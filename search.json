[{"title":"React专题","path":"/面试题/React专题/","content":"如何创建 React 项目123456npm install create-react-app -gcreate-react-app ./react-basiccd react-basicnpm startnpm init react-app ./react-basic 如何理解 JSX1JSX 是 Facebook 创建的 JavaScript 语法扩展,React 中使用 JSX 来构建用户界面. 在使用 JSX 时有哪些注意事项123456781. JSX 必须有根元素 &lt;&gt;&lt;/&gt;2. 单标记必须闭合 &lt;img src=&quot;&quot; /&gt;3. 在 JSX 的外部可以加上小括号用于美化其对其方式4. 只有表达式才可以嵌入到 JSX 中, 非表达式不可以 if else for switch5. 属性名称遵循驼峰式命名法6. Null undefined true false 可以被渲染 但是渲染的结果是空7. JSX 中不能直接渲染对象8. 使用 className 替换 class、使用 htmlFor 替换 for 如何将对象类型的数据直接嵌入 JSX 中1要将对象转换为对象的字符串格式才可以。JSON.stringify(obj) 什么是条件渲染, 在 React 中有哪些手段可以实现条件渲染。12根据条件决定渲染什么内容if 三元运算 逻辑运算 如何实现列表渲染121. 先通过map方法将纯数据数组转换为JSX数组2. 将JSX数组直接插入到表达式中进行展开 在 React 中如何使用本地图片1234import img from &quot;some/path&quot;;const img = require(&quot;some/path&quot;);&lt;img src=&#123;img&#125; /&gt; 简要说明如何为元素绑定事件1234事件名称采用驼峰式命名法, 将事件名称直接作为属性添加到元素的身上事件名称对应的值,就是事件处理函数本身&lt;element onClick=&#123;() =&gt; &#123;&#125;&#125;&gt;&lt;/element&gt; 什么是组件、组件为开发者带来了哪些好处12345组件就是可以被整合的零部件，React中采用组件化进行开发就是将一个完整页面拆分成多个小部分在组合一个组件就是页面中的一小块区域, 要包含 html 结构、css 样式、javascript 逻辑React 中有两种组件：函数式组件和class组件。提升代码的扩展性和可维护性。 如何为组件添加组件级样式12341. 创建样式表文件，一般以文件名.module.css结尾2. 在组件中通过import styles from &quot;样式文件&quot; 进行导入3. 在组件中通过 className 使用样式表中的样式 &lt;element className=&#123;styles.样式表中的类名&#125;/&gt; 类组件如何声明组件状态、如何获取组件状态、如何修改组件状态123将组件状态存储到state属性中，state属性的值就是组件的状态，在render方法中通过this.state.属性方法进行获取组件状态，通过this.setState方法进行修改组件的状态 类组件中的 constructor 方法、render 方法中的 this 指向谁?1指向当前类的实例对象 如何使事件处理函数中的 this 指向当前组件的实例对象1231. 将事件处理函数更改为箭头函数2. 使用 bind 更改事件处理函数中的this3. &lt;element onClick=&#123;() =&gt; this.clickHandler()&#125; /&gt; 在类组件中如何获取 DOM 对象 12345678import &#123; createRef &#125; from &quot;react&quot;;class App extends React.Component &#123;\tdivRef = createRef();\trender() &#123; return &lt;div ref=&#123;divRef&#125; onClick=&#123;() =&gt; console.log(divRef.current)&#125;&gt;&lt;/div&gt;\t&#125;&#125; 什么是受控表单、如何实现受控表单 12345678910表单的值由组件状态进行控制, 用户在表单中实时输入的时候, 我们要将用户输入的内容同步到组件状态之中, 开发者要想获取表单值, 只需要从组件状态中进行获取即可.\tclass App extends React.Component &#123; state = &#123; text: &quot;&quot; &#125; render() &#123; return &lt;input type=&quot;text&quot; value=&#123;this.state.text&#125; onChange=&#123;(event) =&gt; this.setState(&#123;text: event.target.value&#125;)&#125;/&gt; &#125;\t&#125; 什么是组件通讯 12数据能够在不同的组件之间进行流动。父组件能够将自己的状态传递到子组件, 子组件可以修改父组件中定义的状态 如果向组件内部传递数据、如何在组件内部获取数据 12345678910通过组件属性的方式(props)&lt;App name=&quot;张三&quot;/&gt;class App extends React.Component &#123;\trender() &#123; this.props.name\t&#125;&#125; 什么是单向数据流动 12数据在组件之间进行流动的时候, 方向只能是从上到下, 也就是说, 只能上层组件中的数据传递到下层组件使数据流动变得简单, 程序更加好维护. props 为什么是只读的. 1为了实现单向实现数据流动, 如果 props 不是只读的, 是可以修改的, 那么单向数据流动将无法实现. 在子组件中如何更新父组件中的状态 1父组件定义修改状态的方法, 父组件将修改状态的方式传递到子组件, 子组件通过父组件传递下来的方法进行状态的修改。 如何实现兄弟组件通讯 1利用状态提升思想, 将兄弟组件之间需要共享的状态提供至它们之间公共的父级中, 然后通过 props 的方式再将状态分别传递到兄弟组件中. 如何实现跨级组件通讯20qz-pylcc 123456789101112131415利用上下文对象实现.import &#123; createContext &#125; from &quot;react&quot;;// Provider 用来保存状态并提供状态// Consumer 用来获取状态const &#123; Provider, Consumer &#125; = createContext();&lt;Provider value=&#123;&#123;name: &quot;张三&quot;&#125;&#125;&gt;\t&lt;App /&gt;&lt;/Provider&gt;&lt;Consumer&gt;\t&#123; (value) =&gt; &lt;div&gt;&#123;value.name&#125;&lt;/div&gt; &#125;&lt;/Consumer&gt; 组件属性校验的意义是什么 123456789101112131. 防止组件的调用者传递错误的属性值类型, 导致组件内部的代码执行出错2. 当组件的调用者传递了错误的属性值时, 给组件的调用者更加精准的错误提示npm install prop-typesimport PropTypes from &quot;prop-types&quot;;class App extends React.Component &#123;\tstatic propTypes = &#123; colors: PropTypes.array.isRequired\t&#125;&#125; 什么是组件属性的默认值 12345我们在定义组件的时候, 可以为即将接收的外部数据设置默认值, 组件的调用者在传值的情况下组件使用调用者传递的值, 没传就是用默认值, 这样可以防止组件代码执行出错.\tclass App extends React.Component &#123; static defaultProps = &#123;&#125;;\t&#125; 什么是组件的生命周期 123从组件创建到销毁, 它经历的整个过程被称之为组件的生命周期.开发者通过组件生命周期函数将业务逻辑插入到组件运行的各个阶段.所谓生命周期函数就是 React 提供的一些固定名字的函数, 在组件运行的各个阶段被自动调用. React 类组件中组件生命周期函数有几大阶段, 分别对应哪些常见的生命周期函数 12345678910111213141516171819202122232425262728291. 挂载阶段\t创建组件、渲染组件视图\tconstructor render componentDidMount\tconstructor: 做一些初始化的工作, 比如更改组件中的函数的this 指向、初始化状态对象、创建引用对象、创建业务逻辑需要的公共属性\trender: 渲染视图、不能直接调用 setState 更新状态\tcomponentDidMount: 操作DOM、发送网络请求、更新组件状态2. 更新阶段\t1. 什么情况下会触发组件更新 1. 组件状态发生变化 2. 父组件更新 3. 强制更新 forceUpdate\t2. render componentDidUpdate componentDidUpdate: 操作DOM、发送网络请求、有条件的更新组件状态3. 卸载阶段\tcomponentWillUnMount\t清理操作、清除定时器、清除事件、清除订阅、清除全局状态 页面初始渲染时要请求的数据要写在哪个生命周期函数中 1componentDidMount 组件卸载之前需要干些什么事情 1清理操作、清除定时器、清除事件、清除订阅、清除全局状态 在调用 setState 方法时传递对象作为参数和传递函数作为参数主要的区别在哪 12345678区别主要体现在同时多次调用 setState 方法时, 传递对象在做状态合并时, 它是覆盖式合并, 传递函数时, 它是累计性合并.this.setState(&#123;count: 1&#125;)this.setState(&#123;count: 1&#125;)this.setState((state) =&gt; (&#123;count: state.count + 1&#125;))this.setState((state) =&gt; (&#123;count: state.count + 1&#125;)) 为什么在调用 setState 方法之后不能立即获取到更新之后的状态值 1234567在 React 中，当调用 setState 方法更新组件的状态时，React 并不会立即更新组件的状态，而是会将状态更新请求放入更新队列中，以便在适当的时候进行更新。这是因为 React 会将多个 setState 方法调用进行合并，以提高性能和优化更新。因此，如果在调用 setState 后立即尝试访问状态值，可能会得到之前的状态值，因为此时更新队列尚未被处理。如果需要在更新完成后访问更新后的状态值，可以使用 setState 的第二个参数，即回调函数。回调函数会在组件状态更新完成后被调用，可以在回调函数中访问更新后的状态值。this.setState(&#123;count: this.state.count + 1&#125;, () =&gt; &#123; console.log(this.state.count); // 在回调函数中访问更新后的状态值&#125;); 什么是浅比较 123在 React 中，当一个组件的状态或属性更新时，React 会进行一个称为“比较”的过程来确定是否需要重新渲染组件。浅比较是 React 中一种比较对象的方式，用于检查两个对象是否相等。浅比较只会比较对象的引用，而不会比较对象的值。如果两个对象的引用不同，即使它们的值相同，浅比较也会认为它们是不相等的。如果两个对象的引用相同，即使它们的值已经发生了变化，浅比较仍然认为它们是相等的。 PureComponent 类的作用是什么 123可以防止组件的无效渲染.在组件即将更新之前, PureComponent 会拿着上一次更新组件时使用的 props 和 即将更新组件时使用的 prop 进行比较如果比较结果是相同的, 阻止组件渲染, 因为即使重新渲染, 得到的最终结果也是一样的. shouldComponentUpdate 生命周期函数的作用是什么 1通过 shouldComponentUpdate 生命周期函数的返回值可以决定组件是否继续更新. true 继续更新 false 阻止更新. 组件状态管理存在什么问题 1当组件与组件之间要进行状态共享的时候, 状态需要在不同的组件之间通过 props 的方式进行传递, 传递过程非常复杂. 和组件状态管理相比, 全局状态管理有什么优势 1全局状态管理是指将状态存储到一个脱离于组件的地方进行管理, 所有组件都可以直接获取状态, 直接修改状态, 避免了组件状态管理中的 状态需要在不同的组件之间进行传递的复杂过程. 简要描述 Redux 管理状态的模式 123456在 Redux 中通过 store 对象进行状态的管理, store 对象可以存储状态, 有提供了管理状态的方法.通过 store.getState 获取状态, 通过 store.dispatch 修改状态, 通过 store.subscribe 订阅状态的变化.在 Redux 中对状态进行的任何修改都需要通过 action 对象进行描述, action 对象中有 type 属性, 它就是具体的用来描述的属性视图中要想修改状态, 必须调用 dispatch 方法接收 action 对象, 该命令会被 reducer 函数接收, 在 reducer 函数要对 action.type 进行匹配根据 action 的类型对状态进行不同的处理, 处理完成之后要返回, 给 store 进行存储. 在 Redux 中通过什么方法创建 store 对象, 并描述该方法的使用方式 1const store = createStore(reducer, initialState) 描述 action 对象的作用是什么、什么是 action creator、为什么会有 action creator 这样的概念 123456789在 Redux 中, action 对象用于描述当前要对状态进行怎样的操作, 它就是一个命令, 通过 dispatch 进行发送.action creator 就是一个用于返回 action 对象的函数它存在的目的是消除相似 action 对象的重复定义&#123; type: &quot;increment&quot;, payload: 1 &#125;&#123; type: &quot;increment&quot;, payload: 2 &#125;&#123; type: &quot;increment&quot;, payload: 3 &#125;const increment = (payload) =&gt; (&#123;type: &quot;increment&quot;, payload&#125;) 简要描述 reducer 函数的用法 12345reducer 就是一个函数, 在 Redux 中用于对状态进行更新, 是具体的写更新状态代码的地方.reducer 函数接收两个参数, 第一个参数是要管理的状态对象, 第二个参数是 action 对象在 reducer 函数内部, 我们通常通过编写 switch case 对 action 类型进行匹配, 根据不同的 action 类型, 对状态进行不同的更新.在状态更新完成之后, 必须要返回新的状态, 如果没有匹配到 action type, 默认就返回当前状态.在 reducer 中不能做任何和修改状态无关的事情, 比如发送 ajax 请求, 开启定时器等 在 redux 中使用什么方法获取状态仓库中存储的状态对象 1在 Redux 中获取状态仓库中存储的状态对象，可以使用 Redux 提供的 getState() 方法。getState() 方法是 Redux Store 对象中的一个函数，用于返回当前的状态树对象。 在 redux 中使用什么方法分发 action 对象 1在 Redux 中分发 action 对象，可以使用 Redux 提供的 dispatch() 方法。dispatch() 方法是 Redux Store 对象中的一个函数，用于向 reducer 发送 action 对象，并触发 state 的更新。 react-redux 这个库的作用是什么? 1解决 redux 状态更新组件不更新的问题 简要描述 react-redux 中提供的 connect 方法的作用及用法 12345678react-redux 提供了 connect 方法让组件获取状态connect 方法有两个参数都是函数, 第一个函数用于将 redux 状态映射到组件的 props 对象中第二个函数用于将修改状态的逻辑映射到组件的 props 对象中connect 方法在调用之后又返回一个函数, 通过调用该函数告诉 redux 状态及修改状态的逻辑要映射到哪一个组件中connect 方法返回的方法在调用之后返回了一个被增强了的组件, 外部要渲染该组件export default connect(mapStateToProps, mapDispatchToProps)(App) 为什么要将 action 对象中的 type 属性值定义为常量 20qz-pylcc 12345在 Redux 中，将 action 对象中的 type 属性值定义为常量，可以提高应用的可维护性和可重用性。具体来说，将 action 类型定义为常量，可以避免由于手误或代码错误而导致的拼写错误，从而避免出现难以追踪的 bug。此外，常量还可以更好地传达代码中的含义，从而提高代码的可读性和可维护性。另外，定义 action 类型为常量还可以增加代码的重用性。在 Redux 应用中，可能有多个 reducer 需要处理相同的 action 类型，如果将 action 类型定义为常量，可以将这些常量集中到一个文件中，然后在多个 reducer 中重复使用，从而减少重复的代码。 reducer 函数为什么要被分解再组合20qz-pylcc 1234在 Redux 应用中，reducer 函数被分解再组合可以提高应用的可维护性和可扩展性。具体来说，将 reducer 函数分解成多个小的 reducer 函数，可以将不同部分的状态分开管理，从而使代码更加清晰和易于维护。Redux 提供了 combineReducers() 函数，它可以将多个 reducer 函数合并成一个 reducer 函数，并生成一个新的状态树对象。这样，我们可以将不同部分的状态分开管理，并将它们组合成一个完整的状态树，从而使代码更加清晰、易于维护和可扩展。 如何理解 redux 中间件 12redux 中间件允许开发者在修改状态的过程中加入一些中间环节, 在 reducer 函数中不能做的事情, 全部都要在中间件中去做比如异步请求、定时器、控制台输出、DOM 操作、localStorage redux-thunk 中间件的作用是什么, 如何使用该中间件。 12345678910111213扩展了 dispatch 方法的功能, 使 dispatch 方法可以接收函数作为参数, 开发者可以将副作用代码写在该函数中, 比如异步请求,其实就是让开发者在 redux 的工作流程中加入异步代码.npm install redux-thunkimport thunk from &quot;redux-thunk&quot;;createStore(reducer, applyMiddleware(thunk));dispatch(async (dispatch) =&gt; &#123;\t// 异步操作\tdispatch();&#125;) BrowserRouter 内部使用的是什么 API 实现的路由功能 123456在 React Router 库中，BrowserRouter 使用 HTML5 的 history API 实现了路由功能。history API 是 HTML5 中引入的一组 API，用于在浏览器中操作浏览器的历史记录和地址栏。使用 history API，我们可以通过 JavaScript 修改 URL，同时还可以监听 URL 的变化，从而实现前端路由功能。BrowserRouter 组件使用了 history API 中的 pushState() 和 replaceState() 方法，将 URL 中的路径与组件进行匹配，以确定要渲染的组件。当 URL 发生变化时，BrowserRouter 会通过 props 将新的 location 信息传递给子组件，从而触发重新渲染。 在 react-router-dom 路由库中使用什么组件配置路由规则, 使用的是什么属性 1&lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt; 使用哪些组件可以实现 a 链接跳转? 它们之间有什么区别 1234&lt;Link&gt;&lt;/Link&gt;&lt;NavLink&gt;&lt;/NavLink&gt;NavLink 链接被激活之后有高亮的类名 使用哪些方法可以实现编程式导航? 它们之间有什么区别 12push 正常跳转, 记录会被添加到浏览器的历史记录中, 可以回退replace 跳转, 但是跳转记录不会被添加到浏览器的历史记录中, 不可以回退 什么是查询参数？ 12查询参数是指 URL 中的一部分，通常用于向服务器传递额外的信息。查询参数以 &quot;?&quot; 符号开始，后面是一系列键值对，多个键值对之间使用 &quot;&amp;&quot; 符号分隔。https://www.example.com/search?q=react&amp;lang=en 如何传递查询参数 1&lt;Link to=&quot;/detail?aid=1&quot;&gt;&lt;/Link&gt; 如何接收查询参数20qz-pylcc 1qs.parse(this.props.location.search, &#123;ignoreQueryPrefix: true&#125;) 如何实现路径参数的路由传参 12345678910111. 在路由规则中指定要进入到当前路由需要传递参数 &lt;Route path=&quot;/detail/:id&quot; /&gt;2. 在链接中传递参数 &lt;Link to=&quot;/detail/1&quot;&gt;&lt;/Link&gt;3. 接收参数 match.params Switch 组件的作用是什么 12默认情况下, 路由规则是从上到下进行匹配的, 直到匹配完所有的路由规则, 匹配到哪些, 就渲染哪些路由规则对应的组件Switch 组件可以指定在匹配到一个规则以后停止匹配 在路由规则中匹配请求路径时, 它的匹配方式模式有哪些? 123精确匹配: 路由规则和请求路径完全吻合才能匹配成功, 要启用精确匹配, 需要 Route 组件的身上添加 exact 属性模糊匹配(默认行为): 只要路由规则被请求路径所包裹即可匹配成功 /home =&gt; / 、 /home 在路由规则中如何定义 404 页面组件对应的路由规则. 123路由规则从上到下依次进行匹配, 如果所有的路由规则都没有匹配成功, 就让它匹配最后一条&lt;Route component=&#123;NotFound&#125;/&gt; 如何在普通组件中获取路由相关的信息. 1withRouter 路由守卫组件的作用是什么. 1对路由组件进行的保护, 在进入组件之前, 判断你可以不以进入, 如果可以就让你进， 否则就不让你进. 路由组件懒加载有什么好处? 如何实现路由组件懒加载 123提升首页加载速度.lazy Suspense 如何在 JSX 中通过组件的方式进行页面跳转. 1&lt;Redirect to=&quot;&quot;/&gt; React 中的 render()的用途是什么？ 1在class组件中使用Render()，来返回在组件中显示的HTML。 它被用作读取props和state并将JSX代码返回到应用的根组件。 什么是 Props？ 12Props也被称作属性。它们将数据从一个组件传递到另一个组件（从父组件到子组件）。它们通常被用来呈现动态数据。子组件永远不能将props发送到父组件，因为此流程是单向的（父到子）。 如何区分 State 和 Props 123State和props是具有不同功能的JavaScript对象。props用于将数据从父组件传输到子组件，而state是对本地数据的存储，仅对当前组件可用，不能与其他组件共享。 useState 是什么？20qz-pylcc 1useState Hook是一个可以在函数组件中使用状态变量的存储。你可以把初始状态传给这个函数，它将返回一个包含当前状态值（不一定是初始状态）的变量和另一个更新这个值的函数。 useEffect 是什么？ 12345useEffect Hook允许你在组件中执行副作用，例如数据获取、直接更新DOM、使用setTimeout()之类的计时器等等。这个hook接受两个参数：回调函数和依赖项，它们允许您控制何时执行副作用。注意：第二个参数是可选的。 useMemo() hook 的用途是什么？ 12useMemo() hook在函数组件中使用来记忆昂贵的函数，以便它们仅在设定的输入更改时调用，而不是每次渲染都调用。它类似于useCallback hook，用于优化React函数组件的渲染行为。 React 的功能是什么？ 1231.它使用虚拟DOM而不是真实DOM。2.它使用服务器端渲染。3.它遵循单向数据流或数据绑定。 列出 React 的一些主要优点。 12345它提高了应用程序的性能它可以方便地在客户端和服务器端使用由于有了JSX，代码的可读性提高了React易于与其他框架（如Meteor，Angular等）集成使用React，编写UI测试用例变得非常容易 对 Virtual DOM 有什么了解？解释它的工作。 1虚拟DOM是轻量级的JavaScript对象，其最初只是真实DOM的副本。 它是一个节点树，列出了元素，它们的属性和内容作为对象及其属性。React的render函数从React组件中创建一个节点树。然后，它会响应由用户或系统执行的各种操作引起的数据模型中的突变来更新此树。 state 和 props 有何区别？ 1234567定义位置不同：state 是在组件内部定义的，而 props 是从组件的父组件传递进来的。可变性不同：state 是组件的内部状态，可以通过调用 setState() 方法来更新它的值，而 props 是从父组件传递进来的，通常是不可变的。作用不同：state 用于存储组件的数据和状态，可以用来更新组件的视图。props 则用于从父组件向子组件传递数据和方法，用于子组件的渲染。访问方式不同：在组件内部可以通过 this.state 来访问组件的 state 值，而在组件内部可以通过 this.props 来访问父组件传递给子组件的 props 值。 什么是高阶组件？ 1高阶组件是重用组件逻辑的高级方法。基本上，这是从React的组成性质衍生的模式。HOC是自定义组件，在其中包裹了另一个组件。他们可以接受任何动态提供的子组件，但不会修改或复制其输入组件中的任何行为。您可以说HOC是“纯”组件。 Redux 遵循的三个原则是什么？ 1231.单一事实来源：整个应用程序的状态存储在单个存储中的对象/状态树中。单一状态树使跟踪随时间变化以及调试或检查应用程序变得更加容易。2.状态是只读的：更改状态的唯一方法是触发操作。动作是描述更改的普通JS对象。就像状态是数据的最小表示一样，操作是数据更改的最小表示。3.使用纯函数进行更改： 为了指定操作如何转换状态树，您需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。 对 React refs 的理解？应用场景？ 12345678910111213在 React 中，Refs 是一种允许我们访问 DOM 节点或者组件实例的方法。Refs 提供了一种方式，允许我们直接操作 DOM 节点或组件实例，而无需经过 React 的 Virtual DOM。Refs 的主要作用是解决访问组件内部 DOM 节点的问题。在 React 中，由于组件的渲染是通过 Virtual DOM 实现的，因此在某些情况下需要直接访问组件内部的 DOM 节点，比如进行动画效果、获取输入框的值等等。应用场景：获取组件内部的 DOM 节点，比如获取表单元素的值、滚动条的位置等。与第三方库或原生 API 集成，比如集成 Google 地图、视频播放器等，需要访问 DOM 节点或组件实例。控制组件的生命周期，比如手动触发组件的某些生命周期函数。处理焦点、选择等问题，比如实现自动聚焦、选中文本等。 React-Router 的路由模式有哪些？ 123456789BrowserRouter：基于 HTML5 的 History API，使用 HTML5 中的 pushState() 和 replaceState() 方法来实现路由跳转。HashRouter：使用 URL 中的哈希值来实现路由跳转，这是一种旧的路由实现方式。MemoryRouter：使用内存中的 history 实现路由跳转，不会改变 URL。StaticRouter：用于服务器端渲染，通过将 URL 作为 props 传递给组件来实现路由跳转。NativeRouter：用于 React Native 开发，提供了与 React Native 导航 API 一致的路由实现方式。 React 中的 key 有什么作用？ 123跟Vue一样，React 也存在 Diff算法，而元素key属性的作用是用于判断元素是新创建的还是被移动的元素，从而减少不必要的Diff因此key的值需要为每一个元素赋予一个确定的标识 设置 key 的注意事项有哪些？ 123key 应该是唯一的key不要使用随机值（随机数在下一次 render 时，会重新生成一个数字）避免使用 index 作为 key 什么是 HTTP? 12HTTP（Hypertext Transfer Protocol）是一种用于传输超文本的协议。它是 Web 的基础，用于客户端和服务器之间的通信，客户端通过 HTTP 请求获取 Web 页面或资源，服务器通过 HTTP 响应返回 Web 页面或资源。HTTP 通常使用 TCP（Transmission Control Protocol）作为传输协议，在传输层之上实现了一个面向请求和响应的客户端和服务器之间的通信。HTTP 请求由客户端发起，包含请求方法、URL、HTTP 版本号、请求头和请求正文等信息；HTTP 响应由服务器返回，包含响应状态码、响应头和响应正文等信息。 什么是 HTTPS？ 1HTTPS（Hypertext Transfer Protocol Secure）是基于 HTTP 协议的安全版本，它使用了 SSL/TLS 加密协议来保护数据传输的安全性和完整性。HTTPS 通过 SSL/TLS 协议对通信进行加密，可以防止数据在传输过程中被窃听和篡改。 HTTPS 的 URL 以 &quot;https://&quot; 开头，常用于传输敏感信息的 Web 应用，比如银行、电商等。 HTTP 和 HTTPS 的区别? 123456789安全性：HTTP 不加密，数据传输容易被窃听和篡改；HTTPS 使用 SSL/TLS 加密协议，保证数据传输的安全性和完整性。端口号：HTTP 默认使用端口号 80，HTTPS 默认使用端口号 443。证书：HTTPS 需要使用 SSL/TLS 数字证书，用于验证服务器的身份和建立安全通道；而 HTTP 不需要证书。性能：HTTPS 比 HTTP 的传输速度慢，因为 HTTPS 需要进行加密和解密操作，增加了服务器的负担和网络延迟。SEO：HTTPS 可以提升网站的搜索引擎排名，因为谷歌等搜索引擎将 HTTPS 作为一个排名因素。 为什么说 HTTPS 比 HTTP 安全? 1HTTPS 比 HTTP 更安全，主要是因为 HTTPS 在数据传输的过程中使用了 SSL/TLS 协议来加密和验证数据的完整性，从而保证了数据的安全性和完整性。 HTTPS 是如何保证安全的？ 12345加密通信：HTTPS 使用 SSL/TLS 协议对通信过程进行加密，防止数据在传输过程中被窃听和篡改。SSL/TLS 协议通过使用公钥和私钥来建立安全通道，加密传输数据。身份验证：HTTPS 使用 SSL/TLS 数字证书对服务器和客户端进行身份验证，防止中间人攻击。SSL/TLS 数字证书是由受信任的第三方机构颁发的，用于验证服务器的身份和建立安全通道。数据完整性：HTTPS 使用消息摘要算法对传输的数据进行验证，保证数据的完整性，防止数据在传输过程中被篡改。消息摘要算法使用哈希函数将原始数据转换成固定长度的摘要值，然后将摘要值发送给接收方进行验证，如果验证失败，则说明数据已经被篡改。 如何理解 UDP 和 TCP? 区别? 12345678UDP（User Datagram Protocol）和 TCP（Transmission Control Protocol）都是用于在网络中传输数据的协议连接性：TCP 是一种面向连接的协议，而 UDP 是一种无连接的协议。TCP 在传输数据之前需要先建立连接，而 UDP 不需要建立连接。可靠性：TCP 是一种可靠的协议，它通过确认和重传机制来保证数据传输的可靠性。UDP 是一种不可靠的协议，它不提供数据重传机制。消息大小限制：TCP 没有消息大小的限制，而 UDP 的消息大小被限制在 65,507 个字节以内。传输效率：由于 TCP 需要建立连接、确认和重传数据等机制，因此其传输效率相对较低。而 UDP 没有这些机制，因此其传输效率相对较高。 DNS 协议 是什么？ 1DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器 说说 DNS 完整的查询过程? 12345678910111213141516首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表若没有命中，则继续搜索操作系统的 DNS 缓存若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起 说说地址栏输入 URL 敲下回车后发生了什么？ 123456URL解析DNS 查询TCP 连接HTTP 请求响应请求页面渲染 说说 HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?20qz-pylcc 12345678910111213141516HTTP1.0：浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接HTTP1.1：引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用在同一个TCP连接里面，客户端可以同时发送多个请求虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着新增了一些请求方法新增了一些请求头和响应头HTTP2.0：采用二进制格式而非文本格式完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行使用报头压缩，降低开销服务器推送 说说 HTTP 常见的状态码有哪些，适用场景？ 12345678910111213141516171819202122232425261 表示消息2 表示成功3 表示重定向4 表示请求错误5 表示服务器错误 100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输 206：一般用来做断点续传，或者是视频文件等大文件的加载 301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名 302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面 304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分 400：参数有误，请求无法被服务器识别 403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回 404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时 503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503 504：网关超时 说一下 GET 和 POST 的区别？ 123456789GET在浏览器回退时是无害的，而POST会再次提交请求。GET产生的URL地址可以被Bookmark，而POST不可以。GET请求会被浏览器主动cache，而POST不会，除非手动设置。GET请求只能进行url编码，而POST支持多种编码方式。GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。GET请求在URL中传送的参数是有长度限制的，而POST没有。对参数的数据类型，GET只接受ASCII字符，而POST没有限制。GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。GET参数通过URL传递，POST放在Request body中 常用的版本管理工具有哪些？ 1git SVN 谈谈你对 git 的理解。 1git是一个分布式版本控制软件，最初目的是为更好地管理Linux内核开发而设计 git 常见的命令 123456git addgit commitgit pushgit pullgit clonegit checkout 说说 Git 中 fork, clone,branch 这三个概念，有什么区别? 123fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓branch 特征与 fork 很类似，fork 得到的是一个新的、自己的代码仓，而 branch 得到的是一个代码仓的一个新分支 说说对 git pull 和 git fetch 的理解？有什么区别？ 12345678910git fetch 命令用于从另一个存储库下载对象和引用git pull 命令用于从另一个存储库或本地分支获取并集成(整合)相同点：在作用上他们的功能是大致相同的，都是起到了更新代码的作用不同点：git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull = git fetch + git merge相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并 如何解决 git 冲突？ 123当Git无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交 说说 git 发生冲突的场景？ 1234一般情况下，出现分支的场景有如下：多个分支代码合并到一个分支时多个分支向同一个远端分支推送 git reset 干什么的？ 123reset用于回退版本，可以遗弃不再使用的提交执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容 git revert 是干什么的？ 1跟git reset用法基本一致，git revert 撤销某次操作，此次操作之前和之后的 commit和history都会保留，并且把这次撤销，作为一次最新的提交 get reset 和 git revert 的区别20qz-pylcc 123git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commitgit reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别 当你开发到一半，现在要修改别的分支问题的时候，怎么处理？ 12345可以使用git stash缓存当前区域的代码git stash：保存开发到一半的代码git commit -m &#x27;修改问题&#x27;git stash pop：将代码追加到最新的提交之后","tags":["面试题"],"categories":["面试题"]},{"title":"重点掌握面试题","path":"/面试题/重点掌握面试题/","content":"001：1、react 有哪些性能优化的点 11、https://github.com/brickspert/blog/issues/36 2、v8 垃圾回收机制 1https://juejin.cn/post/6844904016325902344 3、CSS 样式隔离手段 1https://juejin.cn/post/6844904034281734151#heading-9 4、行内元素、块级元素有哪些，区别是什么 123456789101112131415161718什么叫行内元素？常见的span、a、lable、strong、b等html标签都是行内元素什么叫块级元素？常见的div、p、li、h1、h2、h3、h4等html标签都是块级元素行内元素属性:行内元素属性标签它和其它标签处在同一行内行内元素属性标签无法设置宽度，高度 距顶部距离 距底部距离行内元素属性标签的宽度是直接由内部的文字或者图片等内容撑开的行内元素属性标签内部不能嵌套行属性标签（a链接内不能嵌套其他链接）块级元素属性:每一个块级元素属性标签都是从新的一行开始，而且之后的元素也都会从新的一行开始（因为每一个块属性标签都会直接占据一整行的内容，导致下面的内容也只能从新的一行开始）块级元素属性标签都是可以设置宽度、高度，行高，距顶部距离，距底部距离块级元素属性标签的宽度假如不做设置，会直接默认为父元素宽度的100%块级元素属性标签是可以直接嵌套的p标签中不能嵌套div标签 5、聊下你知道的浏览器架构 12345678910111213141516171819浏览器进程（Browser process）浏览器进程负责管理 Chrome 应用本身，包括地址栏、书签、前进和后退按钮。同时也负责可不见的功能，比如网络请求、文件按访问等，也负责其他进程的调度。渲染进程（Renderer process）渲染进程负责站点的渲染，其中也包括 JavaScript 代码的运行，web worker 的管理等。插件进程（Plugin process）插件进程负责为浏览器提供各种额外的插件功能，例如 flash。GPU 进程（GPU process）GPU 进程负责提供成像的功能。当然还有其他像扩展进程或工具进程等其他进程，可以在 Chrome 的 Task Manager 面板中查看，面板中列出了运行的进程和其占用的 CPU、内存情况。https://xie.infoq.cn/article/5d36d123bfd1c56688e125ad3 6、是否有写过 webpack 插件 12看下webpack.config.js 如果没有运行 yarn eject 就会解包处理config文件夹，文件夹中包含。https://juejin.cn/post/6844903789804126222 7、websocket 建立过程 1https://blog.csdn.net/LL845876425/article/details/106393358 8、合并二维有序数组成一维有序数组 123arr.reduce((m,n)=&gt;m.concat(n))arr.flat()[].concat.apply([],arr) 9、实现防抖函数 1234567891011121314151617181920212223242526E:const debounce = (func, wait) =&gt; &#123; let timer return () =&gt; &#123; clearTimeout(timer) timer = setTimeout(func, wait); &#125;&#125;D:function debounce(callback,delay)&#123; let timer=null; var that=this; return function()&#123; var args=Array.prototype.slice.call(arguments); if(timer !== null)&#123; clearTimeout(timer) &#125; timer=setTimeout(()=&gt;&#123; callback.apply(that,args) &#125;,delay) &#125;&#125; 10、Vue 首屏白屏或者加载慢如何解决 1https://juejin.cn/post/6995455015972241444 11、Vue 线上环境和开发环境如何切换 1.env文件或者env,js文件，再通过process.env判断切换 12、谈谈 axios 拦截器 12345请求拦截器和响应拦截器;请求拦截器;axios.interceptors.request.use(func);响应拦截器;axios.interceptors.response.use(func); 13、hash 和 history 路由的区别 1https://blog.csdn.net/Charissa2017/article/details/104779412 14、call，apply 和 bind 的作用和区别？ 12345678910111213141516171819202122232425262728293031323334353637call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数。他们俩之间的差别在于参数的区别，call和apply的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。1、判断变量类型： &lt;script&gt; let arr1 = [1, 2, 3]; let str1 = &#x27;string&#x27;; let obj1 = &#123; name: &#x27;thomas&#x27; &#125;; function isArray(obj) &#123; return Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;; &#125; console.log(fn1(arr1)); // true // 判断类型的方式，这个最常用语判断array和object，null(因为typeof null等于object) console.log(Object.prototype.toString.call(arr1)); // [object Array] console.log(Object.prototype.toString.call(str1)); // [object String] console.log(Object.prototype.toString.call(obj1)); // [object Object] console.log(Object.prototype.toString.call(null)); // [object Null] &lt;/script&gt; 2、利用call和apply做继承 function Animal(name)&#123; this.name = name; this.showName = function()&#123; console.log(this.name); &#125; &#125; function Cat(name)&#123; Animal.call(this, name); &#125; // Animal.call(this) 的意思就是使用this对象代替Animal对象，那么 // Cat中不就有Animal的所有属性和方法了吗，Cat对象就能够直接调用Animal的方法以及属性了 var cat = new Cat(&quot;TONY&quot;); cat.showName(); //TONY 参考给大家发的有道文档 15、useMemo 的作用 12数据缓存机制，避免在每次渲染时都进行高开销的计算。https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo 16、react 中发送请求一般在哪个 hook 中 1useEffect 17、如何更新组件的状态 1234rendersetState(class component)forceUpdate(class component)useState (function component) 18、如何监听 react 状态更新 12componentWillUpdateuseEffect 19、Vue 中的响应式原理 12345678910Vue不支持IE8以下版本的浏览器，因为Vue是基于 Object.defineProperty 来实现数据响应的，而Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因；Vue通过Object.defineProperty的 getter/setter 对收集的依赖项进行监听,在属性被访问和修改时通知变化,进而更新视图数据；受现代JavaScript 的限制 (以及废弃 Object.observe)，Vue不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让Vue转换它，这样才能让它是响应的。shim:shim可以将新的API引入到旧的环境中，而且仅靠就环境中已有的手段实现。意思就是Object.defineProperty这个特性是无法使用低级浏览器中的方法来实现的，所以Vue不支持IE8以及更低版本的浏览器。第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲 染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者， 一旦数据有变动，收到通知，更新视图。第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:\t1、在自身实例化时往属性订阅器(dep)里面添加自己\t2、自身必须有一个 update()方法\t3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模 板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据 变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。 20、Vue-Router 有哪几种路由守卫? 12345678910全局守卫router.beforeEach 全局前置守卫router.beforeResolve 全局解析守卫router.afterEach 全局后置钩子路由独享守卫beforeEnter路由组件内的守卫beforeRouteEnterbeforeRouteUpdatebeforeRouteLeave 21、简述 Vuex 的数据传递流程 1234561、通过new Vuex.Store()创建一个仓库 state是公共的状态，state---&gt;components渲染页面2、在组件内部通过this.$store.state.属性 来调用公共状态中的state，进行页面的渲染。3、当组件需要修改数据的时候，必须遵循单向数据流。通过this.$store.dispatch来触发actions中的方法4、actions中的每个方法都会接受一个对象 这个对象里面有一个commit方法，用来触发mutations里面的方法5、mutations里面的方法用来修改state中的数据 mutations里面的方法都会接收到2个参数 一个是store中的state另外一个是需要传递到参数6、当mutations中的方法执行完毕后state会发生改变，因为vuex的数据是响应式的 所以组件的状态也会发生改变 22、Vue 和 jQuery 两者之间的区别是什么 123456789jquery直接操作domVue不直接操作dom，采用虚拟domVue通过数据驱动界面jquery通过选择器选取元素，进行取值赋值、事件绑定等操作Vue对项目的侵入较强。 23、Object.defineProperty 和 Proxy 的区别 12345671）Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化；Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has等等是Object.defineProperty 不具备的；Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty 只能遍历对象属性直接修改；Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的 新标准的性能红利；2）Object.defineProperty 的优势如下: 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill。 24、Vue 怎么在组件中监听路由参数的变化？ 12第一种 watch: &#123; &#x27;$route&#x27;(to, from) &#123; // 在此处监听 &#125;, &#125;,第二种beforeRouteUpdate (to, from, next) &#123; //这里监听 &#125;, 25、watch、methods 和 computed 的区别? 123456789101．computed：计算属性将被混入到Vue实例中。所有getter和setter的this上下文自动地绑定为Vue实例。2．methods： methods将被混入到Vue实例中。可以直接通过VM实例访问这些方法，或者在指令表达式中使用。方法中的this自动绑定为Vue实例。3．watch： 观察和响应 Vue 实例上的数据变动，一个对象，键是需要观察的表达式， 值是对应回调函数。值也可以是方法名，或者包含选项的对象，Vue 实例将会在 实例化时调用 $watch()，遍历 watch 对象的每一个属性。2）三者的加载顺序\t1. computed 是在 HTML DOM 加载后马上执行的，如赋值；（属性将被混入 到 Vue 实例）\t2. methods 则必须要有一定的触发条件才能执行，如点击事件\t3. watch 呢？它用于观察 Vue 实例上的数据变动。3）默认加载的时候 先 computed 再 watch，不执行 methods；4）触发某一事件后 先 computed 再 methods 再到 watch computed 属性 vs method 方法 computed 计算属性是基于它们的依赖进行缓存的。5）总结计算属性computed只有在它的相关依赖发生改变时才会重新求值，当有一个性能开销比较大的的计算属性A，它需要遍历一个极大的数组和做大量的计算，然后我们可能有其他的计算属性依赖于A，这时候，我们就需要缓存，每次确实需要重新加载，不需要缓存时用 methods 26、Vue 循环 key 的作用 1key 的作用主要是为了高效的更新虚拟 DOM。 27、对比 Vue 和 React 的差异。 1234567891011121314相同点：\t数据驱动视图\t组件化\t都使用 Virtual DOM不同点：\t核心思想不同：React：React推崇函数式编程（纯组件），数据不可变以及单向数据流,当然需要双向的地方也可以手动实现， 比如借助onChange和setState来实现。Vue：灵活易用的渐进式框架，进行数据拦截/代理，它对侦测数据的变化更敏感、更精确\t组件写法不同：react：JSX + inline style vue：template\tdiff算法不同\t响应式原理不同：Vue依赖收集，自动优化，数据可变。Vue递归监听data的所有属性,直接修改。当数据改变时，自动找到引用组件重新渲染。React基于状态机，手动优化，数据不可变，需要setState驱动新的state替换老的state。当数据改变时，以组件为根目录，默认全部重新渲染, 所以 React 中会需要 shouldComponentUpdate 这个生命周期函数方法来进行控制 28、ES 中 JavaScript 的数据类型有哪些？ 1Boolean，null，undefined,Number,BigInt,String,Symbol,Object 29、在 JavaScript 中，可以通过哪些方式改变 this 指向。 12345回答这个首先明确下this的指向问题：\t一般来说，在this指向全局对象window（函数），对象里是指向调用对象，构造函数指向，指向实例，事件指向触发的dom对象，箭头函数没有自己的this，指向外层的代码的this，在严格模式下，this为undefined。 改变this指向可以使用call、apply、bind等方法，具体见题14 30、http 常见的 header。 Header 解释 示例 Accept 指定客户端能够接收的内容类型 Accept: text&#x2F;plain, text&#x2F;html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的 web 服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP 授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D; Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1 默认进行持久连接） Connection: close Cookie HTTP 请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给 web 服务器。 Cookie: $Version&#x3D;1; Skin&#x3D;new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的 MIME 信息 Content-Type: application&#x2F;x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的 Email From: &#117;&#115;&#x65;&#x72;&#x40;&#101;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d; Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回 304 代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回 304 代码，参数为服务器先前发送的 Etag，与服务器回应的 Etag 比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为 Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D; Range 只请求实体的一部分，指定范围 Range: bytes&#x3D;500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives/71.html TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q&#x3D;0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP&#x2F;2.0, SHTTP&#x2F;1.3, IRC&#x2F;6.9, RTA&#x2F;x11 User-Agent User-Agent 的内容包含发出请求的用户信息 User-Agent: Mozilla&#x2F;5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache&#x2F;1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning 31、http 中 cache-control 的含义 12Cache-Control 通用消息头字段，被用于在http请求和响应中，通过指定指令来实现缓存机制。详见：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control 32、JavaScript 的对象类型包含。 1数组，函数，正则，日期 33、判断一个变量是值是数组还是对象。 1234567891011121314151617var a = [];// 1.基于instanceofa instanceof Array;// 2.基于constructora.constructor === Array;// 3.基于Object.prototype.isPrototypeOfArray.prototype.isPrototypeOf(a);// 4.基于getPrototypeOfObject.getPrototypeOf(a) === Array.prototype;// 5.基于Object.prototype.toStringObject.prototype.toString.apply(a) === &quot;[object Array]&quot;;//Array.isArray 的polyfillif (!Array.isArray) &#123; Array.isArray = function (arg) &#123; return Object.prototype.toString.call(arg) === &quot;[object Array]&quot;; &#125;;&#125; 34、类数组对象 arguments。 1arguments 是一个对应于传递给函数的参数的类数组对象。arguments对象是所有（非箭头）函数中都可用的局部变量。 35、[“1”,”2”,”3”].map(parseInt) 1234567// parseInt(string, radix) -&gt; map(parseInt(value, index))/* first iteration (index is 0): */ parseInt(&quot;1&quot;, 0); // 1/* second iteration (index is 1): */ parseInt(&quot;2&quot;, 1); // NaN/* third iteration (index is 2): */ parseInt(&quot;3&quot;, 2); // NaN如果radix未指定，且第一个参数为string，radix默认会10。如果radix的小于2或者大于36，返回结果也是NaN。参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/maphttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt 36、JS 模块化规范有哪些？ 1commomJS,AMD.CMD,ES6模块化，...... 37、Array.from 的用法。 1Array.from() 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。console.log(Array.from(&#x27;foo&#x27;));=&gt;[&quot;f&quot;,&quot;o&quot;,&quot;o&quot;] 38、Vue 开发环境和线上环境如何切换 1process.env; 39、Object.defineProperty 和 Proxy 的区别 1参考23题; 40、React 怎么在组件中监听路由参数的变化。 12345678在useEffect()中可以通过history监听路由变化const history = useHistory()useEffect(()=&gt;&#123; history.listen(historyLocation=&gt;....)&#125;)class component props.history 41、对比 Vue 和 React 的差异。 127题 42、React 项目优化的方式有哪些。 1234567减少dom更新次数使用生产版本长列表优化webpack压缩（rollup）缓存https://zh-hans.reactjs.org/docs/optimizing-performance.html 43、Hash 和 history 路由模式的区别？ 123456789hash模式：监听浏览器地址hash值变化，执行相应的js切换网页；history模式：利用history API实现url地址改变，网页内容改变；hash模式：使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。history模式：window.history 属性指向 History 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。每当 history 对象出现变化时，就会触发 popstate 事件。hash 就是指 url 尾巴后的 # 号以及后面的字符，history没有底带#，外观上比hash 模好看些hash回车刷新会加载到地址栏对应的页面，history一般就是404掉了hash 能兼容到IE8， history 只能兼容到 IE10； 44、call，apply 和 bind 的作用和区别 114题 45、谈谈 axios 拦截器。 12345请求拦截器和响应拦截器;请求拦截器;axios.interceptors.request.use(func);响应拦截器;axios.interceptors.response.use(func); 46、谈谈浏览器缓存，如何进行强制缓存？ 1234567891011121314浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中.缓存分为：强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程.协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为： public：所有内容都将被缓存（客户端和代理服务器都可缓存） private：所有内容只有客户端可以缓存，Cache-Control的默认取值 no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效 47、React 如何更改组件的状态，如何去监听组件状态？ 1useEffect(); 48、实现一个算法，生成一个不会重复的 uuid。 123Date.now().toString(16);md5(Date.now());sha1; 49、定义一个方法，实现数组的扁平化 12345678核心代码1、arr.flat(Infinity)2、function flatten(arr) &#123; return arr.reduce((res,next) =&gt;&#123; return res.concat(Array.isArray(next)? flatten(next) : next); &#125;,[]); &#125;3、arr.toString().split(&quot;,&quot;) 50、定义一个方法，实现数组的排序 12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; var middle = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = middle; &#125; &#125; &#125; return arr;&#125; 51、实现浅拷贝的几种方式。 12345671、Object.assign(target,source)2、扩展运算符 let cloneObj = &#123; ...obj &#125;3、concat()let arr = [1,3,4,6,8];let copyArr = arr.concat();console.log(copyArr)4、slice() 52、手写一个浅拷贝。 12345678910111213141516const shallowClone = (target) =&gt; &#123; if (target === &quot;object&quot; &amp;&amp; target !== null) &#123; const cloneTarget = Array.isArray(target) ? [] : &#123;&#125;; for (prop in target) &#123; if (target.hasOwnProperty(prop)) &#123; cloneTarget[prop] = target[prop]; &#125; &#125; return cloneTarget; &#125; return target;&#125;;let arr = [1, 3, 5, 7, &#123; name: &quot;apple&quot; &#125;];let newArr = shallowClone(arr);console.log(newArr); 53、new 的执行过程。 123456789101112function Car()&#123; this.name = &quot;MAN&quot;&#125;var obj = new Car()console.log(obj.name) //MAN大致的执行步骤：创建一个新对象；将构造函数的作用域赋给新对象（this 指向新对象）；执行构造函数中的代码（为这个新对象添加属性）；返回新对象。new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象。 54、new 的实现 123456789101112131415161718192021222324function _new(type) &#123; debugger; if (typeof type !== &quot;function&quot;) &#123; throw &quot;type must be function&quot;; &#125; var args = Array.prototype.slice.call(arguments, 1); let obj = new Object(); //链接空对象到原型上 obj.__proto__ = Object.create(type.prototype); //绑定obj的this上下文 let res = type.apply(obj, args); let isObject = typeof res === &quot;object&quot; &amp;&amp; res !== null; let isFunction = typeof res === &quot;function&quot;; return isObject || isFunction ? res : obj;&#125;function Car(name, color) &#123; this.name = name; this.color = color; Car.prototype.getName = function () &#123; return this.name; &#125;;&#125;let obj11 = _new(Car, &quot;MAN&quot;, [&quot;red&quot;, &quot;blue&quot;]);console.log(obj11); 55、什么是闭包？ 123闭包其实就是一个可以访问其他函数内部变量的函数。即一个定义在函数内部的函数，或者直接说闭包是个内嵌函数也可以。因为通常情况下，函数内部变量是无法在外部访问的（即全局变量和局部变量的区别），因此使用闭包的作用，就具备实现了能在外部访问某个函数内部变量的功能，让这些内部变量的值始终可以保存在内存中。&#x27;闭包产生的本质就是：当前环境中存在指向父级作用域的引用。&#x27; 56、闭包的表现形式。 12341. 返回一个函数，上面讲原因的时候已经说过，这里就不赘述了。2. 在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。3. 作为函数参数传递的形式4. IIFE（立即执行函数），创建了闭包，保存了全局作用域（window）和当前函数的作用域 57、循环引用问题。 12345678910111213141516171819202122232425262728293031323334353637383940for(var i = 1; i &lt;= 5; i ++)&#123; setTimeout(function() &#123; console.log(i) &#125;, 0) console.log(i);&#125;以上输出的结果是？上图的输出结果并不是想象中的 1、2、3、4、5。而是6，为什么呢？原因如下：1、setTimeout 为宏任务，由于 JS 中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 setTimeout 中的回调才依次执行。2、因为 setTimeout 函数也是一种闭包，往上找它的父级作用域链就是 window，变量 i 为 window 上的全局变量，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6。&#x27;解决办法：&#x27;1、最简单的使用es6的let。for(let i = 1; i &lt;= 5; i++)&#123; setTimeout(function() &#123; console.log(i); &#125;,0)&#125;2、利用IIFE 立即执行函数。for(var i = 1;i &lt;= 5;i++)&#123; (function(j)&#123; setTimeout(function timer()&#123; console.log(j) &#125;, 0) &#125;)(i)&#125;3、利用定时器传入第三个参数。for(var i=1;i&lt;=5;i++)&#123; setTimeout(function(j) &#123; console.log(j) &#125;, 0, i)&#125; 58、JavaScript 中改变自身的数组方法。 1pop、push、reverse、shift、sort、splice、unshift，以及两个 ES6 新增的方法 copyWithin 和 fill。 59、JavaScript 中不改变自身的数组方法。 1concat、join、slice、toString、toLocaleString、indexOf、lastIndexOf以及 ES7 新增的方法 includes。 60、简述 promise，promise 有哪些状态？.then 返回的是什么？promise.race,promise.any,promise.all 分别代表什么意思？ 123456789101112131415161、Promise 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。2、待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。已兑现（fulfilled）: 意味着操作成功完成。已拒绝（rejected）: 意味着操作失败。3、因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回的是 promise， 所以它们可以被链式调用。4、Promise.race(iterable)当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。Promise.any(iterable)接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值Promise.all(iterable)这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，","tags":["面试题"],"categories":["面试题"]},{"title":"前端必问基础","path":"/面试题/前端面试必问基础/","content":"1、H5 的新特性有哪些？C3 的新特性有哪些？H5 新特性 1、拖拽释放(Drap and drop) API ondrop 拖放是一种常见的特性，即抓取对象以后拖到另一个位置 在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放 2、自定义属性 data-id 3、语义化更好的内容标签(header,nav,footer ,aside, article, section) 4、音频 ,视频(audio, video) 如果浏览器不支持自动播放怎么办? 在属性中添加 autoplay(谷歌浏览器不支持音频自动播放，但是视频支持静音自动播放) 5、画布 Canvas 5.1）getContext() 方法返回一个用于在画布上绘图的环境 Canvas.getContext(contextID) 参 数 contextID 指定了您想要在画布上绘制的类型。当前唯一的合法值是 “2d”，它指定了二 维绘图，并且导致这个方法返回一个环境对象，该对象导出一个二维绘图 API 5.2）cxt.stroke() 绘制线条 5.3）canvas 和 image 在处理图片的时候有什么区别? image 是通过对象的形式描述图片的,canvas 通过专门的 API 将图片绘制在画布上. 6、 地理(Geolocation) API 其实 Geolocation 就是用来获取到当前设备的经纬度（位置） 7、 本地离线存储 localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间， 直到手动去删除 8、 sessionStorage 该数据对象临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页 之后将会删除这些数据。 9、 表单控件 calendar , date , time , email , url , search , tel , file , number 10、新的技术 webworker, websocket , Geolocation CSS3 新特性 1、颜色: 新增 RGBA , HSLA 模式 2、文字阴影(text-shadow) 3、边框: 圆角(border-radius) 边框阴影 : box-shadow 4、盒子模型: box-sizing 5、背景:background-size background-origin background-clip 6、渐变: linear-gradient , radial-gradient 7、过渡 : transition 可实现属性的渐变 8、自定义动画 animate @keyfrom 9、媒体查询 多栏布局 @media screen and (width:800px) {…} 10、border-image 图片边框 11、2D 转换&#x2F;3D 转换;transform: translate(x,y) rotate(x,y) skew(x,y) scale(x,y) 12、字体图标 iconfont&#x2F;icomoon 13、弹性布局 flex 2、如何使一个盒子水平垂直居中？方法一：利用定位 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .parent &#123; width: 500px; height: 500px; border: 1px solid #000; position: relative; &#125; .child &#123; width: 100px; height: 100px; border: 1px solid #999; position: absolute; background-color: red; top: 50%; left: 50%; margin-top: -50px; margin-left: -50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt;&lt;div class=&quot;child&quot;&gt;我是子元素&lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 方法二：利用 margin:auto; 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;&lt;/head&gt;&lt;/html&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style&gt; .parent &#123; width: 500px; height: 500px; border: 1px solid #000; position: relative; &#125; .child &#123; width: 100px; height: 100px; border: 1px solid #999; position: absolute; background-color: aqua; margin: auto; top: 0; left: 0; right: 0; bottom: 0; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;我是子元素&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 方法三：利用 display：flex;设置垂直水平都居中 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .parent &#123; width: 500px; height: 500px; border: 1px solid #000; display: flex; justify-content: center; align-items: center; &#125; .child &#123; width: 100px; height: 100px; border: 1px solid #999; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;我是子元素&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 方法四：利用 transform 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .parent &#123; width: 500px; height: 500px; border: 1px solid #000; position: relative; &#125; .child &#123; width: 100px; height: 100px; border: 1px solid #999; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;我是子元素&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、CSS 的盒模型？盒子模型（Box Modle）可以用来对元素进行布局，包括内边距，边框，外边距，和实际 内容这几个部分。 盒子模型分为两种: 第一种是 W3C 标准的盒子模型（标准盒模型） 第二种 IE 标准的盒子模型（怪异盒模型） 标准盒模型与怪异盒模型的表现效果的区别之处： 1、标准盒模型中 width 指的是内容区域 content 的宽度 height 指的是内容区域 content 的高度 标准盒模型下盒子的大小 &#x3D; content + border + padding + margin 2、怪异盒模型中的 width 指的是内容、边框、内边距总的宽度（content + border + padding）；height 指的是内容、边框、内边距总的高度 。 怪异盒模型下盒子的大小&#x3D;width（content + border + padding） + margin 4、CSS 单位中 px、em 和 rem 的区别？1、px 像素（Pixel）。绝对单位。像素 px 是相对于显示器屏幕分辨率而言的，是一个虚拟长度单位，是计算机系统的数字化图像长度单位。 2、em 是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺 寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小因此并不是一 个固定的值。 3、rem 是 CSS3 新增的一个相对单位（root em，根 em），使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML 根元素。 5、为什么会出现浮动？浮动元素会引起什么问题？如何清除浮动？浮动将元素排除在普通流之外，即元素将脱离文档流，不占据空间。浮动元素碰到包含它的边界或者浮动元素的边界停留 。 为什么需要清除浮动 1、子元素浮动后，不占位置，父元素的高度无法被撑开，影响与父元素同级的元素； 2、与浮动元素同级的非浮动元素（内联元素）会跟随其后； 3、若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解 决方法 清除浮动的方式 1、使用 CSS 中的 clear:both（; 放一个空的标签，并设置上述 css，注意该标签必须是块元素）, 属性来清除元素的浮动 可解决 2、3 问题 2、对于问题 1，添加如下样式，给父元素添加 clearfix 样式： 12345678.clearfix:after &#123; content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125;/* for IE */ .clearfix&#123; *zoom:1; &#125; 3、给父级元素设置双伪元素； 123456789101112131415161718192021.clearfix:after&#123; content:&quot;&quot;; /*设置内容为空*/ height:0; /*高度为 0*/ line-height:0; /*行高为 0*/ display:block; /*将文本转为块级元素*/ visibility:hidden; /*将元素隐藏*/ clear:both; /*清除浮动*/ &#125;.clearfix&#123; zoom:1; /*为了兼容 IE*/ &#125; 4、给父级元素设置 overflow：hidden；或 overflow：auto；本质是构建一个 BFC。 5、如何解决 margin“塌陷”？外边距塌陷共有两种情况： 第一种情况：两个同级元素，垂直排列，上面的盒子给 margin-bottom 下面的盒子给 margin-top，那么他们两个的间距会重叠，以大的那个计算。解决这种情况 的方法为：两个外边距不同时出现 第二种情况：两个父子元素，内部的盒子给 margin-top，其父级也会受到影响，同时产生上边距，父子元素会进行粘连。 解决方案： 1、为父盒子设置 border，添加 border 后父子盒子就不是真正意义上的贴合（可以设置成透 明：border：1px solid transparent）； 2、为父盒子添加 overflow：hidden； 3、为父盒子设定 padding 值； 4、为父盒子添加 position：fixed； 5、为父盒子添加 display：table； 6、利用伪元素给父元素的前面添加一个空元素 1234567.father::before &#123; content:&#x27;&#x27;; display:table; &#125; 6、BFC 是什么？定义 BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有 Block-level box 参与，它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干 布局规则 1、内部的 Box 会在垂直方向，一个接一个地放置。 2、Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin会发生重叠。 3、每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 4、BFC 的区域不会与 float box 重叠 5、BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此 。 6、计算 BFC 的高度时，浮动元素也参与计算。 哪些元素会生成 BFC： 1、根元素 2、float 属性不为 none 3、position 为 absolute 或 fixed 4、display 为 inline-block， table-cell， table-caption， flex， inline-flex 5、overflow 不为 visible 7、JavaScript数据类型。基本类型：Number、String、Boolean、null、undefined，symbol。 引用类型：Object 8、数据类型的检测。12345678910111213常用的数据类型检测有三种方式。1、typeof2、instanceof3、Object.prototype.toString.call(&#123;&#125;) // 同上结果，加上call也ok//通用方法 检测类型function getType(obj)&#123; let type = typeof obj; if (type !== &quot;object&quot;) &#123; // 先进行typeof判断，如果是基础数据类型，直接返回 return type; &#125; // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果 return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/, &#x27;$1&#x27;); // 注意正则中间有个空格&#125; 9、实现浅拷贝的几种方法12345671、Object.assign(target,source)2、扩展运算符 let cloneObj = &#123; ...obj &#125;3、concat() let arr = [1,3,4,6,8];let copyArr = arr.concat();console.log(copyArr)4、slice() 10、手写一个浅拷贝12345678910111213141516const shallowClone = (target) =&gt;&#123; if(target === &#x27;object&#x27; &amp;&amp; target !== null) &#123; const cloneTarget = Array.isArray(target) ? []:&#123;&#125;; for(prop in target)&#123; if(target.hasOwnProperty(prop))&#123; cloneTarget[prop] = target[prop] &#125; &#125; return cloneTarget; &#125; return target;&#125;let arr = [1,3,5,7,&#123;name:&#x27;apple&#x27;&#125;];let newArr = shallowClone(arr);console.log(newArr) 11、null，undefined 的区别区别 null 表示一个对象被定义了，值为“空值”； undefined 表示不存在这个值 typeof undefined &#x2F;&#x2F;“undefined” undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但还没有定义。当尝试读取时会返回 undefined； 例如变量被声明了，但没有赋值时，就等于 undefined typeof null &#x2F;&#x2F;“object” null : 是一个对象(空对象, 没有任何属性和方法)； 例如作为函数的参数，表示该函数的参数不是对象； 注意： 在验证 null 时，一定要使用&#x3D;&#x3D;&#x3D; ，因为 &#x3D;&#x3D; 无法分别 null 和 undefined undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义。 典型用法是： 1、变量被声明了，但没有赋值时，就等于 undefined 2、调用函数时，应该提供的参数没有提供，该参数等于 undefined 3、对象没有赋值的属性，该属性的值为 undefined 4、函数没有返回值时，默认返回 undefined null 表示”没有对象”，即该处不应该有值。典型用法是： 4.1） 作为函数的参数，表示该函数的参数不是对象 4.2） 作为对象原型链的终点 12、如何区分数组和对象？方法一：通过 ES6 中的 Array.isArray 来识别 123Array.isArray([]) //true Array.isArray(&#123;&#125;) //false 方法二：通过 instanceof 来识别 123[] instanceof Array //true &#123;&#125; instanceof Array //false 方法三：通过调用 constructor 来识别 123&#123;&#125;.constructor //返回 object [].constructor //返回 Array 方法四：通过 Object.prototype.toString.call 方法来识别 123Object.prototype.toString.call([]) //[&quot;object Array&quot;] Object.prototype.toString.call(&#123;&#125;) //[&quot;object Object&quot;] 13、多维数组降维的几种方法（1）数组字符串化 123let arr = [[222, 333, 444], [55, 66, 77] ] ;arr += &#x27;&#x27;; arr = arr.split(&#x27;,&#x27;); (2) Array .prototype .flat() 12345678var arr1 = [1, 2, [3, 4]]; arr1.flat(); // [1, 2, 3, 4] var arr2 = [1, 2, [3, 4, [5, 6]]]; arr2.flat(); // [1, 2, 3, 4, [5, 6]] var arr3 = [1, 2, [3, 4, [5, 6]]]; arr3.flat(2); // [1, 2, 3, 4, 5, 6] //使用 Infinity 作为深度，展开任意深度的嵌套数组 arr3.flat(Infinity); // [1, 2, 3, 4, 5, 6] (3) 使用 reduce、concat 和递归无限反嵌套多层嵌套的数组 12345var arr1 = [1,2,3,[1,2,3,4, [2,3,4]]]; function flattenDeep(arr1) &#123; return arr1.reduce((acc, val) =&gt; Array.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val), []);&#125;flattenDeep(arr1); // [1, 2, 3, 1, 2, 3, 4, 2, 3, 4] (4) 递归 1234567891011function reduceDimension(arr) &#123; let ret = []; let toArr = function (arr) &#123; arr.forEach( function (item) &#123; item instanceof Array ? toArr(item) : ret.push(item); &#125;); &#125; toArr(arr); return ret;&#125; 14、JavaScript 中的作用域、预解析与变量声明提升？作用域 就是变量的有效范围。 在一定的空间里可以对数据进行读写操作，这个空间就是数据的作用域 1、全局作用域： 最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是 可以访问的； 2、局部作用域： 局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无 法访问的，最常见的例如函数内部。在 ES6 之前，只有函数可以划分变量的作用域，所以 在函数的外面无法访问函数内的变量 3、块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫块级作用域 块级作用域 函数作用域 词法作用域之间的区别： 3.1）块级作用域和函数作用域描述的是，什么东西可以划分变量的作用域 3.2）词法作用域描述的是，变量的查找规则 之间的关系： 1、 块级作用域 包含 函数作用域 2、 词法作用域 与 块级作用域、函数作用域之间没有任何交集， 他们从两个角度描 述了作用域的规则 ES6 之前 JavaScript 采用的是函数作用域+词法作用域，ES6 js 采用的是块级作用域+词 法作用域 预解析 JavaScript 代码的执行是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器执行JavaScript 代码的时候，分为两个过程：预解析过程和代码执行过程 预解析过程： 1.把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值 2.把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用 3.先提升 function，在提升 var 变量提升 变量提升：定义变量的时候，变量的声明会被提升到作用域的最上面，变量的赋值不会提升。 函数提升：JavaScript 解析器首先会把当前作用域的函数声明提前到整个作用域的最前面。 15、如何实现数组的随机排序1234567891011var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];function randSort1(arr) &#123; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; var rand = parseInt(Math.random() * len); var temp = arr[rand]; arr[rand] = arr[i]; arr[i] = temp; &#125; return arr;&#125;console.log(randSort1(arr)); 16、继承的几种方式。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421、原型链继承 prototypeChainInheritance 缺点：内存共享，一个发生改变，另一个也会发生改变function Car()&#123; this.name =&#x27;Volvo&#x27;, this.color = [&#x27;white&#x27;,&#x27;black&#x27;,&#x27;red&#x27;]&#125;function Truck()&#123; this.price = 20000&#125;Truck.prototype = new Car()const obj = new Truck();const obj1 = new Truck();obj.price = 30000;console.log(obj)console.log(obj1)2、构造函数继承 constructorInheritance缺点：父类的引用属性，不会被共享function Car()&#123; this.name = &quot;MAN&quot;&#125;Car.prototype.getName = function()&#123; return this.name&#125;function Truck()&#123; Car.call(this) this.price = 30000&#125;let obj = new Truck()console.log(obj)console.log(Truck.getName())3、组合继承 combinatorial inheritancefunction Car()&#123; this.name = &quot;MAN&quot; this.color = [&#x27;red&#x27;,&#x27;white&#x27;,&#x27;blue&#x27;]&#125;Car.prototype.getName = function () &#123; return this.name&#125;function Truck()&#123; Car.call(this) this.price = 6666&#125;Truck.prototype = new Car()Truck.prototype.constructor = Truckvar obj1 = new Truck()var obj2 = new Truck()obj1.color.push(&#x27;black&#x27;)console.log(obj1.color)console.log(obj2.color)console.log(obj1.getName())console.log(obj2.getName())4、原型式继承 prototypal Inheritance缺点：多个实例的引用类型属性指向相同的内存，存在篡改的可能let car = &#123; name: &#x27;MAN&#x27;, color: [&#x27;red&#x27;,&#x27;gold&#x27;,&#x27;white&#x27;], getName: function ()&#123; return this.name &#125;&#125;let truck = Object.create(car)truck.name = &#x27;Volvo&#x27;;truck.color.push(&#x27;black&#x27;)let lorn = Object.create(truck)lorn.color.push(&#x27;blue&#x27;)console.log(truck.name === truck.getName())console.log(truck.getName())console.log(lorn.color)console.log(car.getName())5、寄生式继承let car = &#123; name: &#x27;MAN&#x27;, color: [&#x27;red&#x27;,&#x27;gold&#x27;,&#x27;white&#x27;], getName: function ()&#123; return this.name &#125;&#125;function clone(original) &#123; let clone = Object.create(original); clone.getColor = function() &#123; return this.color; &#125;; return clone;&#125;let obj = clone(car);console.log(obj.getName());console.log(obj.getColor());6、寄生组合继承function clone(parent,child)&#123; // 解决构造继承中多进行一次构造的过程 child.prototype = Object.create(parent.prototype) child.prototype.constructor = child&#125;function Car()&#123; this.name = &quot;MAN&quot; this.color = [&#x27;red&#x27;,&#x27;white&#x27;,&#x27;black&#x27;]&#125;Car.prototype.getName = function()&#123; return this.name&#125;function Truck()&#123; Car.call(this) this.voice = &#x27;wuwuwuuw^&#x27;&#125;clone(Car,Truck)Truck.prototype.getVoice = function()&#123; return this.voice&#125;let obj = new Truck()console.log(obj)console.log(obj.getName())console.log(obj.getVoice())7、ES6的extends继承class Car &#123; constructor(name) &#123; this.name = name; &#125; getName = function()&#123; console.log(&quot;Car:&quot;,this.name) &#125;&#125;class Truck extends Car&#123; constructor(name,price)&#123; super(name) this.price = price &#125;&#125;const obj = new Truck(&#x27;MAN&#x27;,333333)obj.getName() 17、apply &amp; call &amp; bind 的介绍都可以改变函数 func 的 this 指向。 call 和 apply 的区别在于，传参的写法不同：apply 的第 2 个参数为数组； call 则是从第 2 个至第 N 个都是给 func 的传参； 而 bind 和这两个（call、apply）又不同，bind 虽然改变了 func 的 this 指向，但不是马上执行， 而这两个（call、apply）是在改变了函数的 this 指向之后立马执行。 18、闭包的概念1闭包其实就是一个可以访问其他函数内部变量的函数。即一个定义在函数内部的函数，或者直接说闭包是个内嵌函数也可以。 因为通常情况下，函数内部变量是无法在外部访问的（即全局变量和局部变量的区别），因此使用闭包的作用，就具备实现了能在外部访问某个函数内部变量的功能，让这些内部变量的值始终可以保存在内存中。 &#x27;闭包产生的本质就是：当前环境中存在指向父级作用域的引用。&#x27; 19、如何解决循环引用问题。1234567891011121314151617181920212223242526272829for(var i = 1; i &lt;= 5; i ++)&#123; setTimeout(function() &#123; console.log(i) &#125;, 0)&#125;上图的输出结果并不是想象中的 1、2、3、4、5。而是6，为什么呢？原因如下：1、setTimeout 为宏任务，由于 JS 中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 setTimeout 中的回调才依次执行。2、因为 setTimeout 函数也是一种闭包，往上找它的父级作用域链就是 window，变量 i 为 window 上的全局变量，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6。&#x27;解决办法：&#x27;1、最简单的使用es6的let。for(let i = 1; i &lt;= 5; i++)&#123; setTimeout(function() &#123; console.log(i); &#125;,0)&#125;2、利用IIFE 立即执行函数。for(var i = 1;i &lt;= 5;i++)&#123; (function(j)&#123; setTimeout(function timer()&#123; console.log(j) &#125;, 0) &#125;)(i)&#125;3、利用定时器传入第三个参数。for(var i=1;i&lt;=5;i++)&#123; setTimeout(function(j) &#123; console.log(j) &#125;, 0, i)&#125; 20、dom 节点的 Attribute 和 Property 有何区别？1、什么是 Property 每 个 DOM 节点都是一个 object 对象，有自己的 property 和 method 。 原 则 上 property 应 该 仅 供 js 操 作 ， 不 会 出 现 在 html 中 （ 默 认 属 性 除 外 ：id&#x2F;src&#x2F;href&#x2F;className&#x2F;dir&#x2F;title&#x2F;lang 等），和其他 js object 一样，自定义的 property 也会出现在 object的 for…in 遍历中 2、什么是 Attribute attribute 出现 在 dom 中，js 提供了 getAttribute&#x2F;setAttribute 等方法来获取和改变它的值，最后作用于 html 中，可以影响innerHTML 获取的值。可以通过访问 dom 节点的 attributes 属性来获取改节点的所有的 attribute。（在 IE&lt;9 中,attribute 获取和改变的实际上是 property。） 3、两者之间的区别是 3.1）自定义的 Property 与 Attribute 不同步,不相等 3.2）非自定义的 DOM property 与 attributes 是有条件同步的 3.3）非自定义的属性(id&#x2F;src&#x2F;href&#x2F;name&#x2F;value 等)，通过 setAttribute 修改其特性值可以同步 作用到 property 上，而通过.property 修改属性值有的(value)时候不会同步到 attribute 上，即不会反应到 html 上(除以下几种情况，非自定义属性 在二者之间是同步的)。 21、DOM 和 BOM 的区别1、BOM 1.1) BOM 是 Browser Object Model 的缩写，即浏览器对象模型。 1.2） BOM 没有相关标准。 1.3） BOM 的最根本对象是 window 2、DOM 2.1） DOM 是 Document Object Model 的缩写，即文档对象模型。 2.2） DOM 是 W3C 的标准。 2.3） DOM 最根本对象是 document（实际上是 window.document） 22、如何最小化重绘(repaint)和回流(reflow)重绘:当元素的一部分属性发生改变，如外观、背景、颜色等不会引起布局变化，只需要浏览器根据元素的新属性重新绘制，使元素呈现新的外观叫做重绘。 重排（回流）:当 render 树中的一部分或者全部因为大小边距等问题发生改变而需要 DOM 树重新计算的过程 。 重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置） 方法： 1、需要要对元素进行复杂的操作时，可以先隐藏(display:”none”)，操作完成后再显示 2、需要创建多个 DOM 节点时，使用 DocumentFragment 创建完后一次性的加入 document缓存 Layout 属性值，如：var left &#x3D; elem.offsetLeft; 这样，多次使用 left 只产生一次回流 。 3、尽量避免用 table 布局（table 元素一旦触发回流就会导致 table 里所有的其它元素回流） 4、避免使用 css 表达式(expression)，因为每次调用都会重新计算值（包括加载页面） 5、尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color 6、批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx 23、EventLoop 事件循环机制什么是 Event Loop JavaScript 的事件分两种，宏任务(macro-task)和微任务(micro-task) 宏任务：包括整体代码 script，setTimeout，setInterval 微任务：Promise.then(非 new Promise)，process.nextTick(node 中) 事件的执行顺序——先执行微任务，然后执行宏任务，任务有同步的任务和异步的任务， 同步的进入主线程，异步的进入 Event Table 并注册函数，异步事件完成后 24、判断一个字符串中出现次数最多的字符，统计这个次数12345678910111213141516var str = &#x27;asdfssaaasasasasaa&#x27;;var json = &#123;&#125;;for (var i = 0; i &lt; str.length; i++) &#123; if (!json[str.charAt(i)]) &#123; json[str.charAt(i)] = 1; &#125; else &#123; json[str.charAt(i)]++; &#125;&#125;;var iMax = 0;var iIndex = &#x27;&#x27;;for (var i in json) &#123; if (json[i] &gt; iMax) &#123; iMax = json[i]; iIndex = i; &#125;&#125; alert(&#x27;出现次数最多的是:&#x27; + iIndex + &#x27;出现&#x27; + iMax + &#x27;次&#x27;); 25、将数字 12345678 转化成 RMB 形式 如： 12,345,678123456789//思路：先将数字转为字符， str= str + &#x27;&#x27; ; //利用反转函数，每三位字符加一个 &#x27;,&#x27;最后一位不加； re()是自定义的反转函数，最后再反转回去！ for (var i = 1; i &lt;= re(str).length; i++) &#123; tmp += re(str)[i - 1]; if (i % 3 == 0 &amp;&amp; i != re(str).length) &#123; tmp += &#x27;,&#x27;; &#125;&#125; 26、谈谈你对 Javascript 垃圾回收机制的理解？12341、标记清除（mark and sweep） 这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量， 垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离 开环境” 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被 环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 2、引用计数(reference counting) 在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该 变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以 将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间 在 IE 中虽然 JavaScript 对象通过标记清除的方式进行垃圾回收，但 BOM 与 DOM 对象却是通过 引用计数回收垃圾的，也就是说只要涉及 BOM 及 DOM 就会出现循环引用问题. 27、什么是 Ajax，Ajax 的原理，Ajax 都有哪些优点和缺点？什么是 Ajax Ajax 是“Asynchronous JavaScript and XML”的缩写。他是指一种创建交互式网页应用的网页 开发技术。沟通客户端与服务器，可以在不必刷新整个浏览器的情况下，与服务器进 行 异步通讯的技术 Ajax 的原理 通过 XMLHTTPRequest 对象来向服务器发异步请求，从服务器获得数据，然后用 javascript 来操作 DOM 而更新页面。这其中最关键的一步就是从服务器获得请求数据。 XMLHTTPRequest 是 Ajax 的核心机制，它是在 IE5 中首先引入的，是一种支持异步请求的 技术。 简单的说，也就是 javascript 可以及时向服务器提出请求和处理响应，而不阻塞用户。 达到无刷新的效果。 Ajax 的优点 1、最大的一点是页面无刷新，用户的体验非常好。 2、使用异步方式与服务器通信，具有更加迅速的响应能力。 3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理， 减 轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，Ajax 的原则是“按 需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。 4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。 Ajax 的缺点 1、Ajax 不支持浏览器 back 按钮。 2、安全问题 Ajax 暴露了与服务器交互的细节。 3、对搜索引擎的支持比较弱。 4、破坏了程序的异常机制。 28、常见的 HTTP 状态码以及代表的意义100 &#x3D;&gt; 正在初始化（一般是看不到的） 101 &#x3D;&gt; 正在切换协议（websocket 浏览器提供的） 202 &#x3D;&gt; 表示接受 301 &#x3D;&gt; 永久重定向&#x2F;永久转移 302 &#x3D;&gt; 临时重定向&#x2F;临时转移（一般用来做服务器负载均衡） 304 &#x3D;&gt; 本次获取的内容是读取缓存中的数据，会每次去服务器校验 401 &#x3D;&gt; 未认证，没有登录网站 403 &#x3D;&gt; 禁止访问，没有权限 502 &#x3D;&gt; 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求 503 &#x3D;&gt; 服务器超负荷（假设一台服务器只能承受 10000 人，当第 10001 人访问的时候， 如果服务器没有做负载均衡，那么这个人的网络状态码就是 503） 505 &#x3D;&gt; 服务器不支持请求的 HTTP 协议的版本，无法完成处理。 29、请解释一下 JavaScript 的同源策略同源策略是客户端脚本的重要的安全度量标准。其目的是防止某个文档或脚本从多个不同 源装载。所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能 读取来自同一来源的窗口和文档的属性。 30、为什么会有跨域的问题出现，如何解决跨域问题什么是跨域 指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的,是浏览器对 javascript施加的安全限制，防止他人恶意攻击网站。 解决方案 jsonp cors 反向代理 31、Get 和 Post 的区别以及使用场景区别 1、Get 使用 URL 或 Cookie 传参。而 Post 将数据放在 body 中 2、Get 的 URL 会有长度上的限制，则 Post 的数据则可以非常大 3、Post 比 Get 安全，因为数据在地址栏上不可见 最本质的区别 基于 http 协议进行请求， 其实 GET 和 POST 无区别， 只是请求时的方式不同， 都可以携 带请求体， 也可以在 URL 带参数 区别来自于浏览器对 URL 长度的限制， 请求体大小来源于服务器的限制 还有语义的区别： GET 是获取， POST 是提交 Get 是用来从服务器上获得数据，而 post 是用来向服务器上传递数据 Get&#x2F;Post 使用场景 若符合下列任一情况，则 Post 方法： 1、请求的结果有持续性的作用，例如：数据库内添加新的数据行 2、若使用 Get 方法，则表单上收集的数据可能让 URL 过长 3、要传送的数据不是采用 ASCII 编码 若符合下列任一情况，则用 Get 方法： 1、请求是为了查找资源，html 表单数据仅用来搜索 2、请求结果无持续性的副作用 3、收集的数据及 html 表单内的输入字段名称的总长不超过 1024 个字符 32、HTTP 与 HTTPS 的区别1、HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。 2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。 3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443 4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。) 33、localStorage、sessionStorage、cookie 的区别共同点：都是保存在浏览器端、且同源的 区别： 1、cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递，而 sessionStorage 和 localStorage 不会自动把数据发送给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下 2、存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带 cookie、所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大 3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的 cookie 过期时间之前有效，即使窗口关闭或浏览器关闭 4、作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。 34、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？1、浏览器查找域名对应的 IP 地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根域名服务器) 2、浏览器向 Web 服务器发送一个 HTTP 请求（TCP 三次握手） 3 服务器 301 重定向（从 HTTP:&#x2F;&#x2F;example.com 重定向到 HTTP:&#x2F;&#x2F;www.example.com） 4、浏览器跟踪重定向地址，请求另一个带 www 的网址 5、服务器处理请求（通过路由读取资源） 6、服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 ‘text&#x2F;html’） 7、浏览器进 DOM 树构建 8、浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS 等） 9、浏览器显示完成页面 10、浏览器发送异步请求 35、HTTP 常见请求方式有哪些？1、GET 请求指定的页面信息，并返回实体主体。 2、HEAD 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 3、POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。 4、PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5、DELETE 请求服务器删除指定的页面。 6、CONNECT HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7、OPTIONS 允许客户端查看服务器的性能。 8、TRACE 回显服务器收到的请求，主要用于测试或诊断。 9、PATCH 实体中包含一个表，表中说明与该 URI 所表示的原内容的区别。 10、MOVE 请求服务器将指定的页面移至另一个网络地址。 11、COPY 请求服务器将指定的页面拷贝至另一个网络地址。 12、LINK 请求服务器建立链接关系。 13、UNLINK 断开链接关系。 14、WRAPPED 允许客户端发送经过封装的请求。 15、LOCK 允许用户锁定资源，比如可以再编辑某个资源时将其锁定，以防别人同时对其进行编辑。 16、MKCOL 允许用户创建资源 17、Extension-mothed 在不改动协议的前提下，可增加另外的方法。 36、什么是 TCP 连接的三次握手TCP 是因特网中的传输层协议，使用建立连接，完成三次握手，与服务器开始传送。 第一次握手：建立连接时，发送包（syn&#x3D;j）到服务器，并进入等待状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器 第二次握手：收到 SYN 包，必须确认客户的 SYN（syn&#x3D;j+1），同时自己也发送一个SYN 包（syn&#x3D;k），即 SYN+ACK 包，此时服务器进入等待状态； 第三次握手：客户端收到服务器器的 SYN+ACK 包，向服务器发送确认包 ACK(ack&#x3D;k+1），此包发送完毕，客户端和服务器进入（TCP 连接成功）状态，完成三次握手。 37、为什么 TCP 连接需要三次握手四次挥手为什么是三次握手 为了防止已失效的连接请求报文段突然有送到了服务器，因而产生错误,假设两次握手时， 客户发出的第一个请求连接报文段在某一网络节点长时间滞留，以致延误到连接释放后才到达服务器。服务器收到失效的连接请求报文段后，认为是客户又发出一次新的连接请求。于是向客户发送确认报文段，同意建立连接，此时在假定两次握手的前提下，连接建立成功。这样会导致服务器的资源白白浪费。 为什么是四次挥手 TCP 协议是全双工通信，这意味着客户端和服务器端都可以向彼此发送数据，所以关闭连接 是双方都需要确认的共同行为，假设是三次挥手时，首先释放了客户到服务器方向的连接，此时 TCP 连接处于半关闭状态，这时客户不能向服务器发送数据，而服务器还是可以向客户发送数据。如果此时客户收到了服务器的确认报文段后，就立即发送一个确认报文段，这会导致服务器向客户还在发送数据时连接就被关闭。这样会导致客户没有完整收到服务器所发的报文段。 38、ES5 和 ES6 的区别，说几个 ES6 的新增方法ES5 和 ES6 的区别 ECMAScript5，即 ES5，是 ECMAScript 的第五次修订，于 2009 年完成标准化 ECMAScript6，即 ES6，是 ECMAScript 的第六次修订，于 2015 年完成，也称 ES2015 ES6 是继 ES5 之后的一次改进，相对于 ES5 更加简洁，提高了开发效率 ES6 的新增方法 1、新增声明命令 let 和 const 在 ES6 中通常用 let 和 const 来声明，let 表示变量、const 表示常量 1.1）特点 let 和 const 都是块级作用域。以{}代码块作为作用域范围 只能在代码块里面使用不存在变量提升，只能先声明再使用，否则会报错。语法上，称为“暂时性死区” 在同一个代码块内，不允许重复声明 const 声明的是一个只读常量，在声明时就需要赋值。（如果 const 的是一个对象，对象所包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址不能改变，而变量成员是可以修改的。） 2、模板字符串（Template String） 用一对反引号(&#96;)标识，它可以当作普通字符串使用，也可以用来定义多行字符串，也可以在字符串中嵌入变量，js 表达式或函数，变量、js 表达式或函数需要写在${ }中。 3、函数的扩展 3.1）函数的默认参数 ES6 为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。 3.2）箭头函数 在 ES6 中，提供了一种简洁的函数写法，我们称作“箭头函数”。 39、var、let、const 之间的区别区别 var 声明变量可以重复声明，而 let 不可以重复声明 var 是不受限于块级的，而 let 是受限于块级 var 会与 window 相映射（会挂一个属性），而 let 不与 window 相映射 var 可以在声明的上面访问变量，而 let 有暂存死区，在声明的上面访问变量会报错 const 声明之后必须赋值，否则会报错 const 定义不可变的量，改变了就会报错 const 和 let 一样不会与 window 相映射、支持块级作用域、在声明的上面访问变量会报错 40、介绍下 Set、Map 的区别区别 应用场景 Set 用于数据重组，Map 用于数据储存 Set： 成员不能重复 只有键值没有键名，类似数组 可以遍历，方法有 add, delete,has Map: 本质上是健值对的集合，类似集合 可以遍历，可以跟各种数据格式转换 41、setTimeout、Promise、Async&#x2F;Await 的区别事件循环中分为宏任务队列和微任务队列 宏任务（macrotask）：在新标准中叫 task 主要包括：script(整体代码)，setTimeout，setInterval，setImmediate，I&#x2F;O，ui rendering 微任务（microtask）：在新标准中叫 jobs 主要包括：process.nextTick， Promise，MutationObserver（html5 新特性） setTimeout、Promise、Async&#x2F;Await 的区别 setTimeout 的回调函数放到宏任务队列里，等到执行栈清空以后执行 Promise.then 里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行 async 函数表示函数里面可能会有异步方法，await 后面跟一个表达式 async 方法执行时，遇到 await 会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。 42、Promise 有几种状态，什么时候会进入 catch？Promise 有几种状态 三个状态：pending、fulfilled、reject 两个过程：padding -&gt; fulfilled、padding -&gt; rejected Promise 什么时候会进入 catch 当 pending 为 rejected 时，会进入 catch 43、git 的基本使用方法第一步：window 本机电脑安装 git 软件（只需要一次） 第二步：配置环境变量（只需要一次） 安装到 D:\\software\\git\\目录，把 bin 目录路径完整加入 Path 变量。 D:\\software\\git\\bin 第三步：配置 git 的 config（只需要一次） git config –global user.email “&#121;&#111;&#117;&#64;&#x65;&#120;&#x61;&#109;&#112;&#108;&#101;&#46;&#99;&#x6f;&#109;“ git config –global user.name “Your Name” 查看你的配置是 git config –list 第四步：使用 git 开始工作 （每次） 1 、在本地建立一个文件夹，作为本地代码仓库，并初始化 cmd 中 cd 到该文件夹，执行 git init 命令，让该文件夹成为受 git 管理的仓库目录。 2、把某个文件添加到本地仓库（前提项目文件夹有这个文件） 执行 git add HelloWorld.html 命令 如果暂存所有（git add .） 3、提交文件到仓库 git commit -m “第一次使用 git 提交文件”m 后面的“” 44、git 工作流程git 的作用 1、在工作目录中修改某些文件 2、对修改后的文件进行快照，然后保存到暂存区域 3、提交更新，将保存在暂存区域的文件快照永久转储到 git 目录中 git 的工作中使用场景： 两个分支 master 和 dev 项目开始执行流程 git branch -a (查看所有分支) 0、克隆代码 git clone 地址 1、拉取线上 master 最新代码: git pull origin master 2、切换到开发分支: git checkout dev 3、合并 master 本地分支（master）: git merge master 4、开始开发 5、开发结束 6、查看当前文件更改状态: git status 7、把所有更改代码放到缓存区: git add -A 8、查看当前文件更改状态 : git status 9、缓存区内容添加到仓库中: git commit -m ‘本次更改注释’ 10、把代码传到 gitLab 上: git push origin dev 11、若代码到达上线标准则合并代码到 master,切换分支到 master: git checkout master 12、拉取 master 最新分支: git pull origin master 13、合并分支代码到 master(若有冲突则解决冲突): git merge dev 14、把当前代码上传到 gitLab: git push origin master 15、代码上线后，用 tag 标签标记发布结点(命名规则：prod_+版本_+上线日期) git tag -a prod_V2.1.8_20220201 16、tag 标签推到 gitLab git push origin prod_V2.1.8_20220201 缓存区的应用 1、需要合并别人代码进来 1.1）把自己的代码放入暂存: git stash 1.2）如果需要释放出来用: git stash pop#恢复最近一次的暂存 1.3）查看你有哪些队列: git stash list 1.4）删除第一个队列，以此可以类推: git stash drop stash@{0} 2、需要切换分支 2.1）git add -A 2.2）git stash save ‘demo’ 2.3）git stash list 2.4）git stash apply stash@{0} 45、提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的冲突是如何产生 开发过程中，我们都有自己的特性分支，所以冲突发生的并不多，但也碰到过。诸如公共类的公共方法，我和别人同时修改同一个文件，他提交后我再提交就会报冲突的错误。 如何解决冲突 1、发生冲突，在 IDE 里面一般都是对比本地文件和远程分支的文件，然后把远程分支上文件的内容手工修改到本地文件，然后再提交冲突的文件使其保证与远程分支的文件一致，这样才会消除冲突，然后再提交自己修改的部分。特别要注意下，修改本地冲突文件使其与远程仓库的文件保持一致后，需要提交后才能消除冲突，否则无法继续提交。必要时可与同事交流，消除冲突。 2、发生冲突，也可以使用命令 通过 git stash 命令，把工作区的修改提交到栈区，目的是保存工作区的修改； 通过 git pull 命令，拉取远程分支上的代码并合并到本地分支，目的是消除冲突； 通过 git stash pop 命令，把保存在栈区的修改部分合并到最新的工作空间中； 分支提交冲突：当分支对某文件某句话进行修改后，切换到主分支也对该文件该句话进行修改，使用 git merge 进行合并，需要将两个修改进行合并。此时合并产生冲突 。 3、另外一种解决方法 3.1）git status 查看冲突文件 3.2）编辑器打开冲突文件，查看内容。Git 用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标 记出不同分支的内容 3.3）修改文件内容 3.4）提交 git add file ; git commit -m “” 查看分支合并图 git log –graph 46、什么是 WebpackWebpack 是一个打包模块化 javascript 的工具，在 Webpack 里一切文件皆模块，通过loader 转换文件，通过 plugin 注入钩子，最后输出由多个模块组合成的文件，Webpack 专注构建模块化项目，Webpack 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript 等），并将其打包为合适的格式以供浏览器使用。 47、有哪些常见的 Loader？他们是解决什么问题的？1、file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 2、url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内 容注入到代码中去 3、source-map-loader：加载额外的 Source Map 文件，以方便断点调试 4、image-loader：加载并且压缩图片文件 5、babel-loader：把 ES6 转换成 ES5 6、css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 7、style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS 8、eslint-loader：通过 ESLint 检查 JavaScript 代码 48、Vue 的最大的优势是什么Vue 作为一款轻量级框架、简单易学、 数据绑定、组件化、数据和结构的分离、虚拟 DOM、运行速度快，并且作者是中国人尤雨溪，对应的 API 文档对国内开发者优化，作为前端开发人员的首选入门框架，Vue 有很多优势： Vue.js 可以进行组件化开发，使代码编写量大大减少，读者更加易于理解。 Vue.js 最突出的优势在于可以对数据进行双向绑定。 相比传统的页面通过超链接实现页面的切换和跳转，Vue 使用路由不会刷新页面。 Vue 是单页面应用，使页面局部刷新，不用每次跳转页面都要请求所有数据和 dom， 这样大大加快了访问速度和提升用户体验。 而且他的第三方 UI 组件库使用起来节省很多开发时间，从而提升开发效率。 49、mvvm 和 mvc 区别是什么？1）MVVM 基本定义 MVVM 即 Model-View-ViewModel 的简写。即模型-视图-视图模型。模型（Model）指的是后端传递的数据。视图(View)指的是所看到的页面。视图模型(ViewModel)是 mvvm 模式的核心，它是连接 view 和 model 的桥梁。它有两个方向： 一是将模型（Model）转化成视图(View)，即将后端传递的数据转化成所看到的页 面。实现的方式是：数据绑定。 二是将视图(View)转化成模型(Model)，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。 2） MVC 基本定义 MVC 是 Model-View- Controller 的简写。即模型-视图-控制器。M 和 V指的意思和 MVVM 中的 M 和 V 意思一样。C 即 Controller 指的是页面业务逻辑。 使用 MVC 的目的就是将 M 和 V 的代码分离。MVC 是单向通信。也就是 View 跟Model，必须通过 Controller 来承上启下。MVC 和 MVVM 的区别并不是 VM 完全取代了 C，只是在 MVC 的基础上增加了一层 VM，只不过是弱化了 C 的概念，ViewModel 存在目的在于抽离 Controller 中展示的业务逻辑，而不是替代 Controller，其它视图操作业务等还是应该放在 Controller 中实现。也就是说 MVVM 实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。 50、Vue 数据双向绑定的原理是什么Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化 第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个 update()方法 3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile中绑定的回调，则功成身退。 第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。 51、Object.defineProperty 和 Proxy 的区别1）Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化； Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等 等是 Object.defineProperty 不具备的； Proxy 返 回 的 是 一 个 新 对 象 , 我 们 可 以 只 操 作 新 的 对 象 达 到 目 的 , 而 Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，新标准的性能红利； 2）Object.defineProperty 的优势如下: 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill磨平。 52、请说下封装 Vue 组件的过程首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。 1）分析需求：确定业务需求，把页面中可以服用的结构，样式以及功能，单独抽离成一个文件，实现复用。 2）具体步骤： 使用 Vue.component 方法注册组件，子组件需要数据，可以在 props 中接受定义，而子组件修改好数据后，想把数据传递给父组件。可以采用$emit 方法向外抛数据 。 如果需要给组件传入模板，则定义为插槽 slot 如果需要 父组件主动调用子组件的方法 可以在 methods 选项中开放方法 53、组件中写 name 选项有什么作用？1、 项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤 2、 DOM 做递归组件时需要调用自身 name 3、Vue-devtools 调试工具里显示的组见名称是由 Vue 中组件 name 决定的 54、watch、methods 和 computed 的区别?1）基本说明 1．computed： 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。 2．methods： methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。 3．watch： 观察和响应 Vue 实例上的数据变动，一个对象，键是需要观察的表达式， 值是对应回调函数。值也可以是方法名，或者包含选项的对象，Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 2）三者的加载顺序 computed 是在 HTML DOM 加载后马上执行的，如赋值；（属性将被混入 到 Vue 实例） methods 则必须要有一定的触发条件才能执行，如点击事件 watch 呢？它用于观察 Vue 实例上的数据变动。 3）默认加载的时候 先 computed 再 watch，不执行 methods； 4）触发某一事件后 先 computed 再 methods 再到 watch computed 属性 vs method 方法 computed 计算属性是基于它们的依赖进行缓存的。 55、Vue 中 key 值的作用是什么？​\t当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用” 策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的 顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key 的作用主要是为了高效的更新虚拟 DOM。 56、Vuex 的 5 个核心属性是什么?分别是 State、 Getter、Mutation 、Action、 Module 1）state state 为单一状态树，在 state 中需要定义我们所需要管理的数组、对象、字符串等等，只有在这里定义了，在 Vue.js 的组件中才能获取你定义的这个对象的状态。 2）getter getter 有点类似 Vue.js 的计算属性，当我们需要从 store 的 state 中派生出一些状态，那么我们就需要使用 getter，getter 会接收 state 作为第一个参数，而且 getter的返回值会根据它的依赖被缓存起来，只有 getter 中的依赖值（state 中的某个需要派生状态的值）发生改变的时候才会被重新计算。 3）mutation 更改 store 中 state 状态的唯一方法就是提交 mutation，就很类似事件。每个mutation 都有一个字符串类型的事件类型和一个回调函数，我们需要改变 state的值就要在回调函数中改变。我们要执行这个回调函数，那么我们需要执行一个相应的调用方法：store.commit。 4）action action 可以提交 mutation，在 action 中可以执行 store.commit，而且 action 中可以有任何的异步操作。在页面中如果我们要嗲用这个 action，则需要执行store.dispatch 5）module module其实只是解决了当state中很复杂臃肿的时候，module可以将store分割成模块，每个模块中拥有自己的 state、mutation、action 和 getter。 57、简述 Vuex 的数据传递流程当组件进行数据修改的时候我们需要调用 dispatch 来触发 actions 里面的方法。 actions 里面的每个方法中都会 有一个 commit 方法，当方法执行的时候会通过commit 来触发 mutations 里面的方法进行数据的修改。mutations 里面的每个函数都会有一个 state 参数，这样就可以在 mutations 里面进行 state 的数据修改 ，当数据修改完毕后，会传导给页面。页面的数据也会发生改变。 58、Vue-Router 是干什么的，原理是什么？Vue-Router 是 Vue.js 官方的路由插件，它和 Vue.js 是深度集成的，适合用于构建单页面应用。Vue 的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在 Vue-Router 单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起 url 和页面之间的映射关系。 “更新视图但不重新请求页面”是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式： 利用 URL 中的 hash（“#”） 利用 History interface 在 HTML5 中新增的方法 59、Vue-Router 有哪几种路由守卫?全局守卫：beforeEach 后置守卫：afterEach 全局解析守卫：beforeResolve 路由独享守卫：beforeEnter 60、query 和 params 之间的区别是什么？1、query 要用 path 来引入，params 要用 name 来引入 。 2、接收参数时，分别是 this.$route.query.name 和 this.$route.params.name。 61、**$route 和$router 的区别是什么？**$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。 $router 为 VueRouter 的实例，相当于一个全局的路由器对象，里面含有很多属性和子对象，例如 history 对象，经常用的跳转链接就可以用 this.router.push 会往 history 栈中添加一个新的记录。返回上一个 history 也是使用$router.go 方法。 62、Vue 的路由实现模式：hash 模式和 history 模式1）hash 模式：在浏览器中符号“#”，#以及#后面的字符称之为 hash，用 window.location.hash 读取。特点：hash 虽然在 URL 中，但不被包括在 HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash 不会重加载页面。 2） history 模式：history 采用 HTML5 的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及 popState事件的监听到状态变更。 63、Vue2.0 兼容 IE 哪个版本以上吗？不支持 ie8 及以下，部分兼容 ie9 ，完全兼容 10 以上， 因为 Vue 的响应式原理是基于 es5 的 Object.defineProperty(),而这个方法不支持 ie8 及以下。 64、如何对 Vue 首屏加载实现优化?1、把不常改变的库放到 index.html 中，通过 cdn 引入 2、Vue 路由的懒加载 3、不生成 map 文件 4、Vue 组件尽量不要全局引入 5、使用更轻量级的工具库 6、开启 gzip 压缩 7、首页单独做服务端渲染","tags":["面试题"],"categories":["面试题"]},{"title":"ReduxToolkit全局状态管理","path":"/React/ReduxToolkit全局状态管理/","content":"ReduxToolkitReduxToolkit 是官方推出的基于 Redux 进行高度封装的工具包，不需下载就可下载，在开发过程中可以用更少的代码完成工作。 使用12345# 新项目# Redux + Plain JS templatenpx create-react-app my-app --template redux# Redux + TypeScript templatenpx create-react-app my-app --template redux-typescript 12# 现有项目 (@reduxjs/toolkit 和 react-redux 都自带ts类型声明文件, 不需要单独下载)npm install @reduxjs/toolkit@1.9.5 react-redux@8.0.5 一、方法1.createActioncreateAction 用于创建 action creator 函数，接收 action 对象的 type 属性作为参数 1export const creator = createAction(&quot;type&quot;); 2.createReducercreateReducer 用于创建 reducer 函数，使 reducer 函数中的代码细化和拆分。 addCase 调度操作的 action.type 与提供字段完全匹配运行 reducer。 addMatcher 里提供的函数返回 true 时运行 reducer。 123456export const Reducer = createReducer(state, (builder) =&gt; &#123; builder .addCase(creator, () =&gt; (&#123;&#125;)) .addMatcher((action) =&gt; action.type === &quot;action.type&quot;), (state, action) =&gt; (&#123;&#125;);&#125;); 3.configureStoreconfigureStore 创建和配置 Redux 的 store 对象。 1234567export const store = configureStore(&#123; reducer: &#123; counterReducer, &#125;, //是否开启redux工具 devTools: process.env.NODE_ENV !== &quot;production&quot;,&#125;); 4.useSelectoruseSelector 用于在函数式组件中获取 store 对象中的状态的方法,接收函数为参数，参数函数的参数表示状态对象，参数函数返回要获取的具体状态。 1const useSelector((state)=&gt;state.counterReducer.count); 5.useDispatchuseDispatch 是用于在函数式组件中获取 dispatch 的方法 12const dispatch = useDispatch();dispatch(获取dispatch); 6.createAsyncThunkcreateAsyncThunk 用于创建执行异步操作的 action creator 函数。第一个参数是 action 对象的 type 属性，第二个参数是指向异步操作的函数。 1234567export const Creators = createAsyncThunk(&quot;type属性&quot;, async () =&gt; &#123; const res = await axios.get(&quot;http://123&quot;); return res;&#125;);//Creators.pending-&gt;加载//Creators.fulfilled-&gt;请求成功//Creators.rejected-&gt;请求失败 调用 1234567891011121314151617181920const initialState = &#123; status: &quot;idle&quot;, data: [], error: null &#125;;export const Reducer = createReducer(initialState, (builder) =&gt; &#123; builder .addCase(loadTodos.pending, () =&gt; (&#123; status: &quot;loading&quot;, data: [], error: null, &#125;)) .addCase(loadTodos.fulfilled, (state, action) =&gt; (&#123; status: &quot;success&quot;, data: action.payload, error: null, &#125;)) .addCase(loadTodos.rejected, (state, action) =&gt; (&#123; status: &quot;error&quot;, data: [], error: action.error, &#125;));&#125;); 7.createSlice 状态切片action creator 函数、reducer 函数全部都由状态切片生成，状态切片可以使在开发时更专注于状态的管理。 1234567891011121314151617181920212223242526272829import &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;;// createSlice 方法的返回值是一个对象// actions: 该对象中存储的是操作状态 action creator 函数, reducers 配置对象中的函数名称将会作为 action creator 函数的名称// reducer: 原本开发者自己定义的 reducer 函数const &#123; actions, reducer: counterReducer &#125; = createSlice(&#123; // 状态名称, 该名称将会被用于 action 对象的 type 属性值的第一部分 name: &quot;counter&quot;, // 初始状态 initialState: &#123; count: 0 &#125;, // 方法接收两个参数, state 对象和 action 对象 // 在方法中可以直接对状态对象进行操作, 不需要返回新的状态对象 // 调用 action creator 函数时传递的参数将会被放置在 action.payload 属性中 reducers: &#123; increment: (state) =&gt; &#123; state.count += 1; &#125;, decrement: (state) =&gt; &#123; state.count -= 1; &#125;, incrementByCount: (state, action) =&gt; &#123; state.count = state.count + action.payload; &#125;, &#125;,&#125;);// 导出 action creator 函数供组件使用export const &#123; increment, decrement, incrementByCount &#125; = actions;// 导出 counterReducer 函数export default counterReducer; 7.1createSlice_prepareprepare 方法允许开发者在 action 指令发出后 reducer 函数接收前先对 action 对象中的 payload 属性值进行处理。 123456789101112incrementByCount: &#123; prepare: (payload) =&gt; &#123; // prepare 方法接收 payload 作为参数 // 要求返回对象, 该对象会和 action 对象进行合并 return &#123; payload: payload + 10, &#125;; &#125;, reducer: (state, action) =&gt; &#123; state.count = state.count + action.payload; &#125;, &#125;, 8.configureStore_middleware 配置中间件middleware 选项的值是一个函数，该函数有一个参数，该参数习惯被命名为 getDefaultMiddeware，它就是用来获取内置中间件函数的。etDefaultMiddeware 方法的返回值是一个数组，数组中包含内置的中间件函数，开发者只需要在该数组中添加中间件函数即可。middleware 选项要求在该函数中返回最新的中间件函数数组。 12345678//npm i redux-logger@3.0.6import logger from &quot;redux-logger&quot;;export const store = configureStore(&#123; middleware: (getDefaultMiddleware) =&gt; &#123; return getDefaultMiddleware().concat(logger); &#125;,&#125;);","tags":["React"],"categories":["React使用"]},{"title":"React性能优化","path":"/React/react性能优化/","content":"React 组件性能优化1. memoReact.memo 可以对组件输入数据进行浅层比较(简单数据类型比较值，引用数据类型比较内存的引用地址)，如果输入数据没有变化则阻止组件更新。 2. useMemoReact.useMemo 用于在函数式组件中缓存值，避免重复操作执行影响组件运行性能。 3. useCallbackReact.useCallback 用于在函数式组件中缓存方法，避免组件每次重新渲染时都返回一个新方法。 4. useDeferredValueReact.useDeferredValue 用于获取一个延时更新的值，让 React 在空闲时去更新值；在频繁更新视图的场景下可以避免出现视图卡顿现象。 5. useTransitionReact.useTransition 用于允许开发者点赞状态渲染的优先级；可以将资源密集型任务优先级降低，等待 React 空闲时执行，避免页面出现卡顿现象。","tags":["React"],"categories":["React使用"]},{"title":"React 函数组件","path":"/React/react函数组件/","content":"一、函数组件函数组件是一个返回视图(JSX)的函数。 1.创建函数组件123function App() &#123; return &lt;div&gt;APP&lt;/div&gt;;&#125; 2.函数组件使用方法01.useState 声明组件状态​ 在 React 函数组件中可以通过 useState 方法创建组件状态，可以被调用多次声明多个状态。 123456789101112131415161718//useState方法返回值是一个数组，第一个参数是状态变量，第二个参数是修改/更新状态的方法。function App() &#123; const [value, setValue] = useState(&quot;状态初始值&quot;); const [count, seCount] = useState(0); retutn( &lt;&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;p&gt;&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setValue(&quot;修改的值&quot;)&#125;&gt;更改状态&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setVlaue(count + 1)&#125;&gt;更改数值+1&lt;/button&gt; //更新状态方法可以接收函数作为参数，通过参数函数返回值指定新状态值 //prevState表示更新前状态 //参数函数返回值表示更新后状态 &lt;button onClick=&#123;() =&gt; setCount((prevState) =&gt; prevState - 1)&#125;&gt; 更新数值-1 &lt;/button&gt; &lt;/&gt; );&#125; ​ 当多次调用修改状态的方法时，当传递状态值，最后面的状态会覆盖前面状态；当传递函数，顺序执行，所有函数执行完毕才会更新。 123456789101112131415161718192021222324//传递状态值，最后结果为count+2&lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setCount(count + 1); setCount(count + 1); setCount(count + 2); &#125; &#125; &gt; &#123;count&#125; &lt;/button&gt;//传递函数方法，顺序执行+1+1+1+1返回最终相加结果&lt;button onClick=&#123;() =&gt; &#123; setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); &#125; &#125; &gt; &#123;count&#125; &lt;/button&gt; 02.useEffect 确保函数式组件正确执行副作用代码​ 在 React 中，副作用指与组件渲染无关的操作，如获取数据、修改全局变量、更新 DOM 等。这些操作可能会影响组件渲染结果，但不能被纯函数捕获，因此需 useEffect 进行特殊处理，确保代码在正确时机执行。 ​ useEffect 接收一个回调函数和一个依赖数组作为参数，回调函数的代码会在组件渲染完成后执行，依赖数组的变量会在其发生变化时触发回调函数重新执行。 1234const [参数变量, 修改方法代码] = useState(&quot;&quot;);useEffect(() =&gt; &#123; //回调函数代码&#125;, [&quot;参数变量&quot;]); 03.useRef 获取 DOM 对象​ 通过 useRef 方法可以在函数式组件中获取 DOM 对象 1234function App()&#123; const name = useRef(); return &lt;input ref=&#123;name&#125; onChange=&#123;()=&gt;consloe.lgo(name.current)&#125;/&gt;&#125; 04.forwardRef 获取子组件 DOM 对象​ 通过 useRef 和 forward 高阶函数配合使用可以实现父子组件之间传递 ref 对象。 12345678910//appfunction App() &#123; const appref = useRef(); return &lt;Message ref=&#123;appref&#125; /&gt;;&#125;//messagefunction Message(props, ref) &#123; return &lt;span ref=&#123;ref&#125;&gt;message&lt;/span&gt;;&#125;export default forwardRef(Message); 05.受控组件和非受控组件受控表单组件 ​ 表单状态由 React 组件状态控制 12345678910111213141516171819202122232425function App() &#123; const [formState, setFormState] = useState(&#123; username: &quot;&quot;, password: &quot;&quot; &#125;); const onChangeHandler = (event) =&gt; &#123; setFormState(&#123; ...formState, [event.target.name]: event.target.value, &#125;); &#125;; return ( &lt;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&#123;formState.username&#125; onChange=&#123;onChangeHandler&#125; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&#123;formState.password&#125; onChange=&#123;onChangeHandler&#125; /&gt; &lt;/&gt; );&#125; 非受控表单组件 ​ 通过 DOM 获取&#x2F;修改值，使用 useRef 实现非受控表单组件 12345678910111213function App() &#123; const usernameRef = useRef(); const onSubmijs = (event) =&gt; &#123; event.preventDefault(); console.log(usernameRef.current.value); &#125;; return ( &lt;form onSubmit=&#123;onSubmijs&#125;&gt; &lt;input type=&quot;text&quot; ref=&#123;usernameRef&#125; /&gt; &lt;button&gt;button&lt;/button&gt; &lt;/form&gt; );&#125; 06.父子组件通信 - Props1.父组件传递状态到子组件，子组件修改父组件传递的状态值。 1234567891011//父组件function App() &#123; const [msg, setMsg] = useState(&quot;hello&quot;); //传递给子组件 return &lt;Message msg=&#123;mgs&#125; setMsg=&#123;setMsg&#125;&gt;&lt;/Message&gt;;&#125;//子组件function Message(props) &#123; //接收父组件传递的数据 return &lt;button onClick=&#123;() =&gt; props.setMsg(&quot;你好&quot;)&#125;&gt;&#123;props.msg&#125;&lt;/button&gt;;&#125; 2.设置 Props 对象默认值方式 123456789101112131415161718192021222324252627function App(props) &#123; return ( &lt;div&gt; &lt;Message name=&#123;&quot;张三&quot;&#125; age=&#123;30&#125; /&gt; &lt;/div&gt; );&#125;function Message(&#123; name = &quot;李四&quot;, age = 20 &#125;) &#123; return ( &lt;div&gt; &#123;name&#125; &#123;age&#125; &lt;/div&gt; );&#125;export default App;-------------------------function App()&#123; return &lt;Message/&gt;;&#125;function Message(&#123;name,age&#125;)&#123; return &lt;div&gt;&#123;name&#125;&#123;age&#125;&lt;/div&gt;&#125;Message.defaultProps=&#123; name:&quot;张三&quot;, age:20&#125; 07.父子组件通信-useImperativeHandle​ useImperativeHandle 允许父组件直接调用子组件暴露的成员属性和方法。 12345678910111213141516//App.jsfunction App() &#123; const msgRef = useRef(); return ( &lt;&gt; &lt;Message ref=&#123;msgRef&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; console.log(msgRef.current.value); &#125;&#125; &gt; getMsg &lt;/button&gt; &lt;/&gt; );&#125; 12345678910111213//Messagefunction Message(props, ref) &#123; const [value, setValue] = useState(&quot;&quot;); //useImperativeHandle用于设置ref对象中current属性的值，(参数传递ref对象，传递函数(函数返回什么ref对象的current属性值就是什么，组件每次重新渲染时执行)，数组(传递依赖状态)) useImperativeHandle(ref, () =&gt; (&#123; vlaue &#125;), [value]); return ( &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;(event) =&gt; setValue(event.target.value)&#125; /&gt; );&#125; 08.跨级组件通讯-useContext在组件中创建导出的对象，另一个组件中通过 useContext 方法就那些获取。 12345//创建上下文对象export const PersonContext = createContext(&#123; name: &quot;张三&quot;, age: 20 &#125;);//获取上下文状态const person = useContext(PersonContext); 09.组件状态逻辑分离-useReduceruseReducer 是 React 提供的另一种在函数式组件中声明状态的方式。将组件状态逻辑和组件渲染逻辑进行分离，使代码更加清晰可维护。useReducer 是 useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。 1234567891011121314151617function App()&#123; const [state,dispatch] = useReducer(counterReducer,&#123;count:0&#125;); return &lt;button onClick=&#123;()=&gt;dispatch(&#123;type:&quot;counter/increent&quot;&#125;)&#125;&gt;&#123;state.count&#125;&lt;/button&gt;&#125;-----------------------// src/counterReducer.jsexport default function counterReducer(state, action) &#123; switch (action.type) &#123; case &quot;counter/increment&quot;: return &#123; ...state, count: state.count + 1, &#125;; default: return state; &#125;&#125; 10.保存组件值-useRefuseRef 可以获取 DOM 元素，保存普通值；使用 useRef 保存的普通值并不会随组件更新而销毁，修改通过 useRef 保存的值也不会触发组件更新。 例：组件初次渲染开启定时器，点击按钮进行清空。 1234567891011121314151617181920212223function App(props) &#123; // 根据useRef设置定时器; const [count, setCount] = useState(0); // 保存定时器id const intervalRef = useRef(); useEffect(() =&gt; &#123; //开启定时器 intervalRef.current = window.setInterval(() =&gt; &#123; setCount((prevState) =&gt; prevState + 1); &#125;, 1000); return () =&gt; clearInterval(intervalRef.current); &#125;, []); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; clearInterval(intervalRef.current)&#125;&gt; 清除定时器 &lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount((prevState) =&gt; prevState + 1)&#125;&gt; &#123;count&#125;数值加1 &lt;/button&gt; &lt;/div&gt; );&#125;","tags":["React"],"categories":["React使用"]},{"title":"React + TypeScript - 类组件","path":"/React/react-ts-类组件/","content":"React + TypeScript - 类组件1.应用创建使用官方提供脚手架，创建指令后添加–template typescript 即可 1npm create-react-app 文件名 --template typescript 创建应用后项目中包含 jsx 代码文件后缀为.tsx，不包含 jsx 代码的文件为.ts 2.Component 泛型类标注 Props 和 States 对象的类型 123456789101112131415161718192021222324interface Props &#123; name: string;&#125;interface States &#123; count: number;&#125;//使用泛型类export default class App extends React.Components&lt;Props, States&gt; &#123; constructor(props: Readonly&lt;Props&gt;) &#123; super(props); this.state = &#123; count: 0, &#125;; &#125; render() &#123; return ( &lt;&gt; &lt;div&gt;&#123;name&#125;&lt;/div&gt; &lt;/&gt; ); &#125;&#125;//index.tsx&lt;APP name=&#123;&quot;张三&quot;&#125; /&gt;; 3.标注 React 元素类型01.React 元素含义：通过 React.createElement 方法创建的元素、通过 JSX 语法创建的元素。（虚拟 DOM 对象） 12const title = React.createElement(&quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;);const title2 = &lt;h1 className=&quot;one&quot;&gt;Hello&lt;/h1&gt;; 02.标注 React 元素类型 使用 ReactElement 和 JSX.Element 都可以标注元素的类型 1234567891011import &#123; ReactElement &#125; from &quot;react&quot;;const title: ReactElement = React.createElement( &quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;);const titl2: JSXElement = React.createElement( &quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;); 4.ReactPortal(了解)ReactPortal 表示 ReactDOM.createPortal 方法的返回值类型 123render():ReactPortal&#123; return createPortal(&lt;div&gt;&lt;/div&gt;)&#125; 5.ReactNodeReactNode 表示可渲染的任意值，包括布尔值，数字，字符串，数组等，是 React 中最泛化的类型 123456789type ReactNode = | ReactElement | string | number | ReactFragment | ReactPortal | boolean | null | undefined; 6.ReactFragmentReactFragment 表示一组可以被遍历渲染的任意值，只用于标注组件 children 属性的类型。 123456789//type ReactFragment = Interble&lt;ReactNode&gt;interface Props &#123; children: ReactFragment;&#125;&lt;App&gt; &#123;/* 不能只有一个, 只能多个 */&#125; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/App&gt;; 7.CSSPropertiesCSSProperties 用于标注 styles 属性值的类型，对样式值对象的属性及属性值的类型进行约束。 1234interface Props &#123; style?: React.CSSProperties;&#125;&lt;div style=&#123;this.props.style&#125;&gt;&lt;/div&gt;; 8.标注事件对象的类型MouseEvent 用于标注鼠标事件对应的事件对象的类型。onClickHandler KeyboardEvent 用于标注键盘事件对应的事件对象的类型。onKeyUpHandler FormEvent 用于标注表单提交事件对应的事件对象的类型。onSubmitHandler UIEvent 通用的和用户界面相关的事件的事件对象类型，一般我们使用 UIEvent 标注滚动事件的事件对象类型、加载事件的事件对象类型等。onScrollHandler 123function on事件名(event:React.标注事件类型&lt;HTML事件Element&gt;)&#123;&#125;//等价写法const on事件名:React.标注事件类型Handler&lt;HTML事件Element&gt;=(event)=》&#123;&#125; 9.DefaultPropsdefaultProps 中添加属性之后，该属性变为可选，在调用当前组件时不传递该属性也可以通过 ts 的编译 123456789101112131415interface Props&#123; name:string; age:number;&#125;export default class App extends React.Component&lt;Props&gt;&#123; static defaultProps:Pick&lt;Props&gt; = &#123; name:&quot;默认&quot; &#125;; render() &#123; return &lt;div&gt;APP&lt;/div&gt;; &#125;&#125;//index.tsx&lt;App /&gt;&lt;App greetings=&#123;&quot;Hello world&quot;&#125; age=&#123;20&#125; /&gt;","tags":["React"],"categories":["React使用"]},{"title":"React 基本使用","path":"/React/react基本使用/","content":"react 使用一、react 基础01.react 基本使用1.react 概念 react 概念 React 是一个开源的 JavaScript 库，用于构建 web 应用中的视图层，既是 web 应用的前端用户页面。（一个用于构建用户界面的 javascript 库，与 2012 年由 Facebook 创建，13 年 5 月开源维护） 2.创建 react 项目指令使用 123456#全局安装react脚手架npm install create-react-app@5.0.1 -g#创建项目 名称create-react-app react-basic#进入项目根目录启动项目npm start 目录结构分析 1234567891011121314151617181920# 项目结构分析├── README.md # 项目的说明书├── package.json # npm 包说明文件、记录项目信息├── package-lock.json # 跟踪被安装的每个软件包的确切版本├── public # 本地开发服务器提供的静态资源目录│ ├── favicon.ico # 网站图标、显示在浏览器的标签栏中│ ├── index.html # 项目的 HTML 模板│ ├── logo192.png # react logo 图片 (示例代码中用于设置 IOS 移动端网站图标)│ ├── logo512.png # react logo 图片│ ├── manifest.json # web 应用清单如名称, 作者, 图标和描述 (主要用于将 Web 应用程序安装到设备的主屏幕)│ └── robots.txt # 爬虫协议文件└── src # 项目源码目录 ├── App.css # 示例程序中的根组件样式文件 ├── App.js # 示例程序中的根组件文件 ├── App.test.js # 示例程序中的根组件测试文件 ├── index.css # 示例程序中的全局样式文件 ├── index.js # 项目的入口文件 ├── logo.svg # 示例程序中根组件中显示的网站图标文件 ├── reportWebVitals.js # 测试应用程序的性能 └── setupTests.js # 项目的测试文件 3.react 初使用123456789101112#创建h1元素#参数属性-》(标记名称，标记属性，子元素...);const title = React.createElement( &quot;h1&quot;, &#123;title:&quot;hello&quot;,id:1&#125;, &quot;hello react&quot;)document.createElement(&quot;h1&quot;);#获取public文件下的index.html中的div盒子idconst root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;))#使用render方法生成template模板root.render(title); 4.JSX 概述 jsx 概念 jsx 语法是 React 提供另一种创建用户界面的方式，看起来很像 HTML,但他绝不是 HTML,他是一只 JavaScript 语法扩展。facebook 处于性能考虑，解决必须通过 React.createElement 创建元素，创建出了 jsx，在应用构建的过程中 jsx 由 babel(js 编译器)转换成 React.createElement 方法调用 代码样式 1234567891011const list = ( &lt;div className=&quot;list&quot;&gt; &lt;h2&gt;Hello React&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;hello&lt;/li&gt; &lt;li&gt;react&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;);const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(list); 5.JSX 注意事项(1)JSX 格式美化 当 jsx 中存在多个标记使用小括号（）进行包裹，使代码格式美化排列，创建元素时，元素的最外层必须要有一个根标记 1234567const jsx = ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;); (2)避免出现无意义标记，可使用幽灵标记&lt;&gt;&lt;&#x2F;&gt;(完整语法&lt;React.Fragment&gt;&lt;&#x2F;React.Fragment&gt;) 123456const jsx = ( &lt;&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;/&gt;); (3)JSX 中使用单标签必须是闭合状态 12&lt;input type=&quot;text&quot;/&gt;&lt;img src=&quot;&quot; alt=&quot;&quot;/&gt; (4)在 JSX 中标记属性使用小驼峰命名法 （由多个单词组成，第一个单词首字符小写，其他单词首字符大写） 1&lt;input maxLength=&quot;100&quot; readOnly autoFocus /&gt; (5)在 JSX 中为元素添加属性时使用 className 代替 class、htmlFor 代替 for （jsx 本质上是 javaScript） 12&lt;input type=&quot;text&quot; className=&quot;todos&quot;/&gt;&lt;label htmlFor=&quot;demo&quot;/&gt; 6.JSX 嵌入表达式含义：将表达式产生的值渲染到用户界面中。 表达式就是一个能够产生结果的式子,jsx 里面只能放表达式，非表达式不能被嵌入 JSX 插入值（{}花括号）包裹插入属性值 123//插入文本内容const name = &quot;张三&quot;;const jsx = &lt;div&gt;&#123;name&#125;&lt;/div&gt;; 123//插入属性值const activeName = &quot;active&quot;;const jsx = &lt;input type=&quot;text&quot; className=&#123;activeName&#125; /&gt;; 1234//计算const x = 10;const y = 20;const jsx = &lt;p&gt;&#123;x * y&#125;&lt;/p&gt;; 12345//渲染函数返回值function getValue() &#123; return &quot;jsx&quot;;&#125;const jsx = &lt;p&gt;&#123;getValue()&#125;&lt;/p&gt;; 123//表达式const status = true;const jsx = status ? &lt;div&gt;true&lt;/div&gt; : &lt;div&gt;false&lt;/div&gt;; 12//插入对象 内容中不能直接插入对象const jsx = &lt;p style=&#123;&#123; width: 200 &#125;&#125;&gt;&#123;&#123; name: &quot;jsx&quot; &#125;&#125;&lt;/p&gt;; 1234//注释&#123; /**/&#125; 7.条件渲染（1）使用 if 分支语句进行条件渲染 123456789const Status = fasle;function getContent() &#123; if (Status) &#123; return &lt;span&gt;true&lt;/span&gt;; &#125; else &#123; return &lt;span&gt;fasle&lt;/span&gt;; &#125;&#125;const jsx = &lt;div&gt;&#123;getContent()&#125;&lt;/div&gt;; （2）使用三元运算符进行条件渲染 12const Status = false;const jsx = Status:&lt;span&gt;true&lt;/span&gt;:&lt;span&gt;false&lt;/span&gt; (3)使用逻辑运算符进行条件渲染 123逻辑运算符 &amp;&amp;,全为真时返回真，有一个为假返回假true&amp;&amp;truefalse&amp;&amp;true","tags":["React"],"categories":["React使用"]},{"title":"Vue状态管理","path":"/Vue/Vue状态管理/","content":"- Pinian状态管理工具概念： Pinia是Vue3的存储库，允许跨组件&#x2F;页面共享状态。一个轻量级的状态管理库，提供简单的API来管理应用程序的状态。适合中小型应用和低复杂的vue.js项目。 优点：1.更加轻量级：体积小（约1KB），不需要Vuex的一些复杂模块（mutations） 2.更加简单易用：Pinia的API设计使用了Vue3的新特性，如Composition API 3.更加灵活：提供了更加灵活的管理状态方式，支持多个store实例，而Vuex只支持一个store实例 4.对typescript更友好：与ts一起使用时有可靠的类型推断 缺点： 代码： 12345678910111213141516171819202122232425262728293031321.安装 npm i pinia2.创建stores文件夹,index.ts import &#123;createPinia&#125; from &#x27;pinia&#x27;3.创建实例 const store = createPinia()4.暴露出去 export default store5.在main.ts中集成 引入store import store form &#x27;&#x27;6.集成 app.use(store)7.在store文件夹中定义一个user import &#123;defineStore&#125; from &#x27;pinia&#x27; export const userStore = defineStore(&#x27;user&#x27;,&#123; state:()=&gt;&#123; return&#123; user:&#123;&#125; &#125; &#125;, actions:&#123; saveUser(user)&#123; this.user = user &#125; &#125;, getters:&#123; user:(state) = &gt;state.user &#125; &#125;)8.在需要的页面引入 Impor userStore - Vuex状态管理工具","tags":["Vue"],"categories":["Vue使用"]},{"title":"Vue指令v-指令名","path":"/Vue/Vue指令/","content":"一、指令修饰符1.v-on 指令修饰符 作用：v-on 基于在 vue 程序中绑定事件 语法：&lt;div v-on:事件名称=&quot;事件处理函数|js表达式&quot;&gt;&lt;/div&gt;简写: 使用@代替v-on，@事件名称=“事件处理函数|js表达式” 修饰符： ———- 事件.修饰符名称 语法: @事件名.修饰符&#x3D;“methods 里函数” .stop - 阻止事件冒泡 .prevent - 阻止默认行为 .once - 程序运行期间, 只触发一次事件处理函数 按键修饰符： @keyup.enter-检测回车按钮 @keyup.esc-检测返回按钮 代码： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 点击按钮的时候，修改isShow数据的值即可 --&gt; &lt;!-- v-on:事件名称=&quot;事件处理函数|js表达式&quot; --&gt; &lt;!-- js表达式 --&gt; &lt;!-- &lt;button v-on:click=&quot;isShow=!isShow&quot;&gt;切换显示隐藏&lt;/button&gt; --&gt; &lt;!-- 绑定函数 --&gt; &lt;!-- &lt;button v-on:click=&quot;toggleShow&quot;&gt;切换显示隐藏&lt;/button&gt; --&gt; &lt;!-- v-on: 绑定事件略显麻烦，可以简写成@ --&gt; &lt;button @click=&quot;toggleShow&quot;&gt;切换显示隐藏&lt;/button&gt; &lt;div v-show=&quot;isShow&quot;&gt;我是一个div&lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; isShow: true, &#125;, methods: &#123; // 声明一个函数 toggleShow() &#123; this.isShow = !this.isShow; &#125;, &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.v-bind 指令修饰符 作用：动态绑定属性值 语法：&lt;div v-bind:标签属性名称=&quot;数据名称|js表达式&quot;&gt;&lt;/div&gt; 简写： 使用 :代替v-bind，:属性名=&quot;数据名称|js表达式&quot; 修饰符： .sync 对 props 进行双向绑定，不能和表达式一起使用 v-bind:属性名称.sync，Vue3 中移除 代码： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- v-bind:标签属性名称=&quot;数据名称|js表达式&quot; --&gt; &lt;!-- &lt;div v-bind:title=&quot;title&quot;&gt;我是一个DIV&lt;/div&gt; --&gt; &lt;div :title=&quot;title&quot;&gt;我是一个DIV&lt;/div&gt; &lt;button @click=&quot;fn&quot;&gt;改title&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; title: &quot;abcd&quot;, &#125;, methods: &#123; fn() &#123; this.title = &quot;1234&quot;; &#125;, &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.v-model 指令修饰符 作用：给表单元素扩展双向数据绑定功能 语法：&lt;div v-model=&quot;数据变量&quot;&gt;&lt;/div&gt; 修饰符：v-model.修饰符 &#x3D; “数据变量” v-model.number 以 parseFloat 转为数字类型 v-model.trim去除首尾空白字符 v-model.lazy在 change 时触发而非 input 代码： 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;name&quot; type=&quot;text&quot; /&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;script&gt; const vm = new vue(&#123; el: &quot;#app&quot;, data: &#123; name: &quot;xxx&quot;, &#125;, &#125;);&lt;/script&gt; 二、常用指令1.v-bind 语法：v-bind:xxx=&quot;xxx&quot; 简写：:xxx&#x3D;”xxx” 作用：单项数据绑定（为标签属性绑定动态值） 2.v-for 语法：v-for=&quot;(item,index) in xxx&quot; :key=&quot;item.di&quot; key 唯一值 作用：遍历列表进行渲染 3.v-on 语法：v-on:事件名名称=&quot;事件回调函数&quot; 简写：@事件名称&#x3D;”事件回调函数” 作用：绑定事件 4.v-if&#x2F;e-else-if&#x2F;v-else 语法：v-if=&quot;xxx&quot; 作用：条件判断渲染（让元素显示或隐藏） 在 vue3 中 v-if 和 v-fot 相比优先级更高，可以一起使用。在 vue2 中 v-for 更高，实际不能一起使用 5.v-show 语法：v-show=&quot;xxx&quot; 作用：条件渲染（让元素显示或隐藏） v-if 和 v-show 区别： v-if 隐藏时会销毁元素 v-show 是通过修改样式 display:none 进行隐藏 6.v-model 语法：v-model=&quot;xxx&quot; 作用：进行双向数据绑定 7.v-slot 语法：v-slot:xxx&#x2F;v-slot&#x3D;”{xxx}”&#x2F;v-slot:xxx&#x3D;”{xxx}” 简写：#xxx #default&#x3D;”{xxx}” #xxx&#x3D;”{xxx}” 作用：父子组件进行通信，通信标签数据 8.v-memo（V3 新增） 语法：v-memo=&quot;[xxx]&quot; 作用：用来缓存部分模板页面（DOM 元素） 三、不常用指令1.v-html 语法：v-html=&quot;xxx&quot; 作用：设置元素的 innerHTML 2.v-text 语法：v-text&#x3D;”xxx” 作用：设置元素的 textContent 3.v-once 让模板解析一次 4.v-pre 跳过解析，直接将原始内容渲染 5.v-cloak 用于渲染为完成编译的 DOM 模板","tags":["Vue"],"categories":["Vue使用"]},{"title":"Vue基础概念","path":"/Vue/Vue基础概念/","content":"一、Vue 概念概念：Vue 是一个渐进式的 javascript 框架。渐进式就是可以配合其他的工具进行开发，如 Vue-router、Vuex、axios。 作用：vue 适合开发前后端分离的项目(SPA 类型)，单页面应用程序—在一个页面中实现所有的功能，没有真正的路径跳转。 核心： 数据驱动视图 只需要修改页面绑定的数据就可以更新其对应的视图，优化 DOM 操作，提高开发效率。 MVVM（双向数据绑定）让数据实现双向绑定，实心数据自动双向同步 M—Model(数据模型)在 data 中定义，M 修改数据-&gt;V 视图自动同步 V—View(视图页面)在 html 中，V 修改视图-&gt;M 数据自动同步 VM—ViewModel（视图模型） 组件化开发 将页面按照功能拆分成单独的组件，每一个组件有独立的功能，提高代码的可复用性和维护。 二、Vue 安装通过 script 引入 本地下载 https://cn.vuejs.org/js/vue.js 下载地址 放在本地项目，script 引入即可 cdn 的方式 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&gt;&lt;/script&gt; 通过 npm 安装 下载 npm i vue 导入 const Vue = require(&#39;vue&#39;) import Vue from &#39;vue&#39; 注意 前端开发，在浏览器运行不行。 需要借助一些工具才能支持 以上写法。","tags":["Vue"],"categories":["Vue使用"]},{"title":"React路由[V6]","path":"/React/react路由v6/","content":"React 路由[V6]1.集成应用1234//创建应用create-react-app 项目名//安装路由库npm install react-router-dom@6.4.3 项目中应用 1234567891011121314// src/index.jsimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;// createBrowserRouter: 用于创建基于浏览器历史记录的路由系统// RouterProvider: 用于配置路由系统的组件import &#123; createBrowserRouter, RouterProvider &#125; from &quot;react-router-dom&quot;;// 创建路由系统const router = createBrowserRouter([ // 当用户在浏览器中访问 / 路径时,渲染对应组件 &#123; path: &quot;/&quot;, element: &lt;Home /&gt; &#125;,]);const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));// 使路由规则生效root.render(&lt;RouterProvider router=&#123;router&#125; /&gt;); 2.配置路由组件01.创建页面组件 123456789101112// src/pages/home/index.jsimport React from &quot;react&quot;;export default function HomePage() &#123; return &lt;div&gt;首页页面&lt;/div&gt;;&#125;// src/pages/news/index.jsimport React from &quot;react&quot;;export default function HomePage() &#123; return &lt;div&gt;新闻页面&lt;/div&gt;;&#125; 02.配置路由规则 123456789// src/index.jsimport HomePage from &quot;./pages/home&quot;;// 注意: 在 v6 版本中，请求路径 / 不再需要使用 exact 属性const router = createBrowserRouter([ // 当用户在浏览器中访问 / 路径时, 渲染 &lt;HomePage /&gt; 组件 &#123; path: &quot;/&quot;, element: &lt;HomePage /&gt; &#125;, // 当用户在浏览器中访问 /topic 路径时, 渲染 &lt;TopicPage /&gt; 组件 &#123; path: &quot;/topic&quot;, element: &lt;TopicPage /&gt; &#125;,]); 3.嵌套路由使一级路由和二级路由关联 12345678910111213const router = createBrowserRouter([ // 当用户在浏览器中访问 /news 路径时, 渲染 &lt;NewsPage /&gt; 组件 &#123; path: &quot;/news&quot;, element: &lt;NewsPage /&gt;, children: [ // 当用户在浏览器中访问 /news/company 路径时, 将 &lt;CompanyNewsPage /&gt; 组件渲染到 &lt;NewsPage /&gt; 组件中 &#123; path: &quot;company&quot;, element: &lt;CompanyNewsPage /&gt; &#125;, // 当用户在浏览器中访问 /news/industry 路径时, 将 &lt;IndustryNewsPage /&gt; 组件渲染到 &lt;NewsPage /&gt; 组件中 &#123; path: &quot;industry&quot;, element: &lt;IndustryNewsPage /&gt; &#125;, ], &#125;,]); 在一级路由页面添加占位符()给子级路由渲染位置 1234567// src/pages/news/index.jsimport &#123; Outlet &#125; from &quot;react-router-dom&quot;;export default function NewsPage() &#123; // 子路由页面组件将会被渲染到占位符组件所在的位置 return &lt;Outlet /&gt;;&#125; 4.导航链接使用 react 提供的 Link 组件实现路由跳转, 通过 NavLink 组件生成的链接在被激活时 React Router 会为其添加激活类名，默认激活类名为 active 1234567891011 &lt;div&gt; &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt; &lt;ink to=&quot;/topic&quot;&gt;专题&lt;/Link&gt; &lt;ink to=&quot;/news&quot;&gt;新闻&lt;/Link&gt; &lt;/div&gt;----------------------------&lt;div&gt; &lt;NavLink to=&quot;/&quot;&gt;首页&lt;/NavLink&gt; &lt;NavLink to=&quot;/topic&quot;&gt;专题&lt;/NavLink&gt; &lt;NavLink to=&quot;/news&quot;&gt;新闻&lt;/NavLink&gt; &lt;/div&gt; 5.路由路径传参01.路由规则定义可选参数 1&#123;path:&quot;url/:参数名&quot;,element:&lt;路由指向的组件/&gt;&#125; 02.页面组件中实现参数传递 (to&#x3D;”url&#x2F;参数”) 12345678910111213141516import &#123; Link &#125; from &quot;react-router-dom&quot;;export default function Page() &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&quot;/team/team-a&quot;&gt;Team A&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/team/team-b&quot;&gt;Team B&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; );&#125; 12//获取路由参数 -参数名为路由规则中的:参数名const &#123; 参数名 &#125; = useParams(); 6.路由查询参数在页面组件中进行页面跳转时实现路由传递参数 01.配置路由规则 1234567const router = createBrowserRouter([ &#123; path: &quot;/&quot;, element: &lt;Layout /&gt;, children: [&#123; path: &quot;login&quot;, element: &lt;LoginPage /&gt; &#125;], &#125;,]); 02.页面组件传参 （路径？路由参数） 1234567export default function HomePage() &#123; return ( &lt;p&gt; &lt;Link to=&quot;/login?returnUrl=testUrl&quot;&gt;登录&lt;/Link&gt; &lt;/p&gt; );&#125; 03.获取路由参数 1234// 获取路由查询参数操作对象const [searchParams] = useSearchParams();// 获取路由参数 returnUrl 的值const returnUrl = searchParams.get(&quot;returnUrl&quot;); 7.页面跳转回到顶部01.页面在进行跳转时滚动的位置不会回滚到顶部使用 react 提供的组件可以在跳转的页面实现页面回滚到顶部 12345import &#123; ScrollRestoration &#125; from &quot;react-router-dom&quot;;export default function Layout() &#123; return &lt;ScrollRestoration /&gt;;&#125; 02.阻止回滚到顶部通过 Link 组件的 preventScrollReset 选项阻止滚动恢复 123&lt;Link to=&quot;/topic&quot; preventScrollReset=&#123;true&#125;&gt; 专题&lt;/Link&gt; 8.路由组件懒加载01.通过 React 提供的 lazy 方法和 Suspense 组件实现路由组件懒加载lazy 方法用于懒加载组件、Suspense 组件用于渲染加载过程中的等待状态。 12345678910111213141516171819202122// 通过懒加载的方式导入组件const HomePage = lazy(() =&gt; import(&quot;./pages/home&quot;));//组件实现懒加载状态const router = createBrowserRouter([ &#123; path: &quot;/&quot;, element: &lt;Layout /&gt;, children: [ &#123; path: &quot;&quot;, element: ( &lt;Suspense fallback=&#123;&lt;Fallback /&gt;&#125;&gt; // &lt;Fallback /&gt; 为组件加载过程中的样式组件 &lt;HomePage /&gt; &lt;/Suspense&gt; ), &#125;, ], &#125;,]); 02.Suspense 组件复用实现懒加载状态 创建 loadable 方法复用 Suspense 组件 123456789export default function loadable(Component) &#123; return function (props) &#123; return ( &lt;Suspense fallback=&#123;&lt;Fallback /&gt;&#125;&gt; &lt;Component &#123;...props&#125; /&gt; &lt;/Suspense&gt; ); &#125;;&#125; 123456// src/index.js// 1. 多行选择: 按住鼠标滚动拖动// 2. 选择下一个单词: alt + shift + =&gt;// 3. 选择到行尾: ctrl + shift + =&gt;// 4. 选择下一个字符: shift + =&gt;const HomePage = loadable(lazy(() =&gt; import(&quot;./pages/home&quot;))); 9.404 页面配置创建自己定义的 404 组件页面 NotFoundPage，使用 errorElement 方法，当用户访问了一个不存在的路由路径时就会跳转该页面。 1234567const router = createBrowserRouter([ &#123; path: &quot;/&quot;, // 当用户访问了一个不存在的路由路径时, 渲染 PageNotFound 组件 errorElement: &lt;NotFoundPage /&gt;, &#125;,]);","tags":["React"],"categories":["React使用"]},{"title":"HTML基础","path":"/Html/html基础/","content":"HTML 基础一、HTML 简介 HTML 是一种超文本标记语言(HypterText Markup Language) 描述网页内容: 标记：由标签构成 -&gt; 尖括号包围的关键词，如：&lt;html&gt; HTML 标签有两种 单标签：一些特殊标签必须单个出现，如 &lt;img/&gt; 双标签：标签成对出现，如 &lt;html&gt;&lt;/html&gt; HTML 基本结构：html -&gt; head , body html 标签：是整个文件的 根标签 (所有内容都需要包含在其中) head 标签：代表整个页面的 头部（包含当前页的关键信息） title 标签：让页面有一个属于自己的 标题 body 标签：代表整个页面的 身体（包含当前页给用户看的的主要内容） 二、HTML 标签： 标签 名称 说明 h1~h6 标题标签 HTML 提供了 6 个等级的标题，代表不同的重要程度 &lt;div&gt;&lt;/div&gt; 布局标签 内容常使用的标签 &lt;span&gt;&lt;/span&gt; 布局标签 通常网页布局都可以使用此标签布局 &lt;p&gt;&lt;/p&gt; 段落 可以把网页分为若干个段落 &lt;br/&gt; 换行 强制换行 &lt;ol&gt;&lt;/ol&gt; 有序列表 展示有序列表，里面指令包含 li 标签，有顺序 &lt;ul&gt;&lt;/ul&gt; 无序列表 展示无序列表，里面只能包含 li 标签，没有顺序 &lt;dl&gt;&lt;/dl&gt; 自定义列表 里面只能包含 dt 和 dd(兄弟标签)，经常一个 dt 对应多个 dd &lt;img src=&quot;图片路径&quot;&gt; 图像标签 在网页中插入 指定路径的图片 &lt;audio&gt;&lt;/audio&gt; 音频标签 网页中插入音频文件播放 &lt;video&gt;&lt;/video&gt; 视频标签 网页中插入视频文件播放 &lt;a href=&quot;跳转目标&quot;&gt;&lt;/a&gt; 链接标签 从当前跳转到目标 &lt;hr/&gt; 水平线标签 100%宽度水平分割线，并且独占一行 &lt;form action=&quot;&quot;&gt;&lt;/form&gt; 表单 表单区域标签，通常此标签内放输入框、单选、多选、多行文本框、下拉选项菜单等表单内容 &lt;label for=&quot;对应值&quot;&gt;&lt;/label&gt; 对应选择上控件 点击标签文字时，实现对应控件被选择 &lt;input type=&quot;submit&quot;/&gt; form 表单的 input 控件 type 值可选，submit 为按钮控件，text 输入框控件，checkbox 多选框，radio 单选框 &lt;textarea&gt;&lt;/textarea&gt; 内容输入控件 参数 cols 为字符宽度。Rows 为行数,都跟跟具体数字 &lt;select name=&quot;&quot;&gt;&lt;/select&gt; 表单下拉 表单下拉列表，内部包含&lt;section&gt;标签， &lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 表格 table 表格实用于多列数据列表 三、HTML 语义化标签1.含义：语义化标签，让标签具有语义的含义 2.常用语义化标签：1234567891011121314151617&lt;header&gt;&lt;/header&gt;：头部标签&lt;nav&gt;&lt;/nav&gt;：标记导航&lt;main&gt;&lt;/main&gt;：页面主要内容&lt;section&gt;&lt;/section&gt;：区块&lt;aside&gt;&lt;/aside&gt;：侧边栏&lt;footer&gt;&lt;/footer&gt;：底部标签 3.作用： 没有 css 样式时页面的整体也会体现良好的结构效果。 页面内容结构化，方便其他设备解析。 有利于 SEO（搜索引擎）优化，有助于爬虫抓取更多有效信息。 代码结构清晰，方便团队开发和维护。","tags":["html"],"categories":["html使用"]},{"path":"/about/index.html","content":"联系方式 手机：156****9428 Email：331****&#x33;&#x32;&#48;&#x40;&#113;&#113;&#x2e;&#99;&#x6f;&#x6d; 个人信息 国朋&#x2F;男&#x2F;2001 本科&#x2F;上海开放大学 技术博客：http://mistbollon.github.io Github：http://github.com/mistbollon 期望职位：Web 前端程序员 技能清单 熟练掌握 HTML5+CSS 3 页面布局、实现常见动画效果。 熟练掌握 Vue2&#x2F;3、VueX、Vue Router。 熟练掌握 React 框架、Hooks API、ReduxToolkit。 熟练掌握 JavaScript 语法，有良好代码规范。 熟悉前端 UI 库，如：ElementUI、iView 。 熟悉微信小程序，了解 uni-app 框架开发。 了解基于 python 的 Django 框架进行数据库开发。 熟悉 Git 代码版本工具，配合团队进行开发。 项目经历 咨询头条项目描述：移动端科技咨询类应用技术栈：React+TypeScript+redux+hooks+less 采用 TypeScript 校验开发 使用 redux toolkit 配置全局状态库 封装应用组件进行开发 物换物小程序项目描述：该项目是基于 uni-app 框架开发的微信小程序闲置物品交换平台技术栈:uni-app+Vue3+TypeScript+Django+Mysql 页面使用 uni-app 框架搭建布局 前端使用 Vue 3 和 TypeScript 实现效果 后端使用 Django 框架进行对 mysql 数据库的开发 易购物项目描述：PC 端在线购物平台技术栈：Vue3+TypeScript+less+Pinia 使用 TypeScript 进行开发 配置 less 解析 使用 Pinia 持久化存储状态 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"这是分页标题","path":"/wiki/conduit/07-综合案例-conduit.html","content":"综合案例 - conduit"},{"title":"项目配置","path":"/wiki/React/支持 TypeScript 的 React 应用.html","content":"React+ Type Script 应用1.应用创建12create-react-app 项目名称 --template typescriptnpm start 2.配置路径别名 (使用@可以找到要导入的部分)配置路径别名分为两部分，第一部分是使 Vs Code 识别路径别名(代码提示)，第二部分是使 web pack 识别路径别名(编译代码)。 ① 在应用的根目录下创建 tsconfig.paths.json 文件用于扩展 TS 配置选项，当前用于配置路径别名。 12345678910111213141516&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@shared/*&quot;: [&quot;./src/shared/*&quot;], &quot;@pages/*&quot;: [&quot;./src/pages/*&quot;], &quot;@router/*&quot;: [&quot;./src/router/*&quot;], &quot;@store/*&quot;: [&quot;./src/store/*&quot;], &quot;@slice/*&quot;: [&quot;./src/store/slice/*&quot;], &quot;@service/*&quot;: [&quot;./src/store/service/*&quot;], &quot;@middlewares/*&quot;:[&quot;./src/store/middlewares/*&quot;], &quot;@styles/*&quot;: [&quot;./src/assets/styles/*&quot;], &quot;@images/*&quot;: [&quot;./src/assets/images/*&quot;] &#125; &#125;&#125; ② 在 tsconfig.json 文件中添加以下配置使用扩展配置文件生效 123&#123; &quot;extends&quot;: &quot;./tsconfig.paths.json&quot;&#125; ③ 覆盖 CRA 默认配置使 webpack 能够支持解析路径别名 1npm install react-app-rewired@2.2.1 react-app-alias@2.2.2 --save-dev 1234567// config-overrides.jsconst &#123; aliasWebpack &#125; = require(&quot;react-app-alias&quot;);module.exports = function override(config) &#123; aliasWebpack(&#123; tsconfig: &quot;./tsconfig.json&quot; &#125;)(config); return config;&#125;; 123456// package.json&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;,&#125;, 3.配置应用环境变量文件根目录创建.env 文件配置项目 API 接口地址 12# .env.developmentREACT_APP_BASE_URL=开发环境接口地址 12# .env.productionREACT_APP_BASE_URL=生产环境接口地址 VS Code 中添加 12345// settings.json&quot;files.associations&quot;: &#123; &quot;*.env.development&quot;: &quot;env&quot;, &quot;*.env.production&quot;: &quot;env&quot;&#125; 4.配置全局状态管理库① 在应用中下载 redux toolkit 和 react-redux 1npm install @reduxjs/toolkit@1.9.1 react-redux@8.0.5 ② 创建全局的 API 状态切片 12345678910// src/store/service/index.tsimport &#123; createApi, fetchBaseQuery &#125; from &quot;@reduxjs/toolkit/query/react&quot;;const apiService = createApi(&#123; reducerPath: &quot;apiReducer&quot;, baseQuery: fetchBaseQuery(&#123; baseUrl: process.env.REACT_APP_BASE_URL &#125;), endpoints: () =&gt; (&#123;&#125;),&#125;);export default apiService; ③ 创建 store 对象并配置 API 状态切片 123456789101112131415161718192021// src/store/index.tsimport &#123; configureStore &#125; from &quot;@reduxjs/toolkit&quot;;import apiService from &quot;@service/index&quot;;import &#123; useDispatch, TypedUseSelectorHook, useSelector &#125; from &quot;react-redux&quot;;const store = configureStore(&#123; devTools: process.env.NODE_ENV !== &quot;production&quot;, reducer: &#123; [apiService.reducerPath]: apiService.reducer, &#125;, middleware: (getDefaultMiddleware) =&gt; getDefaultMiddleware().concat([apiService.middleware]),&#125;);export default store;export type AppDispatch = typeof store.dispatch;export const useTypedDispatch = () =&gt; useDispatch&lt;AppDispatch&gt;();export type AppState = ReturnType&lt;typeof store.getState&gt;;export const useTypedSelector: TypedUseSelectorHook&lt;AppState&gt; = useSelector; ④ 配置 Provider 组件 123456789// src/index.tsximport &#123; Provider &#125; from &quot;react-redux&quot;;import store from &quot;@store/index&quot;;root.render( &lt;Provider store=&#123;store&#125;&gt; &lt;div&gt;App works&lt;/div&gt; &lt;/Provider&gt;); 5.配置路由管理库① 下载 react-router-dom 路由库 12# 该库自带 TypeScript 类型声明文件 不需要单独下载npm install react-router-dom@6.6.1 ② 创建登录页面路由组件用于测试路由是否配置成功 1234// src/pages/home/index.tsxexport default function HomePage() &#123; return &lt;div&gt;HomePage&lt;/div&gt;;&#125; ③ 创建 AppRouter 组件用于配置应用路由规则 1234567891011121314// src/router/index.tsximport HomePage from &quot;@pages/home&quot;;import &#123; createBrowserRouter, RouterProvider &#125; from &quot;react-router-dom&quot;;export const router = createBrowserRouter([ &#123; path: &quot;/&quot;, element: &lt;HomePage /&gt;, &#125;,]);export default function AppRouter() &#123; return &lt;RouterProvider router=&#123;router&#125; /&gt;;&#125; ④ 在应用入口文件中调用 AppRouter 组件使路由系统生效 12345678// src/index.tsximport AppRouter from &quot;@router/index&quot;;root.render( &lt;Provider store=&#123;store&#125;&gt; &lt;AppRouter /&gt; &lt;/Provider&gt;); 6.配置 CSS 预处理器 LESS1npm i less@4.1.3 less-loader@11.1.0 123456789101112// config-overrides.jsfunction addLessLoader(config) &#123; config.module.rules[1].oneOf.splice(2, 0, &#123; test: /\\.less$/i, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;);&#125;module.exports = function override(config) &#123; addLessLoader(config); return config;&#125;; 1234567891011121314151617// src/assets/styles/color.less// 主色@mainColor: #fc6627;// 文字颜色@textColor: #646566;// 文字辅助颜色@textHelperColor: #faab0c;// 边框色@borderColor: #ebedf0;// 成功色@successColor: #07c160;// 报错色@errorColor: #ee0a24;// 通知消息中的文本色@noticeTextColor: #ed6a0c;// 背景色@bgColor: #f8f8f8; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// src/assets/styles/base.less@import &quot;@styles/color.less&quot;;*,*::before,*::after &#123; box-sizing: border-box;&#125;* &#123; margin: 0;&#125;body &#123; -webkit-font-smoothing: antialiased; color: @textColor; font-size: 3.4667vw;&#125;img,picture,video,canvas,svg &#123; display: block; max-width: 100%;&#125;input,button,textarea,select &#123; font: inherit; outline: none; border: none; background: none; color: @textColor;&#125;p,h1,h2,h3,h4,h5,h6 &#123; overflow-wrap: break-word;&#125;ul &#123; padding: 0; list-style: none;&#125;a &#123; text-decoration: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125; 12// src/index.tsximport &quot;@styles/base.less&quot;; 7.解决移动端 1px 边框问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174// src/assets/styles/hairline.less@import &quot;./color&quot;;.scale-hairline-common(@color, @top, @right, @bottom, @left) &#123; content: &quot;&quot;; position: absolute; background-color: @color; display: block; z-index: 1; top: @top; right: @right; bottom: @bottom; left: @left;&#125;.hairline(@direction, @color: @borderColor) when (@direction = &quot;top&quot;) &#123; border-top: 1px solid @color; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; border-top: none; &amp;::before &#123; .scale-hairline-common(@color, 0, auto, auto, 0); width: 100%; height: 1px; transform-origin: 50% 50%; transform: scaleY(0.5); @media (min-resolution: 3dppx) &#123; transform: scaleY(0.33); &#125; &#125; &#125; &#125;&#125;.hairline(@direction, @color: @borderColor) when (@direction = &quot;right&quot;) &#123; border-right: 1px solid @color; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; border-right: none; &amp;::after &#123; .scale-hairline-common(@color, 0, 0, auto, auto); width: 1px; height: 100%; background: @color; transform-origin: 100% 50%; transform: scaleX(0.5); @media (min-resolution: 3dppx) &#123; transform: scaleX(0.33); &#125; &#125; &#125; &#125;&#125;.hairline(@direction, @color: @borderColor) when (@direction = &quot;bottom&quot;) &#123; border-bottom: 1px solid @color; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; border-bottom: none; &amp;::after &#123; .scale-hairline-common(@color, auto, auto, 0, 0); width: 100%; height: 1px; transform-origin: 50% 100%; transform: scaleY(0.5); @media (min-resolution: 3dppx) &#123; transform: scaleY(0.33); &#125; &#125; &#125; &#125;&#125;.hairline(@direction, @color: @borderColor) when (@direction = &quot;left&quot;) &#123; border-left: 1px solid @color; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; border-left: none; &amp;::before &#123; .scale-hairline-common(@color, 0, auto, auto, 0); width: 1px; height: 100%; transform-origin: 100% 50%; transform: scaleX(0.5); @media (min-resolution: 3dppx) &#123; transform: scaleX(0.33); &#125; &#125; &#125; &#125;&#125;.hairline(@direction, @color: @borderColor, @radius: 0) when (@direction = &quot;all&quot;) &#123; border: 1px solid @color; border-radius: @radius; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; position: relative; border: none; &amp;::before &#123; content: &quot;&quot;; position: absolute; left: 0; top: 0; width: 200%; height: 200%; border: 1px solid @color; border-radius: @radius * 2; transform-origin: 0 0; transform: scale(0.5); box-sizing: border-box; pointer-events: none; // @media (min-resolution: 3dppx) &#123; // width: 300%; // height: 300%; // border-radius: @radius * 3; // transform: scale(0.33); // &#125; &#125; &#125; &#125;&#125;.hairline-remove(@position) when (@position = &quot;left&quot;) &#123; border-left: 0; &amp;:before &#123; display: none !important; &#125;&#125;.hairline-remove(@position) when (@position = &quot;right&quot;) &#123; border-right: 0; &amp;:after &#123; display: none !important; &#125;&#125;.hairline-remove(@position) when (@position = &quot;top&quot;) &#123; border-top: 0; &amp;:before &#123; display: none !important; &#125;&#125;.hairline-remove(@position) when (@position = &quot;bottom&quot;) &#123; border-bottom: 0; &amp;:after &#123; display: none !important; &#125;&#125;.hairline-remove(@position) when (@position = &quot;all&quot;) &#123; border: 0; &amp;:before &#123; display: none !important; &#125;&#125; 1234567891011// src/pages/home/index.tsximport styles from &quot;./styles.module.less&quot;;export default function HomePage() &#123; return ( &lt;&gt; &lt;div className=&#123;styles.one&#125;&gt;&lt;/div&gt; &lt;div className=&#123;styles.two&#125;&gt;&lt;/div&gt; &lt;/&gt; );&#125; 12345678910111213// src/pages/home/styles.module.less@import &quot;@styles/hairline.less&quot;;.one &#123; border-bottom: 1px solid red; margin: 10px 0;&#125;.two &#123; /* 注意: 设置1像素边框的元素必须是相对定位的 */ position: relative; .hairline(&quot;bottom&quot;, green);&#125; 1234567// src/@types/less.d.tsdeclare module &quot;*.module.less&quot; &#123; const classes: &#123; readonly [key: string]: string; &#125;; export default classes;&#125; 无限列表加载"}]