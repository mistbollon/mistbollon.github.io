[{"title":"React路由[V6]","path":"/React/react路由v6/","content":"React 路由[V6]1.集成应用1234//创建应用create-react-app 项目名//安装路由库npm install react-router-dom@6.4.3 项目中应用 1234567891011121314// src/index.jsimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;// createBrowserRouter: 用于创建基于浏览器历史记录的路由系统// RouterProvider: 用于配置路由系统的组件import &#123; createBrowserRouter, RouterProvider &#125; from &quot;react-router-dom&quot;;// 创建路由系统const router = createBrowserRouter([ // 当用户在浏览器中访问 / 路径时,渲染对应组件 &#123; path: &quot;/&quot;, element: &lt;Home /&gt; &#125;,]);const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));// 使路由规则生效root.render(&lt;RouterProvider router=&#123;router&#125; /&gt;); 2.配置路由组件01.创建页面组件 123456789101112// src/pages/home/index.jsimport React from &quot;react&quot;;export default function HomePage() &#123; return &lt;div&gt;首页页面&lt;/div&gt;;&#125;// src/pages/news/index.jsimport React from &quot;react&quot;;export default function HomePage() &#123; return &lt;div&gt;新闻页面&lt;/div&gt;;&#125; 02.配置路由规则 123456789// src/index.jsimport HomePage from &quot;./pages/home&quot;;// 注意: 在 v6 版本中，请求路径 / 不再需要使用 exact 属性const router = createBrowserRouter([ // 当用户在浏览器中访问 / 路径时, 渲染 &lt;HomePage /&gt; 组件 &#123; path: &quot;/&quot;, element: &lt;HomePage /&gt; &#125;, // 当用户在浏览器中访问 /topic 路径时, 渲染 &lt;TopicPage /&gt; 组件 &#123; path: &quot;/topic&quot;, element: &lt;TopicPage /&gt; &#125;,]); 3.嵌套路由使一级路由和二级路由关联 12345678910111213const router = createBrowserRouter([ // 当用户在浏览器中访问 /news 路径时, 渲染 &lt;NewsPage /&gt; 组件 &#123; path: &quot;/news&quot;, element: &lt;NewsPage /&gt;, children: [ // 当用户在浏览器中访问 /news/company 路径时, 将 &lt;CompanyNewsPage /&gt; 组件渲染到 &lt;NewsPage /&gt; 组件中 &#123; path: &quot;company&quot;, element: &lt;CompanyNewsPage /&gt; &#125;, // 当用户在浏览器中访问 /news/industry 路径时, 将 &lt;IndustryNewsPage /&gt; 组件渲染到 &lt;NewsPage /&gt; 组件中 &#123; path: &quot;industry&quot;, element: &lt;IndustryNewsPage /&gt; &#125;, ], &#125;,]); 在一级路由页面添加占位符()给子级路由渲染位置 1234567// src/pages/news/index.jsimport &#123; Outlet &#125; from &quot;react-router-dom&quot;;export default function NewsPage() &#123; // 子路由页面组件将会被渲染到占位符组件所在的位置 return &lt;Outlet /&gt;;&#125; 4.导航链接使用 react 提供的 Link 组件实现路由跳转, 通过 NavLink 组件生成的链接在被激活时 React Router 会为其添加激活类名，默认激活类名为 active 1234567891011 &lt;div&gt; &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt; &lt;ink to=&quot;/topic&quot;&gt;专题&lt;/Link&gt; &lt;ink to=&quot;/news&quot;&gt;新闻&lt;/Link&gt; &lt;/div&gt;----------------------------&lt;div&gt; &lt;NavLink to=&quot;/&quot;&gt;首页&lt;/NavLink&gt; &lt;NavLink to=&quot;/topic&quot;&gt;专题&lt;/NavLink&gt; &lt;NavLink to=&quot;/news&quot;&gt;新闻&lt;/NavLink&gt; &lt;/div&gt; 5.路由路径传参01.路由规则定义可选参数 1&#123;path:&quot;url/:参数名&quot;,element:&lt;路由指向的组件/&gt;&#125; 02.页面组件中实现参数传递 (to&#x3D;”url&#x2F;参数”) 12345678910111213141516import &#123; Link &#125; from &quot;react-router-dom&quot;;export default function Page() &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&quot;/team/team-a&quot;&gt;Team A&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/team/team-b&quot;&gt;Team B&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; );&#125; 12//获取路由参数 -参数名为路由规则中的:参数名const &#123; 参数名 &#125; = useParams(); 6.路由查询参数在页面组件中进行页面跳转时实现路由传递参数 01.配置路由规则 1234567const router = createBrowserRouter([ &#123; path: &quot;/&quot;, element: &lt;Layout /&gt;, children: [&#123; path: &quot;login&quot;, element: &lt;LoginPage /&gt; &#125;], &#125;,]); 02.页面组件传参 （路径？路由参数） 1234567export default function HomePage() &#123; return ( &lt;p&gt; &lt;Link to=&quot;/login?returnUrl=testUrl&quot;&gt;登录&lt;/Link&gt; &lt;/p&gt; );&#125; 03.获取路由参数 1234// 获取路由查询参数操作对象const [searchParams] = useSearchParams();// 获取路由参数 returnUrl 的值const returnUrl = searchParams.get(&quot;returnUrl&quot;); 7.页面跳转回到顶部01.页面在进行跳转时滚动的位置不会回滚到顶部使用 react 提供的组件可以在跳转的页面实现页面回滚到顶部 12345import &#123; ScrollRestoration &#125; from &quot;react-router-dom&quot;;export default function Layout() &#123; return &lt;ScrollRestoration /&gt;;&#125; 02.阻止回滚到顶部通过 Link 组件的 preventScrollReset 选项阻止滚动恢复 123&lt;Link to=&quot;/topic&quot; preventScrollReset=&#123;true&#125;&gt; 专题&lt;/Link&gt; 8.路由组件懒加载01.通过 React 提供的 lazy 方法和 Suspense 组件实现路由组件懒加载lazy 方法用于懒加载组件、Suspense 组件用于渲染加载过程中的等待状态。 12345678910111213141516171819202122// 通过懒加载的方式导入组件const HomePage = lazy(() =&gt; import(&quot;./pages/home&quot;));//组件实现懒加载状态const router = createBrowserRouter([ &#123; path: &quot;/&quot;, element: &lt;Layout /&gt;, children: [ &#123; path: &quot;&quot;, element: ( &lt;Suspense fallback=&#123;&lt;Fallback /&gt;&#125;&gt; // &lt;Fallback /&gt; 为组件加载过程中的样式组件 &lt;HomePage /&gt; &lt;/Suspense&gt; ), &#125;, ], &#125;,]); 02.Suspense 组件复用实现懒加载状态 创建 loadable 方法复用 Suspense 组件 123456789export default function loadable(Component) &#123; return function (props) &#123; return ( &lt;Suspense fallback=&#123;&lt;Fallback /&gt;&#125;&gt; &lt;Component &#123;...props&#125; /&gt; &lt;/Suspense&gt; ); &#125;;&#125; 123456// src/index.js// 1. 多行选择: 按住鼠标滚动拖动// 2. 选择下一个单词: alt + shift + =&gt;// 3. 选择到行尾: ctrl + shift + =&gt;// 4. 选择下一个字符: shift + =&gt;const HomePage = loadable(lazy(() =&gt; import(&quot;./pages/home&quot;))); 9.404 页面配置创建自己定义的 404 组件页面 NotFoundPage，使用 errorElement 方法，当用户访问了一个不存在的路由路径时就会跳转该页面。 1234567const router = createBrowserRouter([ &#123; path: &quot;/&quot;, // 当用户访问了一个不存在的路由路径时, 渲染 PageNotFound 组件 errorElement: &lt;NotFoundPage /&gt;, &#125;,]);","tags":["React"],"categories":["React使用"]},{"title":"ReduxToolkit全局状态管理","path":"/React/ReduxToolkit全局状态管理/","content":"ReduxToolkitReduxToolkit 是官方推出的基于 Redux 进行高度封装的工具包，不需下载就可下载，在开发过程中可以用更少的代码完成工作。 使用12345# 新项目# Redux + Plain JS templatenpx create-react-app my-app --template redux# Redux + TypeScript templatenpx create-react-app my-app --template redux-typescript 12# 现有项目 (@reduxjs/toolkit 和 react-redux 都自带ts类型声明文件, 不需要单独下载)npm install @reduxjs/toolkit@1.9.5 react-redux@8.0.5 一、方法1.createActioncreateAction 用于创建 action creator 函数，接收 action 对象的 type 属性作为参数 1export const creator = createAction(&quot;type&quot;); 2.createReducercreateReducer 用于创建 reducer 函数，使 reducer 函数中的代码细化和拆分。 addCase 调度操作的 action.type 与提供字段完全匹配运行 reducer。 addMatcher 里提供的函数返回 true 时运行 reducer。 123456export const Reducer = createReducer(state, (builder) =&gt; &#123; builder .addCase(creator, () =&gt; (&#123;&#125;)) .addMatcher((action) =&gt; action.type === &quot;action.type&quot;), (state, action) =&gt; (&#123;&#125;);&#125;); 3.configureStoreconfigureStore 创建和配置 Redux 的 store 对象。 1234567export const store = configureStore(&#123; reducer: &#123; counterReducer, &#125;, //是否开启redux工具 devTools: process.env.NODE_ENV !== &quot;production&quot;,&#125;); 4.useSelectoruseSelector 用于在函数式组件中获取 store 对象中的状态的方法,接收函数为参数，参数函数的参数表示状态对象，参数函数返回要获取的具体状态。 1const useSelector((state)=&gt;state.counterReducer.count); 5.useDispatchuseDispatch 是用于在函数式组件中获取 dispatch 的方法 12const dispatch = useDispatch();dispatch(获取dispatch); 6.createAsyncThunkcreateAsyncThunk 用于创建执行异步操作的 action creator 函数。第一个参数是 action 对象的 type 属性，第二个参数是指向异步操作的函数。 1234567export const Creators = createAsyncThunk(&quot;type属性&quot;, async () =&gt; &#123; const res = await axios.get(&quot;http://123&quot;); return res;&#125;);//Creators.pending-&gt;加载//Creators.fulfilled-&gt;请求成功//Creators.rejected-&gt;请求失败 调用 1234567891011121314151617181920const initialState = &#123; status: &quot;idle&quot;, data: [], error: null &#125;;export const Reducer = createReducer(initialState, (builder) =&gt; &#123; builder .addCase(loadTodos.pending, () =&gt; (&#123; status: &quot;loading&quot;, data: [], error: null, &#125;)) .addCase(loadTodos.fulfilled, (state, action) =&gt; (&#123; status: &quot;success&quot;, data: action.payload, error: null, &#125;)) .addCase(loadTodos.rejected, (state, action) =&gt; (&#123; status: &quot;error&quot;, data: [], error: action.error, &#125;));&#125;); 7.createSlice 状态切片action creator 函数、reducer 函数全部都由状态切片生成，状态切片可以使在开发时更专注于状态的管理。 1234567891011121314151617181920212223242526272829import &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;;// createSlice 方法的返回值是一个对象// actions: 该对象中存储的是操作状态 action creator 函数, reducers 配置对象中的函数名称将会作为 action creator 函数的名称// reducer: 原本开发者自己定义的 reducer 函数const &#123; actions, reducer: counterReducer &#125; = createSlice(&#123; // 状态名称, 该名称将会被用于 action 对象的 type 属性值的第一部分 name: &quot;counter&quot;, // 初始状态 initialState: &#123; count: 0 &#125;, // 方法接收两个参数, state 对象和 action 对象 // 在方法中可以直接对状态对象进行操作, 不需要返回新的状态对象 // 调用 action creator 函数时传递的参数将会被放置在 action.payload 属性中 reducers: &#123; increment: (state) =&gt; &#123; state.count += 1; &#125;, decrement: (state) =&gt; &#123; state.count -= 1; &#125;, incrementByCount: (state, action) =&gt; &#123; state.count = state.count + action.payload; &#125;, &#125;,&#125;);// 导出 action creator 函数供组件使用export const &#123; increment, decrement, incrementByCount &#125; = actions;// 导出 counterReducer 函数export default counterReducer; 7.1createSlice_prepareprepare 方法允许开发者在 action 指令发出后 reducer 函数接收前先对 action 对象中的 payload 属性值进行处理。 123456789101112incrementByCount: &#123; prepare: (payload) =&gt; &#123; // prepare 方法接收 payload 作为参数 // 要求返回对象, 该对象会和 action 对象进行合并 return &#123; payload: payload + 10, &#125;; &#125;, reducer: (state, action) =&gt; &#123; state.count = state.count + action.payload; &#125;, &#125;, 8.configureStore_middleware 配置中间件middleware 选项的值是一个函数，该函数有一个参数，该参数习惯被命名为 getDefaultMiddeware，它就是用来获取内置中间件函数的。etDefaultMiddeware 方法的返回值是一个数组，数组中包含内置的中间件函数，开发者只需要在该数组中添加中间件函数即可。middleware 选项要求在该函数中返回最新的中间件函数数组。 12345678//npm i redux-logger@3.0.6import logger from &quot;redux-logger&quot;;export const store = configureStore(&#123; middleware: (getDefaultMiddleware) =&gt; &#123; return getDefaultMiddleware().concat(logger); &#125;,&#125;);","tags":["React"],"categories":["React使用"]},{"title":"React 函数组件","path":"/React/react函数组件/","content":"一、函数组件函数组件是一个返回视图(JSX)的函数。 1.创建函数组件123function App() &#123; return &lt;div&gt;APP&lt;/div&gt;;&#125; 2.函数组件使用方法01.useState 声明组件状态​ 在 React 函数组件中可以通过 useState 方法创建组件状态，可以被调用多次声明多个状态。 123456789101112131415161718//useState方法返回值是一个数组，第一个参数是状态变量，第二个参数是修改/更新状态的方法。function App() &#123; const [value, setValue] = useState(&quot;状态初始值&quot;); const [count, seCount] = useState(0); retutn( &lt;&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;p&gt;&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setValue(&quot;修改的值&quot;)&#125;&gt;更改状态&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setVlaue(count + 1)&#125;&gt;更改数值+1&lt;/button&gt; //更新状态方法可以接收函数作为参数，通过参数函数返回值指定新状态值 //prevState表示更新前状态 //参数函数返回值表示更新后状态 &lt;button onClick=&#123;() =&gt; setCount((prevState) =&gt; prevState - 1)&#125;&gt; 更新数值-1 &lt;/button&gt; &lt;/&gt; );&#125; ​ 当多次调用修改状态的方法时，当传递状态值，最后面的状态会覆盖前面状态；当传递函数，顺序执行，所有函数执行完毕才会更新。 123456789101112131415161718192021222324//传递状态值，最后结果为count+2&lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setCount(count + 1); setCount(count + 1); setCount(count + 2); &#125; &#125; &gt; &#123;count&#125; &lt;/button&gt;//传递函数方法，顺序执行+1+1+1+1返回最终相加结果&lt;button onClick=&#123;() =&gt; &#123; setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); &#125; &#125; &gt; &#123;count&#125; &lt;/button&gt; 02.useEffect 确保函数式组件正确执行副作用代码​ 在 React 中，副作用指与组件渲染无关的操作，如获取数据、修改全局变量、更新 DOM 等。这些操作可能会影响组件渲染结果，但不能被纯函数捕获，因此需 useEffect 进行特殊处理，确保代码在正确时机执行。 ​ useEffect 接收一个回调函数和一个依赖数组作为参数，回调函数的代码会在组件渲染完成后执行，依赖数组的变量会在其发生变化时触发回调函数重新执行。 1234const [参数变量, 修改方法代码] = useState(&quot;&quot;);useEffect(() =&gt; &#123; //回调函数代码&#125;, [&quot;参数变量&quot;]); 03.useRef 获取 DOM 对象​ 通过 useRef 方法可以在函数式组件中获取 DOM 对象 1234function App()&#123; const name = useRef(); return &lt;input ref=&#123;name&#125; onChange=&#123;()=&gt;consloe.lgo(name.current)&#125;/&gt;&#125; 04.forwardRef 获取子组件 DOM 对象​ 通过 useRef 和 forward 高阶函数配合使用可以实现父子组件之间传递 ref 对象。 12345678910//appfunction App() &#123; const appref = useRef(); return &lt;Message ref=&#123;appref&#125; /&gt;;&#125;//messagefunction Message(props, ref) &#123; return &lt;span ref=&#123;ref&#125;&gt;message&lt;/span&gt;;&#125;export default forwardRef(Message); 05.受控组件和非受控组件受控表单组件 ​ 表单状态由 React 组件状态控制 12345678910111213141516171819202122232425function App() &#123; const [formState, setFormState] = useState(&#123; username: &quot;&quot;, password: &quot;&quot; &#125;); const onChangeHandler = (event) =&gt; &#123; setFormState(&#123; ...formState, [event.target.name]: event.target.value, &#125;); &#125;; return ( &lt;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&#123;formState.username&#125; onChange=&#123;onChangeHandler&#125; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&#123;formState.password&#125; onChange=&#123;onChangeHandler&#125; /&gt; &lt;/&gt; );&#125; 非受控表单组件 ​ 通过 DOM 获取&#x2F;修改值，使用 useRef 实现非受控表单组件 12345678910111213function App() &#123; const usernameRef = useRef(); const onSubmijs = (event) =&gt; &#123; event.preventDefault(); console.log(usernameRef.current.value); &#125;; return ( &lt;form onSubmit=&#123;onSubmijs&#125;&gt; &lt;input type=&quot;text&quot; ref=&#123;usernameRef&#125; /&gt; &lt;button&gt;button&lt;/button&gt; &lt;/form&gt; );&#125; 06.父子组件通信 - Props1.父组件传递状态到子组件，子组件修改父组件传递的状态值。 1234567891011//父组件function App() &#123; const [msg, setMsg] = useState(&quot;hello&quot;); //传递给子组件 return &lt;Message msg=&#123;mgs&#125; setMsg=&#123;setMsg&#125;&gt;&lt;/Message&gt;;&#125;//子组件function Message(props) &#123; //接收父组件传递的数据 return &lt;button onClick=&#123;() =&gt; props.setMsg(&quot;你好&quot;)&#125;&gt;&#123;props.msg&#125;&lt;/button&gt;;&#125; 2.设置 Props 对象默认值方式 123456789101112131415161718192021222324252627function App(props) &#123; return ( &lt;div&gt; &lt;Message name=&#123;&quot;张三&quot;&#125; age=&#123;30&#125; /&gt; &lt;/div&gt; );&#125;function Message(&#123; name = &quot;李四&quot;, age = 20 &#125;) &#123; return ( &lt;div&gt; &#123;name&#125; &#123;age&#125; &lt;/div&gt; );&#125;export default App;-------------------------function App()&#123; return &lt;Message/&gt;;&#125;function Message(&#123;name,age&#125;)&#123; return &lt;div&gt;&#123;name&#125;&#123;age&#125;&lt;/div&gt;&#125;Message.defaultProps=&#123; name:&quot;张三&quot;, age:20&#125; 07.父子组件通信-useImperativeHandle​ useImperativeHandle 允许父组件直接调用子组件暴露的成员属性和方法。 12345678910111213141516//App.jsfunction App() &#123; const msgRef = useRef(); return ( &lt;&gt; &lt;Message ref=&#123;msgRef&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; console.log(msgRef.current.value); &#125;&#125; &gt; getMsg &lt;/button&gt; &lt;/&gt; );&#125; 12345678910111213//Messagefunction Message(props, ref) &#123; const [value, setValue] = useState(&quot;&quot;); //useImperativeHandle用于设置ref对象中current属性的值，(参数传递ref对象，传递函数(函数返回什么ref对象的current属性值就是什么，组件每次重新渲染时执行)，数组(传递依赖状态)) useImperativeHandle(ref, () =&gt; (&#123; vlaue &#125;), [value]); return ( &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;(event) =&gt; setValue(event.target.value)&#125; /&gt; );&#125; 08.跨级组件通讯-useContext在组件中创建导出的对象，另一个组件中通过 useContext 方法就那些获取。 12345//创建上下文对象export const PersonContext = createContext(&#123; name: &quot;张三&quot;, age: 20 &#125;);//获取上下文状态const person = useContext(PersonContext); 09.组件状态逻辑分离-useReduceruseReducer 是 React 提供的另一种在函数式组件中声明状态的方式。将组件状态逻辑和组件渲染逻辑进行分离，使代码更加清晰可维护。useReducer 是 useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。 1234567891011121314151617function App()&#123; const [state,dispatch] = useReducer(counterReducer,&#123;count:0&#125;); return &lt;button onClick=&#123;()=&gt;dispatch(&#123;type:&quot;counter/increent&quot;&#125;)&#125;&gt;&#123;state.count&#125;&lt;/button&gt;&#125;-----------------------// src/counterReducer.jsexport default function counterReducer(state, action) &#123; switch (action.type) &#123; case &quot;counter/increment&quot;: return &#123; ...state, count: state.count + 1, &#125;; default: return state; &#125;&#125; 10.保存组件值-useRefuseRef 可以获取 DOM 元素，保存普通值；使用 useRef 保存的普通值并不会随组件更新而销毁，修改通过 useRef 保存的值也不会触发组件更新。 例：组件初次渲染开启定时器，点击按钮进行清空。 1234567891011121314151617181920212223function App(props) &#123; // 根据useRef设置定时器; const [count, setCount] = useState(0); // 保存定时器id const intervalRef = useRef(); useEffect(() =&gt; &#123; //开启定时器 intervalRef.current = window.setInterval(() =&gt; &#123; setCount((prevState) =&gt; prevState + 1); &#125;, 1000); return () =&gt; clearInterval(intervalRef.current); &#125;, []); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; clearInterval(intervalRef.current)&#125;&gt; 清除定时器 &lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount((prevState) =&gt; prevState + 1)&#125;&gt; &#123;count&#125;数值加1 &lt;/button&gt; &lt;/div&gt; );&#125;","tags":["React"],"categories":["React使用"]},{"title":"React 基本使用","path":"/React/react基本使用/","content":"react 使用一、react 基础01.react 基本使用1.react 概念 react 概念 React 是一个开源的 JavaScript 库，用于构建 web 应用中的视图层，既是 web 应用的前端用户页面。（一个用于构建用户界面的 javascript 库，与 2012 年由 Facebook 创建，13 年 5 月开源维护） 2.创建 react 项目指令使用 123456#全局安装react脚手架npm install create-react-app@5.0.1 -g#创建项目 名称create-react-app react-basic#进入项目根目录启动项目npm start 目录结构分析 1234567891011121314151617181920# 项目结构分析├── README.md # 项目的说明书├── package.json # npm 包说明文件、记录项目信息├── package-lock.json # 跟踪被安装的每个软件包的确切版本├── public # 本地开发服务器提供的静态资源目录│ ├── favicon.ico # 网站图标、显示在浏览器的标签栏中│ ├── index.html # 项目的 HTML 模板│ ├── logo192.png # react logo 图片 (示例代码中用于设置 IOS 移动端网站图标)│ ├── logo512.png # react logo 图片│ ├── manifest.json # web 应用清单如名称, 作者, 图标和描述 (主要用于将 Web 应用程序安装到设备的主屏幕)│ └── robots.txt # 爬虫协议文件└── src # 项目源码目录 ├── App.css # 示例程序中的根组件样式文件 ├── App.js # 示例程序中的根组件文件 ├── App.test.js # 示例程序中的根组件测试文件 ├── index.css # 示例程序中的全局样式文件 ├── index.js # 项目的入口文件 ├── logo.svg # 示例程序中根组件中显示的网站图标文件 ├── reportWebVitals.js # 测试应用程序的性能 └── setupTests.js # 项目的测试文件 3.react 初使用123456789101112#创建h1元素#参数属性-》(标记名称，标记属性，子元素...);const title = React.createElement( &quot;h1&quot;, &#123;title:&quot;hello&quot;,id:1&#125;, &quot;hello react&quot;)document.createElement(&quot;h1&quot;);#获取public文件下的index.html中的div盒子idconst root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;))#使用render方法生成template模板root.render(title); 4.JSX 概述 jsx 概念 jsx 语法是 React 提供另一种创建用户界面的方式，看起来很像 HTML,但他绝不是 HTML,他是一只 JavaScript 语法扩展。facebook 处于性能考虑，解决必须通过 React.createElement 创建元素，创建出了 jsx，在应用构建的过程中 jsx 由 babel(js 编译器)转换成 React.createElement 方法调用 代码样式 1234567891011const list = ( &lt;div className=&quot;list&quot;&gt; &lt;h2&gt;Hello React&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;hello&lt;/li&gt; &lt;li&gt;react&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;);const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(list); 5.JSX 注意事项(1)JSX 格式美化 当 jsx 中存在多个标记使用小括号（）进行包裹，使代码格式美化排列，创建元素时，元素的最外层必须要有一个根标记 1234567const jsx = ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;); (2)避免出现无意义标记，可使用幽灵标记&lt;&gt;&lt;&#x2F;&gt;(完整语法&lt;React.Fragment&gt;&lt;&#x2F;React.Fragment&gt;) 123456const jsx = ( &lt;&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;/&gt;); (3)JSX 中使用单标签必须是闭合状态 12&lt;input type=&quot;text&quot;/&gt;&lt;img src=&quot;&quot; alt=&quot;&quot;/&gt; (4)在 JSX 中标记属性使用小驼峰命名法 （由多个单词组成，第一个单词首字符小写，其他单词首字符大写） 1&lt;input maxLength=&quot;100&quot; readOnly autoFocus /&gt; (5)在 JSX 中为元素添加属性时使用 className 代替 class、htmlFor 代替 for （jsx 本质上是 javaScript） 12&lt;input type=&quot;text&quot; className=&quot;todos&quot;/&gt;&lt;label htmlFor=&quot;demo&quot;/&gt; 6.JSX 嵌入表达式含义：将表达式产生的值渲染到用户界面中。 表达式就是一个能够产生结果的式子,jsx 里面只能放表达式，非表达式不能被嵌入 JSX 插入值（{}花括号）包裹插入属性值 123//插入文本内容const name = &quot;张三&quot;;const jsx = &lt;div&gt;&#123;name&#125;&lt;/div&gt;; 123//插入属性值const activeName = &quot;active&quot;;const jsx = &lt;input type=&quot;text&quot; className=&#123;activeName&#125; /&gt;; 1234//计算const x = 10;const y = 20;const jsx = &lt;p&gt;&#123;x * y&#125;&lt;/p&gt;; 12345//渲染函数返回值function getValue() &#123; return &quot;jsx&quot;;&#125;const jsx = &lt;p&gt;&#123;getValue()&#125;&lt;/p&gt;; 123//表达式const status = true;const jsx = status ? &lt;div&gt;true&lt;/div&gt; : &lt;div&gt;false&lt;/div&gt;; 12//插入对象 内容中不能直接插入对象const jsx = &lt;p style=&#123;&#123; width: 200 &#125;&#125;&gt;&#123;&#123; name: &quot;jsx&quot; &#125;&#125;&lt;/p&gt;; 1234//注释&#123; /**/&#125; 7.条件渲染（1）使用 if 分支语句进行条件渲染 123456789const Status = fasle;function getContent() &#123; if (Status) &#123; return &lt;span&gt;true&lt;/span&gt;; &#125; else &#123; return &lt;span&gt;fasle&lt;/span&gt;; &#125;&#125;const jsx = &lt;div&gt;&#123;getContent()&#125;&lt;/div&gt;; （2）使用三元运算符进行条件渲染 12const Status = false;const jsx = Status:&lt;span&gt;true&lt;/span&gt;:&lt;span&gt;false&lt;/span&gt; (3)使用逻辑运算符进行条件渲染 123逻辑运算符 &amp;&amp;,全为真时返回真，有一个为假返回假true&amp;&amp;truefalse&amp;&amp;true","tags":["React"],"categories":["React使用"]},{"title":"React性能优化","path":"/React/react性能优化/","content":"React 组件性能优化1. memoReact.memo 可以对组件输入数据进行浅层比较(简单数据类型比较值，引用数据类型比较内存的引用地址)，如果输入数据没有变化则阻止组件更新。 2. useMemoReact.useMemo 用于在函数式组件中缓存值，避免重复操作执行影响组件运行性能。 3. useCallbackReact.useCallback 用于在函数式组件中缓存方法，避免组件每次重新渲染时都返回一个新方法。 4. useDeferredValueReact.useDeferredValue 用于获取一个延时更新的值，让 React 在空闲时去更新值；在频繁更新视图的场景下可以避免出现视图卡顿现象。 5. useTransitionReact.useTransition 用于允许开发者点赞状态渲染的优先级；可以将资源密集型任务优先级降低，等待 React 空闲时执行，避免页面出现卡顿现象。","tags":["React"],"categories":["React使用"]},{"title":"React + TypeScript - 类组件","path":"/React/react-ts-类组件/","content":"React + TypeScript - 类组件1.应用创建使用官方提供脚手架，创建指令后添加–template typescript 即可 1npm create-react-app 文件名 --template typescript 创建应用后项目中包含 jsx 代码文件后缀为.tsx，不包含 jsx 代码的文件为.ts 2.Component 泛型类标注 Props 和 States 对象的类型 123456789101112131415161718192021222324interface Props &#123; name: string;&#125;interface States &#123; count: number;&#125;//使用泛型类export default class App extends React.Components&lt;Props, States&gt; &#123; constructor(props: Readonly&lt;Props&gt;) &#123; super(props); this.state = &#123; count: 0, &#125;; &#125; render() &#123; return ( &lt;&gt; &lt;div&gt;&#123;name&#125;&lt;/div&gt; &lt;/&gt; ); &#125;&#125;//index.tsx&lt;APP name=&#123;&quot;张三&quot;&#125; /&gt;; 3.标注 React 元素类型01.React 元素含义：通过 React.createElement 方法创建的元素、通过 JSX 语法创建的元素。（虚拟 DOM 对象） 12const title = React.createElement(&quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;);const title2 = &lt;h1 className=&quot;one&quot;&gt;Hello&lt;/h1&gt;; 02.标注 React 元素类型 使用 ReactElement 和 JSX.Element 都可以标注元素的类型 1234567891011import &#123; ReactElement &#125; from &quot;react&quot;;const title: ReactElement = React.createElement( &quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;);const titl2: JSXElement = React.createElement( &quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;); 4.ReactPortal(了解)ReactPortal 表示 ReactDOM.createPortal 方法的返回值类型 123render():ReactPortal&#123; return createPortal(&lt;div&gt;&lt;/div&gt;)&#125; 5.ReactNodeReactNode 表示可渲染的任意值，包括布尔值，数字，字符串，数组等，是 React 中最泛化的类型 123456789type ReactNode = | ReactElement | string | number | ReactFragment | ReactPortal | boolean | null | undefined; 6.ReactFragmentReactFragment 表示一组可以被遍历渲染的任意值，只用于标注组件 children 属性的类型。 123456789//type ReactFragment = Interble&lt;ReactNode&gt;interface Props &#123; children: ReactFragment;&#125;&lt;App&gt; &#123;/* 不能只有一个, 只能多个 */&#125; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/App&gt;; 7.CSSPropertiesCSSProperties 用于标注 styles 属性值的类型，对样式值对象的属性及属性值的类型进行约束。 1234interface Props &#123; style?: React.CSSProperties;&#125;&lt;div style=&#123;this.props.style&#125;&gt;&lt;/div&gt;; 8.标注事件对象的类型MouseEvent 用于标注鼠标事件对应的事件对象的类型。onClickHandler KeyboardEvent 用于标注键盘事件对应的事件对象的类型。onKeyUpHandler FormEvent 用于标注表单提交事件对应的事件对象的类型。onSubmitHandler UIEvent 通用的和用户界面相关的事件的事件对象类型，一般我们使用 UIEvent 标注滚动事件的事件对象类型、加载事件的事件对象类型等。onScrollHandler 123function on事件名(event:React.标注事件类型&lt;HTML事件Element&gt;)&#123;&#125;//等价写法const on事件名:React.标注事件类型Handler&lt;HTML事件Element&gt;=(event)=》&#123;&#125; 9.DefaultPropsdefaultProps 中添加属性之后，该属性变为可选，在调用当前组件时不传递该属性也可以通过 ts 的编译 123456789101112131415interface Props&#123; name:string; age:number;&#125;export default class App extends React.Component&lt;Props&gt;&#123; static defaultProps:Pick&lt;Props&gt; = &#123; name:&quot;默认&quot; &#125;; render() &#123; return &lt;div&gt;APP&lt;/div&gt;; &#125;&#125;//index.tsx&lt;App /&gt;&lt;App greetings=&#123;&quot;Hello world&quot;&#125; age=&#123;20&#125; /&gt;","tags":["React"],"categories":["React使用"]},{"path":"/about/index.html","content":"联系方式 手机：156****9428 Email：331****&#x33;&#50;&#48;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#109; QQ&#x2F;微信号：331***320&#x2F;A331****420 个人信息 国朋&#x2F;男&#x2F;2001 本科&#x2F;上海开发大学 工作年限：3 年 技术博客：http://mistbollon.github.io Github：http://github.com/mistbollon 期望职位：Web 前端程序员 期望薪资：税前月薪 15k~20k，特别喜欢的公司可例外 期望城市：北京 工作经历（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组） ABC 公司 （ 2012 年 9 月 ~ 2014 年 9 月 ）DEF 项目我在此项目负责了哪些工作，分别在哪些地方做得出色&#x2F;和别人不一样&#x2F;成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写 2~3 个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） 开源项目和作品开源项目 STU：项目的简要说明，Star 和 Fork 数多的可以注明 WXYZ：项目的简要说明，Star 和 Fork 数多的可以注明 技能清单 Web 开发：PHP&#x2F;Hack&#x2F;Node Web 框架：ThinkPHP&#x2F;Yaf&#x2F;Yii&#x2F;Lavaral&#x2F;LazyPHP 前端框架：Bootstrap&#x2F;AngularJS&#x2F;EmberJS&#x2F;HTML5&#x2F;Cocos2dJS&#x2F;ionic 前端工具：Bower&#x2F;Gulp&#x2F;SaSS&#x2F;LeSS&#x2F;PhoneGap 数据库相关：MySQL&#x2F;PgSQL&#x2F;PDO&#x2F;SQLite 版本管理、文档和自动化部署工具：Svn&#x2F;Git&#x2F;PHPDoc&#x2F;Phing&#x2F;Composer 单元测试：PHPUnit&#x2F;SimpleTest&#x2F;Qunit 云和开放平台：SAE&#x2F;BAE&#x2F;AWS&#x2F;微博开放平台&#x2F;微信应用开发 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"这是分页标题","path":"/wiki/conduit/07-综合案例-conduit.html","content":"综合案例 - conduit"}]