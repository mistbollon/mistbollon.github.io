[{"path":"/React/react函数组件/","content":"一、函数组件函数组件是一个返回视图(JSX)的函数。 1.创建函数组件123function App() &#123; return &lt;div&gt;APP&lt;/div&gt;;&#125; 2.函数组件使用方法01.useState 声明组件状态​ 在 React 函数组件中可以通过 useState 方法创建组件状态，可以被调用多次声明多个状态。 123456789101112131415161718//useState方法返回值是一个数组，第一个参数是状态变量，第二个参数是修改/更新状态的方法。function App() &#123; const [value, setValue] = useState(&quot;状态初始值&quot;); const [count, seCount] = useState(0); retutn( &lt;&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;p&gt;&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setValue(&quot;修改的值&quot;)&#125;&gt;更改状态&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setVlaue(count + 1)&#125;&gt;更改数值+1&lt;/button&gt; //更新状态方法可以接收函数作为参数，通过参数函数返回值指定新状态值 //prevState表示更新前状态 //参数函数返回值表示更新后状态 &lt;button onClick=&#123;() =&gt; setCount((prevState) =&gt; prevState - 1)&#125;&gt; 更新数值-1 &lt;/button&gt; &lt;/&gt; );&#125; ​ 当多次调用修改状态的方法时，当传递状态值，最后面的状态会覆盖前面状态；当传递函数，顺序执行，所有函数执行完毕才会更新。 123456789101112131415161718192021222324//传递状态值，最后结果为count+2&lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setCount(count + 1); setCount(count + 1); setCount(count + 2); &#125; &#125; &gt; &#123;count&#125; &lt;/button&gt;//传递函数方法，顺序执行+1+1+1+1返回最终相加结果&lt;button onClick=&#123;() =&gt; &#123; setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); &#125; &#125; &gt; &#123;count&#125; &lt;/button&gt; 02.useEffect 确保函数式组件正确执行副作用代码​ 在 React 中，副作用指与组件渲染无关的操作，如获取数据、修改全局变量、更新 DOM 等。这些操作可能会影响组件渲染结果，但不能被纯函数捕获，因此需 useEffect 进行特殊处理，确保代码在正确时机执行。 ​ useEffect 接收一个回调函数和一个依赖数组作为参数，回调函数的代码会在组件渲染完成后执行，依赖数组的变量会在其发生变化时触发回调函数重新执行。 1234const [参数变量, 修改方法代码] = useState(&quot;&quot;);useEffect(() =&gt; &#123; //回调函数代码&#125;, [&quot;参数变量&quot;]); 03.useRef 获取 DOM 对象​ 通过 useRef 方法可以在函数式组件中获取 DOM 对象 1234function App()&#123; const name = useRef(); return &lt;input ref=&#123;name&#125; onChange=&#123;()=&gt;consloe.lgo(name.current)&#125;/&gt;&#125; 04.forwardRef 获取子组件 DOM 对象​ 通过 useRef 和 forward 高阶函数配合使用可以实现父子组件之间传递 ref 对象。 12345678910//appfunction App() &#123; const appref = useRef(); return &lt;Message ref=&#123;appref&#125; /&gt;;&#125;//messagefunction Message(props, ref) &#123; return &lt;span ref=&#123;ref&#125;&gt;message&lt;/span&gt;;&#125;export default forwardRef(Message); 05.受控组件和非受控组件受控表单组件 ​ 表单状态由 React 组件状态控制 12345678910111213141516171819202122232425function App() &#123; const [formState, setFormState] = useState(&#123; username: &quot;&quot;, password: &quot;&quot; &#125;); const onChangeHandler = (event) =&gt; &#123; setFormState(&#123; ...formState, [event.target.name]: event.target.value, &#125;); &#125;; return ( &lt;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&#123;formState.username&#125; onChange=&#123;onChangeHandler&#125; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&#123;formState.password&#125; onChange=&#123;onChangeHandler&#125; /&gt; &lt;/&gt; );&#125; 非受控表单组件 ​ 通过 DOM 获取&#x2F;修改值，使用 useRef 实现非受控表单组件 12345678910111213function App() &#123; const usernameRef = useRef(); const onSubmijs = (event) =&gt; &#123; event.preventDefault(); console.log(usernameRef.current.value); &#125;; return ( &lt;form onSubmit=&#123;onSubmijs&#125;&gt; &lt;input type=&quot;text&quot; ref=&#123;usernameRef&#125; /&gt; &lt;button&gt;button&lt;/button&gt; &lt;/form&gt; );&#125; 06.父子组件通信 - Props1.父组件传递状态到子组件，子组件修改父组件传递的状态值。 1234567891011//父组件function App() &#123; const [msg, setMsg] = useState(&quot;hello&quot;); //传递给子组件 return &lt;Message msg=&#123;mgs&#125; setMsg=&#123;setMsg&#125;&gt;&lt;/Message&gt;;&#125;//子组件function Message(props) &#123; //接收父组件传递的数据 return &lt;button onClick=&#123;() =&gt; props.setMsg(&quot;你好&quot;)&#125;&gt;&#123;props.msg&#125;&lt;/button&gt;;&#125; 2.设置 Props 对象默认值方式 123456789101112131415161718192021222324252627function App(props) &#123; return ( &lt;div&gt; &lt;Message name=&#123;&quot;张三&quot;&#125; age=&#123;30&#125; /&gt; &lt;/div&gt; );&#125;function Message(&#123; name = &quot;李四&quot;, age = 20 &#125;) &#123; return ( &lt;div&gt; &#123;name&#125; &#123;age&#125; &lt;/div&gt; );&#125;export default App;-------------------------function App()&#123; return &lt;Message/&gt;;&#125;function Message(&#123;name,age&#125;)&#123; return &lt;div&gt;&#123;name&#125;&#123;age&#125;&lt;/div&gt;&#125;Message.defaultProps=&#123; name:&quot;张三&quot;, age:20&#125; 07.父子组件通信-useImperativeHandle​ useImperativeHandle 允许父组件直接调用子组件暴露的成员属性和方法。 12345678910111213141516//App.jsfunction App() &#123; const msgRef = useRef(); return ( &lt;&gt; &lt;Message ref=&#123;msgRef&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; console.log(msgRef.current.value); &#125;&#125; &gt; getMsg &lt;/button&gt; &lt;/&gt; );&#125; 12345678910111213//Messagefunction Message(props, ref) &#123; const [value, setValue] = useState(&quot;&quot;); //useImperativeHandle用于设置ref对象中current属性的值，(参数传递ref对象，传递函数(函数返回什么ref对象的current属性值就是什么，组件每次重新渲染时执行)，数组(传递依赖状态)) useImperativeHandle(ref, () =&gt; (&#123; vlaue &#125;), [value]); return ( &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;(event) =&gt; setValue(event.target.value)&#125; /&gt; );&#125; 08.跨级组件通讯-useContext在组件中创建导出的对象，另一个组件中通过 useContext 方法就那些获取。 12345//创建上下文对象export const PersonContext = createContext(&#123; name: &quot;张三&quot;, age: 20 &#125;);//获取上下文状态const person = useContext(PersonContext); 09.组件状态逻辑分离-useReduceruseReducer 是 React 提供的另一种在函数式组件中声明状态的方式。将组件状态逻辑和组件渲染逻辑进行分离，使代码更加清晰可维护。useReducer 是 useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。 1234567891011121314151617function App()&#123; const [state,dispatch] = useReducer(counterReducer,&#123;count:0&#125;); return &lt;button onClick=&#123;()=&gt;dispatch(&#123;type:&quot;counter/increent&quot;&#125;)&#125;&gt;&#123;state.count&#125;&lt;/button&gt;&#125;-----------------------// src/counterReducer.jsexport default function counterReducer(state, action) &#123; switch (action.type) &#123; case &quot;counter/increment&quot;: return &#123; ...state, count: state.count + 1, &#125;; default: return state; &#125;&#125; 10.保存组件值-useRefuseRef 可以获取 DOM 元素，保存普通值；使用 useRef 保存的普通值并不会随组件更新而销毁，修改通过 useRef 保存的值也不会触发组件更新。 例：组件初次渲染开启定时器，点击按钮进行清空。 1234567891011121314151617181920212223function App(props) &#123; // 根据useRef设置定时器; const [count, setCount] = useState(0); // 保存定时器id const intervalRef = useRef(); useEffect(() =&gt; &#123; //开启定时器 intervalRef.current = window.setInterval(() =&gt; &#123; setCount((prevState) =&gt; prevState + 1); &#125;, 1000); return () =&gt; clearInterval(intervalRef.current); &#125;, []); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; clearInterval(intervalRef.current)&#125;&gt; 清除定时器 &lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount((prevState) =&gt; prevState + 1)&#125;&gt; &#123;count&#125;数值加1 &lt;/button&gt; &lt;/div&gt; );&#125;","tags":["React"],"categories":["React使用"]},{"title":"React 基本使用","path":"/React/react基本使用/","content":"react 使用一、react 基础01.react 基本使用1.react 概念 react 概念 React 是一个开源的 JavaScript 库，用于构建 web 应用中的视图层，既是 web 应用的前端用户页面。（一个用于构建用户界面的 javascript 库，与 2012 年由 Facebook 创建，13 年 5 月开源维护） 2.创建 react 项目指令使用 123456#全局安装react脚手架npm install create-react-app@5.0.1 -g#创建项目 名称create-react-app react-basic#进入项目根目录启动项目npm start 目录结构分析 1234567891011121314151617181920# 项目结构分析├── README.md # 项目的说明书├── package.json # npm 包说明文件、记录项目信息├── package-lock.json # 跟踪被安装的每个软件包的确切版本├── public # 本地开发服务器提供的静态资源目录│ ├── favicon.ico # 网站图标、显示在浏览器的标签栏中│ ├── index.html # 项目的 HTML 模板│ ├── logo192.png # react logo 图片 (示例代码中用于设置 IOS 移动端网站图标)│ ├── logo512.png # react logo 图片│ ├── manifest.json # web 应用清单如名称, 作者, 图标和描述 (主要用于将 Web 应用程序安装到设备的主屏幕)│ └── robots.txt # 爬虫协议文件└── src # 项目源码目录 ├── App.css # 示例程序中的根组件样式文件 ├── App.js # 示例程序中的根组件文件 ├── App.test.js # 示例程序中的根组件测试文件 ├── index.css # 示例程序中的全局样式文件 ├── index.js # 项目的入口文件 ├── logo.svg # 示例程序中根组件中显示的网站图标文件 ├── reportWebVitals.js # 测试应用程序的性能 └── setupTests.js # 项目的测试文件 3.react 初使用123456789101112#创建h1元素#参数属性-》(标记名称，标记属性，子元素...);const title = React.createElement( &quot;h1&quot;, &#123;title:&quot;hello&quot;,id:1&#125;, &quot;hello react&quot;)document.createElement(&quot;h1&quot;);#获取public文件下的index.html中的div盒子idconst root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;))#使用render方法生成template模板root.render(title); 4.JSX 概述 jsx 概念 jsx 语法是 React 提供另一种创建用户界面的方式，看起来很像 HTML,但他绝不是 HTML,他是一只 JavaScript 语法扩展。facebook 处于性能考虑，解决必须通过 React.createElement 创建元素，创建出了 jsx，在应用构建的过程中 jsx 由 babel(js 编译器)转换成 React.createElement 方法调用 代码样式 1234567891011const list = ( &lt;div className=&quot;list&quot;&gt; &lt;h2&gt;Hello React&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;hello&lt;/li&gt; &lt;li&gt;react&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;);const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(list); 5.JSX 注意事项(1)JSX 格式美化 当 jsx 中存在多个标记使用小括号（）进行包裹，使代码格式美化排列，创建元素时，元素的最外层必须要有一个根标记 1234567const jsx = ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;); (2)避免出现无意义标记，可使用幽灵标记&lt;&gt;&lt;&#x2F;&gt;(完整语法&lt;React.Fragment&gt;&lt;&#x2F;React.Fragment&gt;) 123456const jsx = ( &lt;&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;/&gt;); (3)JSX 中使用单标签必须是闭合状态 12&lt;input type=&quot;text&quot;/&gt;&lt;img src=&quot;&quot; alt=&quot;&quot;/&gt; (4)在 JSX 中标记属性使用小驼峰命名法 （由多个单词组成，第一个单词首字符小写，其他单词首字符大写） 1&lt;input maxLength=&quot;100&quot; readOnly autoFocus /&gt; (5)在 JSX 中为元素添加属性时使用 className 代替 class、htmlFor 代替 for （jsx 本质上是 javaScript） 12&lt;input type=&quot;text&quot; className=&quot;todos&quot;/&gt;&lt;label htmlFor=&quot;demo&quot;/&gt; 6.JSX 嵌入表达式含义：将表达式产生的值渲染到用户界面中。 表达式就是一个能够产生结果的式子,jsx 里面只能放表达式，非表达式不能被嵌入 JSX 插入值（{}花括号）包裹插入属性值 123//插入文本内容const name = &quot;张三&quot;;const jsx = &lt;div&gt;&#123;name&#125;&lt;/div&gt;; 123//插入属性值const activeName = &quot;active&quot;;const jsx = &lt;input type=&quot;text&quot; className=&#123;activeName&#125; /&gt;; 1234//计算const x = 10;const y = 20;const jsx = &lt;p&gt;&#123;x * y&#125;&lt;/p&gt;; 12345//渲染函数返回值function getValue() &#123; return &quot;jsx&quot;;&#125;const jsx = &lt;p&gt;&#123;getValue()&#125;&lt;/p&gt;; 123//表达式const status = true;const jsx = status ? &lt;div&gt;true&lt;/div&gt; : &lt;div&gt;false&lt;/div&gt;; 12//插入对象 内容中不能直接插入对象const jsx = &lt;p style=&#123;&#123; width: 200 &#125;&#125;&gt;&#123;&#123; name: &quot;jsx&quot; &#125;&#125;&lt;/p&gt;; 1234//注释&#123; /**/&#125; 7.条件渲染（1）使用 if 分支语句进行条件渲染 123456789const Status = fasle;function getContent() &#123; if (Status) &#123; return &lt;span&gt;true&lt;/span&gt;; &#125; else &#123; return &lt;span&gt;fasle&lt;/span&gt;; &#125;&#125;const jsx = &lt;div&gt;&#123;getContent()&#125;&lt;/div&gt;; （2）使用三元运算符进行条件渲染 12const Status = false;const jsx = Status:&lt;span&gt;true&lt;/span&gt;:&lt;span&gt;false&lt;/span&gt; (3)使用逻辑运算符进行条件渲染 123逻辑运算符 &amp;&amp;,全为真时返回真，有一个为假返回假true&amp;&amp;truefalse&amp;&amp;true","tags":["React"],"categories":["React使用"]},{"title":"React性能优化","path":"/React/react性能优化/","content":"React 组件性能优化1. memoReact.memo 可以对组件输入数据进行浅层比较(简单数据类型比较值，引用数据类型比较内存的引用地址)，如果输入数据没有变化则阻止组件更新。 2. useMemoReact.useMemo 用于在函数式组件中缓存值，避免重复操作执行影响组件运行性能。 3. useCallbackReact.useCallback 用于在函数式组件中缓存方法，避免组件每次重新渲染时都返回一个新方法。 4. useDeferredValueReact.useDeferredValue 用于获取一个延时更新的值，让 React 在空闲时去更新值；在频繁更新视图的场景下可以避免出现视图卡顿现象。 5. useTransitionReact.useTransition 用于允许开发者点赞状态渲染的优先级；可以将资源密集型任务优先级降低，等待 React 空闲时执行，避免页面出现卡顿现象。","tags":["React"],"categories":["React使用"]},{"title":"React + TypeScript - 类组件","path":"/React/react-ts-类组件/","content":"React + TypeScript - 类组件1.应用创建使用官方提供脚手架，创建指令后添加–template typescript 即可 1npm create-react-app 文件名 --template typescript 创建应用后项目中包含 jsx 代码文件后缀为.tsx，不包含 jsx 代码的文件为.ts 2.Component 泛型类标注 Props 和 States 对象的类型 123456789101112131415161718192021222324interface Props &#123; name: string;&#125;interface States &#123; count: number;&#125;//使用泛型类export default class App extends React.Components&lt;Props, States&gt; &#123; constructor(props: Readonly&lt;Props&gt;) &#123; super(props); this.state = &#123; count: 0, &#125;; &#125; render() &#123; return ( &lt;&gt; &lt;div&gt;&#123;name&#125;&lt;/div&gt; &lt;/&gt; ); &#125;&#125;//index.tsx&lt;APP name=&#123;&quot;张三&quot;&#125; /&gt;; 3.标注 React 元素类型01.React 元素含义：通过 React.createElement 方法创建的元素、通过 JSX 语法创建的元素。（虚拟 DOM 对象） 12const title = React.createElement(&quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;);const title2 = &lt;h1 className=&quot;one&quot;&gt;Hello&lt;/h1&gt;; 02.标注 React 元素类型 使用 ReactElement 和 JSX.Element 都可以标注元素的类型 1234567891011import &#123; ReactElement &#125; from &quot;react&quot;;const title: ReactElement = React.createElement( &quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;);const titl2: JSXElement = React.createElement( &quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;); 4.ReactPortal(了解)ReactPortal 表示 ReactDOM.createPortal 方法的返回值类型 123render():ReactPortal&#123; return createPortal(&lt;div&gt;&lt;/div&gt;)&#125; 5.ReactNodeReactNode 表示可渲染的任意值，包括布尔值，数字，字符串，数组等，是 React 中最泛化的类型 123456789type ReactNode = | ReactElement | string | number | ReactFragment | ReactPortal | boolean | null | undefined; 6.ReactFragmentReactFragment 表示一组可以被遍历渲染的任意值，只用于标注组件 children 属性的类型。 123456789//type ReactFragment = Interble&lt;ReactNode&gt;interface Props &#123; children: ReactFragment;&#125;&lt;App&gt; &#123;/* 不能只有一个, 只能多个 */&#125; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/App&gt;; 7.CSSPropertiesCSSProperties 用于标注 styles 属性值的类型，对样式值对象的属性及属性值的类型进行约束。 1234interface Props &#123; style?: React.CSSProperties;&#125;&lt;div style=&#123;this.props.style&#125;&gt;&lt;/div&gt;; 8.标注事件对象的类型MouseEvent 用于标注鼠标事件对应的事件对象的类型。onClickHandler KeyboardEvent 用于标注键盘事件对应的事件对象的类型。onKeyUpHandler FormEvent 用于标注表单提交事件对应的事件对象的类型。onSubmitHandler UIEvent 通用的和用户界面相关的事件的事件对象类型，一般我们使用 UIEvent 标注滚动事件的事件对象类型、加载事件的事件对象类型等。onScrollHandler 123function on事件名(event:React.标注事件类型&lt;HTML事件Element&gt;)&#123;&#125;//等价写法const on事件名:React.标注事件类型Handler&lt;HTML事件Element&gt;=(event)=》&#123;&#125; 9.DefaultPropsdefaultProps 中添加属性之后，该属性变为可选，在调用当前组件时不传递该属性也可以通过 ts 的编译 123456789101112131415interface Props&#123; name:string; age:number;&#125;export default class App extends React.Component&lt;Props&gt;&#123; static defaultProps:Pick&lt;Props&gt; = &#123; name:&quot;默认&quot; &#125;; render() &#123; return &lt;div&gt;APP&lt;/div&gt;; &#125;&#125;//index.tsx&lt;App /&gt;&lt;App greetings=&#123;&quot;Hello world&quot;&#125; age=&#123;20&#125; /&gt;","tags":["React"],"categories":["React使用"]},{"path":"/about/index.html","content":"水畔驰车，看斜阳在水上破散出的闪烁的金光，晚风吹来，春衫嫌薄文章项目关于GitHub"}]