[{"title":"CSS面试题","path":"/面试题/CSS面试题/","content":"CSS 高频面试题01. 盒模型宽度计算在如下代码中类名为 box 的 div，它的 offsetWidth 是多少? 123456789101112&lt;style&gt; #box &#123; width: 100px; padding: 10px; border: 1px solid skyblue; margin: 10px; &#125;&lt;/style&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt; console.log(document.getElementById(&quot;box&quot;).offsetWidth);&lt;/script&gt; offsetWidth &#x3D; 内容宽度 + 内边距 + 边框 box 的内容宽度为 100、左右内边距各为 10、左右边框各为 1、所以盒子的 offsetWidth 为 122。 通过 box-sizing 可以设置到底要如何计算一个元素的总宽度和总高度。 它的默认值为 content-box，即指定 width 属性值为内容宽度，盒子的实际宽度为内容宽度 + 内边距 + 边框。 它的值也可以是 border-box，即指定 width 属性值为盒子的总宽度，在设置了内边距和边框的情况下会挤压盒子内容的宽度。 02. 外边距负值外边距在四个方向上设置负值会产生什么效果。 margin-top 设置正值元素向下移动、设置负值向上移动。 margin-left 设置正值元素向右移动、设置负值向左移动。 margin-right 设置正值右侧元素向左移动、设置负值右侧元素向右移动。 margin-bottom 设置正值下方元素向上移动，设置负值下方元素向下移动。 1234567891011121314&lt;style&gt; .box1 &#123; width: 100px; height: 100px; background: skyblue; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; &#125;&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; 03. 外边距重叠① 什么是外边距重叠 两个块级元素的上外边距和下外边距可能会合并为一个外边距，这种现象被称之为外边距重叠。 外边距重叠只发生在垂直方向，水平方向不会重叠。浮动的元素和绝对定位的元素的外边距不会折叠。 ② 外边距重叠的计算方式 (1) 如果两者都是正数，取最大值为最终的外边距值。 12345678910111213141516&lt;style&gt; .box1 &#123; width: 100px; height: 100px; background: skyblue; margin-bottom: 20px; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; margin-top: 30px; &#125;&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; (2) 如果两者一正一负，使用正值减去负值的绝对值，得到的结果为最终的外边距值。 12345678910111213141516&lt;style&gt; .box1 &#123; width: 100px; height: 100px; background: skyblue; margin-bottom: 20px; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; margin-top: -10px; &#125;&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; (3) 如果两者都是负值，使用 0 减去两个中值中绝对值大的那个，得到的结果为最终的外边距值 1234567891011121314&lt;style&gt; .box1 &#123; width: 100px; height: 100px; background: skyblue; margin-bottom: -20px; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; margin-top: -10px; &#125;&lt;/style&gt; ③ 如何解决外边距重叠 (1) 不要同时为两个相邻的块级元素同时设置垂直方向上的边距(推荐) (2) 为下层元素设置浮动或定位(绝对定位、固定定位)或 inline-block 04. 外边距塌陷① 什么是外边距塌陷 两个嵌套关系的(一般为父子关系)块元素，当父元素有上外边距子元素也有上外边距时，两个上外边距会合成一个上外边距。 12345678910111213141516171819&lt;style&gt; body &#123; margin: 0; &#125; .box1 &#123; width: 100px; background: skyblue; margin-top: 10px; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; margin-top: 10px; &#125;&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt; ② 如何解决外边距塌陷 (1) 为父元素设置 overflow: auto&#x2F;hidden (2) 为父元素设置浮动 (3) 为父元素设置 display: inline-block (4) 为父元素设置 border: 1px solid transparent (5) 为父元素设置 padding: 1px 05. 清除浮动子元素浮动后父元素高度撑不开的问题如何解决 12345678910111213141516&lt;style&gt; .parent &#123; width: 100%; background: skyblue; &#125; .item &#123; width: 200px; height: 100px; background: purple; float: left; &#125;&lt;/style&gt;&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt; ① 为父级元素添加 overflow: hidden 或 overflow: auto 123.parent &#123; overflow: hidden;&#125; ② 通过伪类元素解决浮动父级元素高度问题 1234567.clearfix::after &#123; content: &quot; &quot;; visibility: hidden; display: block; height: 0; clear: both;&#125; 1&lt;div class=&quot;parent clearfix&quot;&gt;&lt;/div&gt; 06. 理解 BFC① 什么是 BFC BFC 全称 Block Formatting Context， 意为块级格式化上下文。 BFC 其实就是指一块能够独立渲染的区域，并对这块区域内部的块级元素如何布局进行了规定。 比如块级元素默认在盒子的左上角进行渲染、块级盒子独占一行垂直排列、块级盒子之间的间距由 margin 设置。 由于通过 BFC 产生了一块独立渲染的区域，所以该区域内的元素无论怎样布局都不会影响到区域以外的元素。 只有块级元素可以具备 BFC 特性。 通过理解和 BFC 相关的知识能够对布局过程中产生问题进行快速解决，比如外边距重叠、外边距塌陷、浮动父级高度无法撑开等问题。 ② 如何使元素具有 BFC 特性 (1) 根元素(HTML) (2) 浮动之后的元素(float 属性的值不为 none) (3) 绝对定位和固定定位之后的元素 (4) 行内块元素 (5) 表格单元格(display: table-cell)、表格标题(display: table-caption) (6) overflow 属性值不为 visible 的块元素 (7) 弹性盒元素(display: flex) (8) 网格元素 (display: grid) ③ BFC 特性 在同一个 BFC 中相邻的两个块级元素垂直方向上的外边距会被折叠 BFC 盒子的不会与浮动盒子产生交集而是紧贴着浮动元素的边缘 计算 BFC 盒子的高度时也会检测浮动盒子的高度 07. 圣杯布局① 什么是圣杯布局 圣杯布局是指三栏布局，左右两栏宽度固定、中间宽度自适应。 在圣杯布局中要求中间一栏最先加载出来。 ② 实现圣杯布局 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; body &#123; margin: 0; &#125; .container &#123; padding: 0 150px 0 200px; &#125; .column &#123; float: left; &#125; .left &#123; width: 200px; background: skyblue; margin-left: -100%; position: relative; left: -200px; &#125; .center &#123; width: 100%; background: purple; &#125; .right &#123; width: 150px; background: palegreen; margin-left: -150px; position: relative; left: 150px; &#125; .clearfix::after &#123; content: &quot; &quot;; visibility: hidden; display: block; height: 0; clear: both; &#125;&lt;/style&gt;&lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;center column&quot;&gt;center&lt;/div&gt; &lt;div class=&quot;left column&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right column&quot;&gt;right&lt;/div&gt;&lt;/div&gt; 08. 双飞翼布局① 什么是双飞翼布局 双飞翼布局和圣杯布局一样都是要实现三栏布局，两侧栏宽度固定，中间栏宽度自适应。 ② 实现双飞翼布局 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; body &#123; margin: 0; &#125; .main-wrap &#123; width: 100%; background: purple; &#125; .main &#123; margin: 0 150px 0 200px; &#125; .column &#123; float: left; &#125; .left &#123; width: 200px; background: skyblue; margin-left: -100%; &#125; .center &#123; width: 100%; &#125; .right &#123; width: 150px; background: palegreen; margin-left: -150px; &#125; .clearfix::after &#123; content: &quot; &quot;; visibility: hidden; display: block; height: 0; clear: both; &#125;&lt;/style&gt;&lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;main-wrap column&quot;&gt; &lt;div class=&quot;main&quot;&gt;center&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left column&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right column&quot;&gt;right&lt;/div&gt;&lt;/div&gt; 09. 弹性盒布局1234567891011121314151617181920212223242526&lt;style&gt; .container &#123; width: 1200px; height: 500px; border: 2px solid #000; &#125; .item &#123; width: 200px; height: 100px; &#125; .item_1 &#123; background: skyblue; &#125; .item_2 &#123; background: purple; &#125; .item_3 &#123; background: orangered; &#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item item_1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item item_2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item item_3&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456789.container &#123; /* 通过 display: flex 将 container 设置为弹性容器 container 的直接一级子元素自动成为弹性盒子 弹性盒子默认按照主轴方向进行排列, 而主轴方向默认又是水平的, 从左到右 所以当 container 被设置为弹性容器以后, 弹性盒子自动在水平方向上从左到右排列 */ display: flex;&#125; 123456789101112.container &#123; /* 通过 justify-content 可以设置弹性盒子在主轴方向上的对应方式 flex-start: 左对齐 flex-end: 右对齐 center: 居中对齐 space-between: 盒子与盒子之间平均分配空间(不包含第一个盒子的左边和最后一个盒子的右边) space-evenly: 在盒子与盒子之间凭据分配间距(包含第一个盒子的左边和最后一个盒子的右边) space-around: 在盒子的两边凭据分配间距 */ justify-content: space-around;&#125; 123456789.container &#123; /* 通过 align-items 可以设置弹性盒子在侧轴方向上的对齐方式 flex-start: 顶对齐 flex-end: 底对齐 center: 垂直居中对齐 */ align-items: center;&#125; 1234567.container &#123; align-items: center;&#125;.item_3 &#123; /* 通过 align-self 属性可以单独设置某一个弹性盒子的侧轴方向上的对齐方式 */ align-self: flex-end;&#125; 123456789.container &#123; /* 设置弹性盒子在主轴方向上左对齐 */ justify-content: flex-start;&#125;.item_3 &#123; /* 通过 margin auto 可以单独设置某一个弹性盒子在主轴方向上位置 */ /* 将第三个盒子推向最右侧 */ margin-left: auto;&#125; 1234.item_2 &#123; /* 当父级有剩余空间时, 通过扩展当前元素的宽度占据所有剩余空间 */ flex-grow: 1;&#125; 12345678910/* 将父级剩余空间划分为4分, 通过扩展弹性盒子占据剩余空间, item_1, item_3 占四分之一, item_2 占四分之二*/.item_1 &#123; flex-grow: 1;&#125;.item_2 &#123; flex-grow: 2;&#125;.item_3 &#123; flex-grow: 1;&#125; 123456789.container &#123; width: 1200px;&#125;.item &#123; width: 500px;&#125;/* 当父级宽度不足以放置所有弹性盒子时, 所有弹性盒子的宽度默认会被缩减, 直到父级可以放置所有弹性盒子*/ 1234567.item_1 &#123; /* 通过 flex-shrink 属性可以改变盒子缩减行为, 它的默认值为1, 即每个盒子的缩减比例一致 可以将 flex-shrink 属性的值设置为 0, 表示不缩减当前盒子, 增加其他盒子的缩减比例 */ flex-shrink: 0;&#125; 1234.item &#123; width: 500px; flex-shrink: 0;&#125; 1234.container &#123; /* 当弹性容器的宽度不够时, 可以通过设置 flex-wrap: wrap 让弹性盒子换行显示 */ flex-wrap: wrap;&#125; 1234.container &#123; /* 通过 align-content 属性可以设置弹性盒子的行对齐方式 */ align-content: flex-start;&#125; 12345678910/* 通过 order 属性可以调整元素的显示顺序 */.item_1 &#123; order: 3;&#125;.item_2 &#123; order: 1;&#125;.item_3 &#123; order: 2;&#125; 12345678910111213.container &#123; /* 通过设置 flex-direction 属性可以调整主轴方向, 默认值为 row, 即主轴方向为水平, 盒子从左到右排列 flex-direction: column 设置主轴方向为垂直, 盒子从上到下排列 flex-direction: column-reverse 设置主轴方向为垂直, 盒子从下到上排列 flex-direction: row-reverse 设置主轴方向为水平, 盒子从右到左排列 */ flex-direction: column; /* 设置盒子在主轴方向居中对齐 (垂直) */ justify-content: center; /* 设置盒子在侧轴方向居中对齐 (水平) */ align-items: center;&#125; 10. 定位12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;style&gt; /* 定位是指确定元素的位置 元素位置的调整可以有不同的参数对象 可以参数自身, 可以参考有定位的父级, 可以参数浏览器窗口 css 中可以通过 position 属性来确认元素位置调整时的参数对象 */ /* 静态定位 position: static; 元素在不设置定位时, 元素的 position 属性值就是 static 一般在使用它时都是在取消该元素的其他定位特性. */ /* 相对定位 position: relative 相对定位的元素是相对于元素自身在文档流中原本的位置进行定位 采用相对定位的元素没有脱离文档流, 所以当相对定位的元素被调整位置时, 原有位置会被保留, 不会影响文档流中的其他元素的位置 一般在进行网页布局时, 极少改变相对定位元素的位置 极大多数情况下, 相对定位的元素都是为绝对定位的元素提供位置参考 */ /* 绝对定位 position: absolute 绝对定位的元素参考它最近的有定位的父级元素进行定位, 该定位可以是 sticky relative absolute fixed 若没有定位父级, 则参考窗口元素的位置进行定位 设置了绝对定位的元素会脱离正常的文档流, 元素原有位置将会被其他元素占据，可以使用绝对定位实现盒子堆叠效果 */ /* 固定定位 position: fixed; 设置了固定定位的元素, 它的位置参考浏览器窗口, 在页面内容滚动时, 它的位置不会改变。 设置了固定定位的元素会脱离文档流, 原有位置将会被其他元素占据。 */ /* 黏性定位 position: sticky 相对于父级进行固定定位, 当父级元素出现在窗口中并进行滚动时, 粘性定位的元素出现 fixed 定位效果 当父级元素离开窗口后, 粘性定位随父级元素离开窗口 注意父级元素不需要设置任何定位 */ .outer &#123; width: 800px; height: 2000px; background-color: #ccc; &#125; .inner &#123; width: 200px; height: 100px; background-color: skyblue; position: sticky; top: 100px; left: 0; &#125; .box &#123; width: 800px; height: 2000px; background-color: purple; &#125;&lt;/style&gt;&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;!-- 问题：两个元素, 一个固定定位, 一个绝对定位, 它们两个都相对于窗口定位, 它们有什么区别。 --&gt; 11. 盒子水平垂直居中1&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 1234567891011/* 知道元素宽高的情况下 */.box &#123; width: 100px; height: 100px; background: skyblue; position: absolute; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px;&#125; 12345678910/* 不知道元素宽高的情况下 */.box &#123; width: 100px; height: 100px; background: skyblue; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);&#125; 123456789101112/* 知道元素宽高的情况下 */.box &#123; width: 100px; height: 100px; background: skyblue; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto;&#125; 123456789101112131415161718&lt;style&gt; .wrap &#123; width: 100%; height: 500px; border: 2px solid skyblue; display: flex; justify-content: center; align-items: center; &#125; .box &#123; width: 100px; height: 100px; background: skyblue; &#125;&lt;/style&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819&lt;style&gt; .wrap &#123; width: 800px; height: 500px; border: 2px solid skyblue; display: table-cell; text-align: center; vertical-align: middle; &#125; .box &#123; width: 100px; height: 100px; display: inline-block; background: skyblue; &#125;&lt;/style&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12. 多行文本垂直居中12345678910111213141516171819&lt;style&gt; .wrap &#123; width: 100px; height: 500px; border: 2px solid skyblue; display: table; &#125; .box &#123; width: 100%; height: 100%; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;box&quot;&gt; 多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本 &lt;/div&gt;&lt;/div&gt; 13. 行高如何继承12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; font-size: 20px; /* 直接被子元素继承, 即子元素的行高就是 20px */ /* line-height: 20px; */ /* 子元素继承该行高后, 会使用子元素字体大小乘以行高比例, 16 * 1.4 = 24 */ /* line-height: 1.5; */ /* 当行高值写成百分比以后, 会先使用当前字体大小乘以该百分比, 得到的值会被子元素继承, 20 * 2 = 40px */ line-height: 200%; &#125; .wrap &#123; font-size: 16px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;wrap&quot;&gt;这是一段文字&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 14. rem 单位rem 是 css 中的长度单位用于实现移动端适配。 移动端适配是指页面元素的宽、高都要随着设备的宽度进行等比缩放，即移动设备的宽度大，页面元素大，移动设备的宽度小，页面元素小。 rem 是一个相对单位，相对于根元素的字体大小进行计算。 比如根元素的字体大小是 20px，那么 1rem 就等于 20px，那么宽度 5rem 和高度 3rem 的盒子最终的宽高就为 100px，高度就为 60px。 123456789html &#123; font-size: 20px;&#125;.box &#123; /* 100px */ width: 5rem; /* 60px */ height: 3rem;&#125; 要实现移动端适配效果，rem 单位需要和 css 中的媒体查询进行配合使用。 通过媒体查询检测设备的视口宽度，针对不同的设备视口宽度为根元素设置不同的字号大小。 如果设备视口宽度较大就为其设置较大的字号大小，如果设备的视口宽度较小就为其设置较小的字号大小。 1234567891011@media (width: 375px) &#123; html &#123; font-size: 20px; &#125;&#125;@media (width: 414px) &#123; html &#123; font-size: 30px; &#125;&#125; 在真实的项目开发中针对不同的设备的视口宽度，根元素的字号大小要如何进行设置呢？ 在 rem 移动端适配方案中，我们通常将网页宽度等分为十份，然后将根元素的字号大小设置为视口宽度的十分之一，这样就将视口宽度和字号进行了关联。 1234567891011121314151617@media (width: 320px) &#123; html &#123; font-size: 32px; &#125;&#125;@media (width: 375px) &#123; html &#123; font-size: 37.5px; &#125;&#125;@media (width: 414px) &#123; html &#123; font-size: 41.4px; &#125;&#125; 设计稿的宽度是 750px，设计稿中有一个盒子的宽高分别为 100px 和 50px，如何将它们转换为 rem 单位？ 我们可以将设计稿的宽度看成是某一个移动设备的视口宽度，那么在该视口宽度下根元素的字号大小为 75px。 我们只需要使用 100px 除以 75px ，50px 除以 75px，就可以得到盒子的对应的宽高 rem 值。 1234567891011@media (width: 750px) &#123; html &#123; font-size: 75px; &#125;&#125;.box &#123; /* 盒子原本的像素值除以根元素字号大小: 100 / 75 = 1.333 50 / 75 = 0.666 */ width: 1.333rem; height: 0.666rem; background: skyblue;&#125; 通过 VSCode 编辑器中的 px to rem &amp; rpx &amp; vw (cssrem) 插件自动计算 rem 值。 先在 VSCode 编辑器中安装该插件，然后在 VSCode 编辑器的配置文件中设置参考的根元素字号大小 触发转换的快捷键默认为 Alt+Z 123&#123; &quot;cssrem.rootFontSize&quot;: 75&#125; 改进媒体查询以适配所有移动端设备 123456789101112@media (min-width: 320px) &#123;&#125;@media (min-width: 481px) &#123;&#125;@media (min-width: 641px) &#123;&#125;@media (min-width: 961px) &#123;&#125;@media (min-width: 1025px) &#123;&#125;@media (min-width: 1281px) &#123;&#125; 也可以通过 flexible.js 替换媒体查询，该 js 可以动态获取设备的视口宽度，为根元素动态设置十分之一的字号大小。 12345678910111213141516171819202122232425262728293031323334353637383940414243(function flexible(window, document) &#123; var docEl = document.documentElement; var dpr = window.devicePixelRatio || 1; // adjust body font size function setBodyFontSize() &#123; if (document.body) &#123; document.body.style.fontSize = 12 * dpr + &quot;px&quot;; &#125; else &#123; document.addEventListener(&quot;DOMContentLoaded&quot;, setBodyFontSize); &#125; &#125; setBodyFontSize(); // set 1rem = viewWidth / 10 function setRemUnit() &#123; var rem = docEl.clientWidth / 10; docEl.style.fontSize = rem + &quot;px&quot;; &#125; setRemUnit(); // reset rem unit on page resize window.addEventListener(&quot;resize&quot;, setRemUnit); window.addEventListener(&quot;pageshow&quot;, function (e) &#123; if (e.persisted) &#123; setRemUnit(); &#125; &#125;); // detect 0.5px supports if (dpr &gt;= 2) &#123; var fakeBody = document.createElement(&quot;body&quot;); var testElement = document.createElement(&quot;div&quot;); testElement.style.border = &quot;.5px solid transparent&quot;; fakeBody.appendChild(testElement); docEl.appendChild(fakeBody); if (testElement.offsetHeight === 1) &#123; docEl.classList.add(&quot;hairlines&quot;); &#125; docEl.removeChild(fakeBody); &#125;&#125;)(window, document); 15. 视口单位vw 和 vh 是 css 中的一个相对的长度单位，被称之为视口单位。 vw 就是 viewport width，表示它相对于视口的宽度进行计算。 vh 就是 viewport height，表示它相对于视口的高度进行计算。 1vw &#x3D; 1&#x2F;100 视口宽度，如果视口的宽度是 375px，那么 1vw &#x3D; 3.75px。 1vh &#x3D; 1&#x2F;100 视口高度，如果视口的高度是 667px，那么 1vh &#x3D; 6.76px。 123456.box &#123; /* 如果视口宽度是 375, 50 * 3.75 = 187.5 30 * 3.75 = 112.5 */ width: 50vw; height: 30vw; background: skyblue;&#125; 123456.box &#123; /* 如果视口高度是 667, 50 * 6.67 = 333.5 30 * 6.67 = 200.1 */ width: 50vh; height: 30vh; background: skyblue;&#125; 设计稿的宽度是 750px，设计稿中有一个盒子的宽高分别为 100px 和 50px，如何将它们转换为 vw 单位？ 我们可以将设计稿的宽度看成是某一个移动设备的视口宽度，那么在该视口宽度下 1vw &#x3D; 7.5px。 我们只需要使用 100px 除以 7.5px ，50px 除以 7.5px，就可以得到盒子的对应的宽高 vw 值。 123456.box &#123; /* 设计稿宽度 750, 100 / 7.5 = 13.333vw 50 / 7.5 = 6.666vw */ width: 13.333vw; height: 6.666vw; background: skyblue;&#125; 注意一般在使用视口单位布局时，一个盒子的宽高一般不会混用 vw 和 vh，一般会基于 vw。 通过配置 cssrem 插件启用对 vw 的支持，使插件辅助我们计算最终的 vw 值。 1234&#123; &quot;cssrem.vw&quot;: true, &quot;cssrem.vwHover&quot;: true&#125;","tags":["面试题"],"categories":["前端面试题"]},{"title":"HTML面试题","path":"/面试题/HTML面试题/","content":"HTML 高频面试题01. HTML 语义化① 什么是 HTML 语义化 HTML 是一门标记语言，在这门语言中每一个标记都被赋予了特殊的含义。 开发者在构建页面布局时应使用恰当语义的 HTML 标签进行内容的展示。 123456789101112131415161718192021222324252627282930&lt;!-- 用于定义标题 --&gt;&lt;h1&gt;&lt;/h1&gt;&lt;!-- 用于定义页面头部区域或 section 区域的页眉 --&gt;&lt;header&gt;&lt;/header&gt;&lt;!-- 用于定义网页导航链接区域 --&gt;&lt;nav&gt;&lt;/nav&gt;&lt;!-- 用于定义页面主体内容, 一个页面只能使用一次 --&gt;&lt;main&gt;&lt;/main&gt;&lt;!-- 用于定义一个页面中的一块自成一体的内容, 可以有自己的 header、footer、section 等 --&gt;&lt;article&gt;&lt;/article&gt;&lt;!-- 在 article 外, 主要用于定义页面侧边栏区域 --&gt;&lt;!-- 在 article 内, 主要用于定义主要内容的附属内容 --&gt;&lt;aside&gt;&lt;/aside&gt;&lt;!-- 表示有语义化的 div, 用于标记页面中的各个部分 --&gt;&lt;section&gt;&lt;/section&gt;&lt;!-- 用于定义页面底部区域 --&gt;&lt;footer&gt;&lt;/footer&gt;&lt;!-- 用于定义标题组 --&gt;&lt;hgroup&gt;&lt;/hgroup&gt;&lt;!-- 用于标记强调文本 --&gt;&lt;strong&gt;&lt;/strong&gt;&lt;!-- 用于标记一个段落 --&gt;&lt;p&gt;&lt;/p&gt;&lt;!-- 用于标记一个独立的流内容, 比如图像、图标、代码等等 --&gt;&lt;figure&gt; &lt;img src=&quot;/media/cc0-images/elephant-660-480.jpg&quot; alt=&quot;Elephant at sunset&quot; /&gt; &lt;figcaption&gt;An elephant at sunset&lt;/figcaption&gt;&lt;/figure&gt;&lt;!-- 用于标记时间 --&gt;&lt;time&gt;2011-01-28&lt;/time&gt; ② HTML 语义化有什么好处 (1) 语义化的 HTML 代码使开发者更容易理解，增加了程序的可阅读性便于团队开发和维护 (2) 使搜索引擎能够快速定位网页中的重要内容，爬虫是依赖于标签来确定上下文和各个关键字的权重 (3) 在没有 CSS 样式情况下也能够让页面呈现出清晰的结构 (一些标记自带样式) (4) 极大程度利用标签的特点优化用户体验，比如 img 标记的 alt 属性和 title 属性、比如 label 标记 02. 块级元素与行内元素① 在 HTML 语言中哪些标记属于块级元素、哪些标记属于行内元素、哪些标记属于行内块元素 display 属性值为 block 或 table 的元素属于块级元素。 1234567&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;/h1&gt;&lt;ul&gt;&lt;/ul&gt;&lt;ol&gt;&lt;/ol&gt;&lt;table&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt; display 属性值为 inline 的元素属于行内元素。 12345&lt;span&gt;&lt;/span&gt;&lt;a&gt;&lt;/a&gt;&lt;b&gt;&lt;/b&gt;&lt;strong&gt;&lt;/strong&gt;&lt;i&gt;&lt;/i&gt; display 属性值为 inline-block 的元素属于行内块元素 123&lt;img /&gt;&lt;input /&gt;&lt;button&gt;&lt;/button&gt; ② 块级元素有什么特点 (1) 块级元素独占一行 (2) 块级元素的宽度默认为 100% (3) 块级元素的高度、行高、外边距、内边距可控 (4) 可以包含行内元素可块级元素 ③ 行内元素有什么特点 (1) 行内元素可以与其他行内元素同在一行，在一行排不下的情况下才会换行显示 (2) 行内元素可设置水平方向上的内边距和外边距、垂直方向无效 (3) 行内元素不能设置宽度和高度，其宽度和高度由内容自动撑开 (4) 行内元素只能包含其他行内元素或文本 ④ 行内块元素有什么特点 (1) 和相邻的行内元素(行内块)在一行上但是中间会有空白的间隙 (2) 可设置宽度、但默认宽度为内容撑开的宽度 (3) 高度、内边距、外边距都可以设置 (4) 行内块元素不能转化为行内元素 ⑤ 通过哪些方式可以将行内元素转换为块级元素 1234567display: block;/* 为行内元素设置 float:left/right 后, 该元素的 display 属性会被设置 block, 且拥有浮动特性。 */float: left;float: right;/* 为行内元素设置决定定位或固定定位时, 会使得行内元素变为块级元素。 */position: absolute;position: fixed; 03. src 属性与 href 属性的区别src 属性和 href 属性都可以用来引入外部的资源。 src 全称 source，通过 src 属性指向的内容会嵌入到文档中标签所在位置比如 js 脚本、img 图片。 当浏览器解析到该元素时，会暂停其它资源下载直到将该资源加载、编译、执行完毕。 正因为该特性所以我们才建议将 js 脚本放置在页面底部加载，防止阻塞页面加载影响用户体验。 href 全称 hyper reference 表示超文本引用，用于建立标签与外部资源的关系。 当浏览器解析到该元素时，会和其他资源并行下载，并不会停止对文档的解析，通常用于超链接和样式表的加载。 由于并行加载特性所以我们才建议将样式表文件防止在页面顶部加载，防止出现页面裸奔现象。 123456&lt;link href=&quot;cssfile.css&quot; /&gt;&lt;a href=&quot;http://www.webpage.com&quot;&gt;&lt;/a&gt;&lt;script src=&quot;myscript.js&quot;&gt;&lt;/script&gt;&lt;img src=&quot;mypic.jpg&quot; /&gt;&lt;video src=&quot;&quot;&gt;&lt;/video&gt;&lt;audio src=&quot;&quot;&gt;&lt;/audio&gt; 04. 图像标记的 title 属性与 alt 属性alt 属性全称 alternate 表示备用，如果图像无法显示浏览器将渲染 alt 指定的内容。 title 属性表示图像的标题，当鼠标移动到图像上时显示 title 属性值中的内容。 1&lt;img src=&quot;&quot; title=&quot;鼠标移入图像时展示的内容&quot; alt=&quot;图像无法显示时展示的内容&quot; /&gt; 05. label 标签的作用label 标签的作用是为使用鼠标的用户改进了可用性，当用户点击 label 标签中的文本时浏览器就会自动将焦点转到和该标签相关联的表单控件上。 123456&lt;form&gt; &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; /&gt; &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot; /&gt;&lt;/form&gt; 06. GET 与 POST 的区别GET 和 POST，两者都是 HTTP 协议中发送请求的方法。 GET 一般用于从服务器端获取数据，POST 一般用于向服务器端传送数据。 GET 和 POST 本质上使用的都是 TCP 链接并无差别，但由于 HTTP 的规定和浏览器&#x2F;服务器的限制，导致他们在使用过程中会体现出一些区别。 ① GET 在浏览器回退时是无害的而 POST 会再次提交请求。 ② GET 产生的 URL 地址可以被存储为书签而 POST 不可以。 ③ GET 请求会被浏览器主动缓存而 POST 不会，除非手动设置。 ④ GET 请求只能进行 url 编码而 POST 支持多种编码方式。 ⑤ GET 请求参数会被完整保留在浏览器历史记录里而 POST 中的参数不会被保留。 ⑥ GET 请求在 URL 中传送的参数是有长度限制的而 POST 没有。 ⑦ GET 比 POST 更不安全，因为参数直接暴露在 URL 中，所以不能用来传递敏感信息。 ⑧ GET 参数通过 URL 传递，POST 放在请求体中。","tags":["面试题"],"categories":["前端面试题"]},{"title":"React路由[V6]","path":"/React/react路由v6/","content":"React 路由[V6]1.集成应用1234//创建应用create-react-app 项目名//安装路由库npm install react-router-dom@6.4.3 项目中应用 1234567891011121314// src/index.jsimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;// createBrowserRouter: 用于创建基于浏览器历史记录的路由系统// RouterProvider: 用于配置路由系统的组件import &#123; createBrowserRouter, RouterProvider &#125; from &quot;react-router-dom&quot;;// 创建路由系统const router = createBrowserRouter([ // 当用户在浏览器中访问 / 路径时,渲染对应组件 &#123; path: &quot;/&quot;, element: &lt;Home /&gt; &#125;,]);const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));// 使路由规则生效root.render(&lt;RouterProvider router=&#123;router&#125; /&gt;); 2.配置路由组件01.创建页面组件 123456789101112// src/pages/home/index.jsimport React from &quot;react&quot;;export default function HomePage() &#123; return &lt;div&gt;首页页面&lt;/div&gt;;&#125;// src/pages/news/index.jsimport React from &quot;react&quot;;export default function HomePage() &#123; return &lt;div&gt;新闻页面&lt;/div&gt;;&#125; 02.配置路由规则 123456789// src/index.jsimport HomePage from &quot;./pages/home&quot;;// 注意: 在 v6 版本中，请求路径 / 不再需要使用 exact 属性const router = createBrowserRouter([ // 当用户在浏览器中访问 / 路径时, 渲染 &lt;HomePage /&gt; 组件 &#123; path: &quot;/&quot;, element: &lt;HomePage /&gt; &#125;, // 当用户在浏览器中访问 /topic 路径时, 渲染 &lt;TopicPage /&gt; 组件 &#123; path: &quot;/topic&quot;, element: &lt;TopicPage /&gt; &#125;,]); 3.嵌套路由使一级路由和二级路由关联 12345678910111213const router = createBrowserRouter([ // 当用户在浏览器中访问 /news 路径时, 渲染 &lt;NewsPage /&gt; 组件 &#123; path: &quot;/news&quot;, element: &lt;NewsPage /&gt;, children: [ // 当用户在浏览器中访问 /news/company 路径时, 将 &lt;CompanyNewsPage /&gt; 组件渲染到 &lt;NewsPage /&gt; 组件中 &#123; path: &quot;company&quot;, element: &lt;CompanyNewsPage /&gt; &#125;, // 当用户在浏览器中访问 /news/industry 路径时, 将 &lt;IndustryNewsPage /&gt; 组件渲染到 &lt;NewsPage /&gt; 组件中 &#123; path: &quot;industry&quot;, element: &lt;IndustryNewsPage /&gt; &#125;, ], &#125;,]); 在一级路由页面添加占位符()给子级路由渲染位置 1234567// src/pages/news/index.jsimport &#123; Outlet &#125; from &quot;react-router-dom&quot;;export default function NewsPage() &#123; // 子路由页面组件将会被渲染到占位符组件所在的位置 return &lt;Outlet /&gt;;&#125; 4.导航链接使用 react 提供的 Link 组件实现路由跳转, 通过 NavLink 组件生成的链接在被激活时 React Router 会为其添加激活类名，默认激活类名为 active 1234567891011 &lt;div&gt; &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt; &lt;ink to=&quot;/topic&quot;&gt;专题&lt;/Link&gt; &lt;ink to=&quot;/news&quot;&gt;新闻&lt;/Link&gt; &lt;/div&gt;----------------------------&lt;div&gt; &lt;NavLink to=&quot;/&quot;&gt;首页&lt;/NavLink&gt; &lt;NavLink to=&quot;/topic&quot;&gt;专题&lt;/NavLink&gt; &lt;NavLink to=&quot;/news&quot;&gt;新闻&lt;/NavLink&gt; &lt;/div&gt; 5.路由路径传参01.路由规则定义可选参数 1&#123;path:&quot;url/:参数名&quot;,element:&lt;路由指向的组件/&gt;&#125; 02.页面组件中实现参数传递 (to&#x3D;”url&#x2F;参数”) 12345678910111213141516import &#123; Link &#125; from &quot;react-router-dom&quot;;export default function Page() &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&quot;/team/team-a&quot;&gt;Team A&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/team/team-b&quot;&gt;Team B&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; );&#125; 12//获取路由参数 -参数名为路由规则中的:参数名const &#123; 参数名 &#125; = useParams(); 6.路由查询参数在页面组件中进行页面跳转时实现路由传递参数 01.配置路由规则 1234567const router = createBrowserRouter([ &#123; path: &quot;/&quot;, element: &lt;Layout /&gt;, children: [&#123; path: &quot;login&quot;, element: &lt;LoginPage /&gt; &#125;], &#125;,]); 02.页面组件传参 （路径？路由参数） 1234567export default function HomePage() &#123; return ( &lt;p&gt; &lt;Link to=&quot;/login?returnUrl=testUrl&quot;&gt;登录&lt;/Link&gt; &lt;/p&gt; );&#125; 03.获取路由参数 1234// 获取路由查询参数操作对象const [searchParams] = useSearchParams();// 获取路由参数 returnUrl 的值const returnUrl = searchParams.get(&quot;returnUrl&quot;); 7.页面跳转回到顶部01.页面在进行跳转时滚动的位置不会回滚到顶部使用 react 提供的组件可以在跳转的页面实现页面回滚到顶部 12345import &#123; ScrollRestoration &#125; from &quot;react-router-dom&quot;;export default function Layout() &#123; return &lt;ScrollRestoration /&gt;;&#125; 02.阻止回滚到顶部通过 Link 组件的 preventScrollReset 选项阻止滚动恢复 123&lt;Link to=&quot;/topic&quot; preventScrollReset=&#123;true&#125;&gt; 专题&lt;/Link&gt; 8.路由组件懒加载01.通过 React 提供的 lazy 方法和 Suspense 组件实现路由组件懒加载lazy 方法用于懒加载组件、Suspense 组件用于渲染加载过程中的等待状态。 12345678910111213141516171819202122// 通过懒加载的方式导入组件const HomePage = lazy(() =&gt; import(&quot;./pages/home&quot;));//组件实现懒加载状态const router = createBrowserRouter([ &#123; path: &quot;/&quot;, element: &lt;Layout /&gt;, children: [ &#123; path: &quot;&quot;, element: ( &lt;Suspense fallback=&#123;&lt;Fallback /&gt;&#125;&gt; // &lt;Fallback /&gt; 为组件加载过程中的样式组件 &lt;HomePage /&gt; &lt;/Suspense&gt; ), &#125;, ], &#125;,]); 02.Suspense 组件复用实现懒加载状态 创建 loadable 方法复用 Suspense 组件 123456789export default function loadable(Component) &#123; return function (props) &#123; return ( &lt;Suspense fallback=&#123;&lt;Fallback /&gt;&#125;&gt; &lt;Component &#123;...props&#125; /&gt; &lt;/Suspense&gt; ); &#125;;&#125; 123456// src/index.js// 1. 多行选择: 按住鼠标滚动拖动// 2. 选择下一个单词: alt + shift + =&gt;// 3. 选择到行尾: ctrl + shift + =&gt;// 4. 选择下一个字符: shift + =&gt;const HomePage = loadable(lazy(() =&gt; import(&quot;./pages/home&quot;))); 9.404 页面配置创建自己定义的 404 组件页面 NotFoundPage，使用 errorElement 方法，当用户访问了一个不存在的路由路径时就会跳转该页面。 1234567const router = createBrowserRouter([ &#123; path: &quot;/&quot;, // 当用户访问了一个不存在的路由路径时, 渲染 PageNotFound 组件 errorElement: &lt;NotFoundPage /&gt;, &#125;,]);","tags":["React"],"categories":["React使用"]},{"title":"ReduxToolkit全局状态管理","path":"/React/ReduxToolkit全局状态管理/","content":"ReduxToolkitReduxToolkit 是官方推出的基于 Redux 进行高度封装的工具包，不需下载就可下载，在开发过程中可以用更少的代码完成工作。 使用12345# 新项目# Redux + Plain JS templatenpx create-react-app my-app --template redux# Redux + TypeScript templatenpx create-react-app my-app --template redux-typescript 12# 现有项目 (@reduxjs/toolkit 和 react-redux 都自带ts类型声明文件, 不需要单独下载)npm install @reduxjs/toolkit@1.9.5 react-redux@8.0.5 一、方法1.createActioncreateAction 用于创建 action creator 函数，接收 action 对象的 type 属性作为参数 1export const creator = createAction(&quot;type&quot;); 2.createReducercreateReducer 用于创建 reducer 函数，使 reducer 函数中的代码细化和拆分。 addCase 调度操作的 action.type 与提供字段完全匹配运行 reducer。 addMatcher 里提供的函数返回 true 时运行 reducer。 123456export const Reducer = createReducer(state, (builder) =&gt; &#123; builder .addCase(creator, () =&gt; (&#123;&#125;)) .addMatcher((action) =&gt; action.type === &quot;action.type&quot;), (state, action) =&gt; (&#123;&#125;);&#125;); 3.configureStoreconfigureStore 创建和配置 Redux 的 store 对象。 1234567export const store = configureStore(&#123; reducer: &#123; counterReducer, &#125;, //是否开启redux工具 devTools: process.env.NODE_ENV !== &quot;production&quot;,&#125;); 4.useSelectoruseSelector 用于在函数式组件中获取 store 对象中的状态的方法,接收函数为参数，参数函数的参数表示状态对象，参数函数返回要获取的具体状态。 1const useSelector((state)=&gt;state.counterReducer.count); 5.useDispatchuseDispatch 是用于在函数式组件中获取 dispatch 的方法 12const dispatch = useDispatch();dispatch(获取dispatch); 6.createAsyncThunkcreateAsyncThunk 用于创建执行异步操作的 action creator 函数。第一个参数是 action 对象的 type 属性，第二个参数是指向异步操作的函数。 1234567export const Creators = createAsyncThunk(&quot;type属性&quot;, async () =&gt; &#123; const res = await axios.get(&quot;http://123&quot;); return res;&#125;);//Creators.pending-&gt;加载//Creators.fulfilled-&gt;请求成功//Creators.rejected-&gt;请求失败 调用 1234567891011121314151617181920const initialState = &#123; status: &quot;idle&quot;, data: [], error: null &#125;;export const Reducer = createReducer(initialState, (builder) =&gt; &#123; builder .addCase(loadTodos.pending, () =&gt; (&#123; status: &quot;loading&quot;, data: [], error: null, &#125;)) .addCase(loadTodos.fulfilled, (state, action) =&gt; (&#123; status: &quot;success&quot;, data: action.payload, error: null, &#125;)) .addCase(loadTodos.rejected, (state, action) =&gt; (&#123; status: &quot;error&quot;, data: [], error: action.error, &#125;));&#125;); 7.createSlice 状态切片action creator 函数、reducer 函数全部都由状态切片生成，状态切片可以使在开发时更专注于状态的管理。 1234567891011121314151617181920212223242526272829import &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;;// createSlice 方法的返回值是一个对象// actions: 该对象中存储的是操作状态 action creator 函数, reducers 配置对象中的函数名称将会作为 action creator 函数的名称// reducer: 原本开发者自己定义的 reducer 函数const &#123; actions, reducer: counterReducer &#125; = createSlice(&#123; // 状态名称, 该名称将会被用于 action 对象的 type 属性值的第一部分 name: &quot;counter&quot;, // 初始状态 initialState: &#123; count: 0 &#125;, // 方法接收两个参数, state 对象和 action 对象 // 在方法中可以直接对状态对象进行操作, 不需要返回新的状态对象 // 调用 action creator 函数时传递的参数将会被放置在 action.payload 属性中 reducers: &#123; increment: (state) =&gt; &#123; state.count += 1; &#125;, decrement: (state) =&gt; &#123; state.count -= 1; &#125;, incrementByCount: (state, action) =&gt; &#123; state.count = state.count + action.payload; &#125;, &#125;,&#125;);// 导出 action creator 函数供组件使用export const &#123; increment, decrement, incrementByCount &#125; = actions;// 导出 counterReducer 函数export default counterReducer; 7.1createSlice_prepareprepare 方法允许开发者在 action 指令发出后 reducer 函数接收前先对 action 对象中的 payload 属性值进行处理。 123456789101112incrementByCount: &#123; prepare: (payload) =&gt; &#123; // prepare 方法接收 payload 作为参数 // 要求返回对象, 该对象会和 action 对象进行合并 return &#123; payload: payload + 10, &#125;; &#125;, reducer: (state, action) =&gt; &#123; state.count = state.count + action.payload; &#125;, &#125;, 8.configureStore_middleware 配置中间件middleware 选项的值是一个函数，该函数有一个参数，该参数习惯被命名为 getDefaultMiddeware，它就是用来获取内置中间件函数的。etDefaultMiddeware 方法的返回值是一个数组，数组中包含内置的中间件函数，开发者只需要在该数组中添加中间件函数即可。middleware 选项要求在该函数中返回最新的中间件函数数组。 12345678//npm i redux-logger@3.0.6import logger from &quot;redux-logger&quot;;export const store = configureStore(&#123; middleware: (getDefaultMiddleware) =&gt; &#123; return getDefaultMiddleware().concat(logger); &#125;,&#125;);","tags":["React"],"categories":["React使用"]},{"title":"React 函数组件","path":"/React/react函数组件/","content":"一、函数组件函数组件是一个返回视图(JSX)的函数。 1.创建函数组件123function App() &#123; return &lt;div&gt;APP&lt;/div&gt;;&#125; 2.函数组件使用方法01.useState 声明组件状态​ 在 React 函数组件中可以通过 useState 方法创建组件状态，可以被调用多次声明多个状态。 123456789101112131415161718//useState方法返回值是一个数组，第一个参数是状态变量，第二个参数是修改/更新状态的方法。function App() &#123; const [value, setValue] = useState(&quot;状态初始值&quot;); const [count, seCount] = useState(0); retutn( &lt;&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;p&gt;&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setValue(&quot;修改的值&quot;)&#125;&gt;更改状态&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setVlaue(count + 1)&#125;&gt;更改数值+1&lt;/button&gt; //更新状态方法可以接收函数作为参数，通过参数函数返回值指定新状态值 //prevState表示更新前状态 //参数函数返回值表示更新后状态 &lt;button onClick=&#123;() =&gt; setCount((prevState) =&gt; prevState - 1)&#125;&gt; 更新数值-1 &lt;/button&gt; &lt;/&gt; );&#125; ​ 当多次调用修改状态的方法时，当传递状态值，最后面的状态会覆盖前面状态；当传递函数，顺序执行，所有函数执行完毕才会更新。 123456789101112131415161718192021222324//传递状态值，最后结果为count+2&lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setCount(count + 1); setCount(count + 1); setCount(count + 2); &#125; &#125; &gt; &#123;count&#125; &lt;/button&gt;//传递函数方法，顺序执行+1+1+1+1返回最终相加结果&lt;button onClick=&#123;() =&gt; &#123; setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); &#125; &#125; &gt; &#123;count&#125; &lt;/button&gt; 02.useEffect 确保函数式组件正确执行副作用代码​ 在 React 中，副作用指与组件渲染无关的操作，如获取数据、修改全局变量、更新 DOM 等。这些操作可能会影响组件渲染结果，但不能被纯函数捕获，因此需 useEffect 进行特殊处理，确保代码在正确时机执行。 ​ useEffect 接收一个回调函数和一个依赖数组作为参数，回调函数的代码会在组件渲染完成后执行，依赖数组的变量会在其发生变化时触发回调函数重新执行。 1234const [参数变量, 修改方法代码] = useState(&quot;&quot;);useEffect(() =&gt; &#123; //回调函数代码&#125;, [&quot;参数变量&quot;]); 03.useRef 获取 DOM 对象​ 通过 useRef 方法可以在函数式组件中获取 DOM 对象 1234function App()&#123; const name = useRef(); return &lt;input ref=&#123;name&#125; onChange=&#123;()=&gt;consloe.lgo(name.current)&#125;/&gt;&#125; 04.forwardRef 获取子组件 DOM 对象​ 通过 useRef 和 forward 高阶函数配合使用可以实现父子组件之间传递 ref 对象。 12345678910//appfunction App() &#123; const appref = useRef(); return &lt;Message ref=&#123;appref&#125; /&gt;;&#125;//messagefunction Message(props, ref) &#123; return &lt;span ref=&#123;ref&#125;&gt;message&lt;/span&gt;;&#125;export default forwardRef(Message); 05.受控组件和非受控组件受控表单组件 ​ 表单状态由 React 组件状态控制 12345678910111213141516171819202122232425function App() &#123; const [formState, setFormState] = useState(&#123; username: &quot;&quot;, password: &quot;&quot; &#125;); const onChangeHandler = (event) =&gt; &#123; setFormState(&#123; ...formState, [event.target.name]: event.target.value, &#125;); &#125;; return ( &lt;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&#123;formState.username&#125; onChange=&#123;onChangeHandler&#125; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&#123;formState.password&#125; onChange=&#123;onChangeHandler&#125; /&gt; &lt;/&gt; );&#125; 非受控表单组件 ​ 通过 DOM 获取&#x2F;修改值，使用 useRef 实现非受控表单组件 12345678910111213function App() &#123; const usernameRef = useRef(); const onSubmijs = (event) =&gt; &#123; event.preventDefault(); console.log(usernameRef.current.value); &#125;; return ( &lt;form onSubmit=&#123;onSubmijs&#125;&gt; &lt;input type=&quot;text&quot; ref=&#123;usernameRef&#125; /&gt; &lt;button&gt;button&lt;/button&gt; &lt;/form&gt; );&#125; 06.父子组件通信 - Props1.父组件传递状态到子组件，子组件修改父组件传递的状态值。 1234567891011//父组件function App() &#123; const [msg, setMsg] = useState(&quot;hello&quot;); //传递给子组件 return &lt;Message msg=&#123;mgs&#125; setMsg=&#123;setMsg&#125;&gt;&lt;/Message&gt;;&#125;//子组件function Message(props) &#123; //接收父组件传递的数据 return &lt;button onClick=&#123;() =&gt; props.setMsg(&quot;你好&quot;)&#125;&gt;&#123;props.msg&#125;&lt;/button&gt;;&#125; 2.设置 Props 对象默认值方式 123456789101112131415161718192021222324252627function App(props) &#123; return ( &lt;div&gt; &lt;Message name=&#123;&quot;张三&quot;&#125; age=&#123;30&#125; /&gt; &lt;/div&gt; );&#125;function Message(&#123; name = &quot;李四&quot;, age = 20 &#125;) &#123; return ( &lt;div&gt; &#123;name&#125; &#123;age&#125; &lt;/div&gt; );&#125;export default App;-------------------------function App()&#123; return &lt;Message/&gt;;&#125;function Message(&#123;name,age&#125;)&#123; return &lt;div&gt;&#123;name&#125;&#123;age&#125;&lt;/div&gt;&#125;Message.defaultProps=&#123; name:&quot;张三&quot;, age:20&#125; 07.父子组件通信-useImperativeHandle​ useImperativeHandle 允许父组件直接调用子组件暴露的成员属性和方法。 12345678910111213141516//App.jsfunction App() &#123; const msgRef = useRef(); return ( &lt;&gt; &lt;Message ref=&#123;msgRef&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; console.log(msgRef.current.value); &#125;&#125; &gt; getMsg &lt;/button&gt; &lt;/&gt; );&#125; 12345678910111213//Messagefunction Message(props, ref) &#123; const [value, setValue] = useState(&quot;&quot;); //useImperativeHandle用于设置ref对象中current属性的值，(参数传递ref对象，传递函数(函数返回什么ref对象的current属性值就是什么，组件每次重新渲染时执行)，数组(传递依赖状态)) useImperativeHandle(ref, () =&gt; (&#123; vlaue &#125;), [value]); return ( &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;(event) =&gt; setValue(event.target.value)&#125; /&gt; );&#125; 08.跨级组件通讯-useContext在组件中创建导出的对象，另一个组件中通过 useContext 方法就那些获取。 12345//创建上下文对象export const PersonContext = createContext(&#123; name: &quot;张三&quot;, age: 20 &#125;);//获取上下文状态const person = useContext(PersonContext); 09.组件状态逻辑分离-useReduceruseReducer 是 React 提供的另一种在函数式组件中声明状态的方式。将组件状态逻辑和组件渲染逻辑进行分离，使代码更加清晰可维护。useReducer 是 useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。 1234567891011121314151617function App()&#123; const [state,dispatch] = useReducer(counterReducer,&#123;count:0&#125;); return &lt;button onClick=&#123;()=&gt;dispatch(&#123;type:&quot;counter/increent&quot;&#125;)&#125;&gt;&#123;state.count&#125;&lt;/button&gt;&#125;-----------------------// src/counterReducer.jsexport default function counterReducer(state, action) &#123; switch (action.type) &#123; case &quot;counter/increment&quot;: return &#123; ...state, count: state.count + 1, &#125;; default: return state; &#125;&#125; 10.保存组件值-useRefuseRef 可以获取 DOM 元素，保存普通值；使用 useRef 保存的普通值并不会随组件更新而销毁，修改通过 useRef 保存的值也不会触发组件更新。 例：组件初次渲染开启定时器，点击按钮进行清空。 1234567891011121314151617181920212223function App(props) &#123; // 根据useRef设置定时器; const [count, setCount] = useState(0); // 保存定时器id const intervalRef = useRef(); useEffect(() =&gt; &#123; //开启定时器 intervalRef.current = window.setInterval(() =&gt; &#123; setCount((prevState) =&gt; prevState + 1); &#125;, 1000); return () =&gt; clearInterval(intervalRef.current); &#125;, []); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; clearInterval(intervalRef.current)&#125;&gt; 清除定时器 &lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount((prevState) =&gt; prevState + 1)&#125;&gt; &#123;count&#125;数值加1 &lt;/button&gt; &lt;/div&gt; );&#125;","tags":["React"],"categories":["React使用"]},{"title":"React 基本使用","path":"/React/react基本使用/","content":"react 使用一、react 基础01.react 基本使用1.react 概念 react 概念 React 是一个开源的 JavaScript 库，用于构建 web 应用中的视图层，既是 web 应用的前端用户页面。（一个用于构建用户界面的 javascript 库，与 2012 年由 Facebook 创建，13 年 5 月开源维护） 2.创建 react 项目指令使用 123456#全局安装react脚手架npm install create-react-app@5.0.1 -g#创建项目 名称create-react-app react-basic#进入项目根目录启动项目npm start 目录结构分析 1234567891011121314151617181920# 项目结构分析├── README.md # 项目的说明书├── package.json # npm 包说明文件、记录项目信息├── package-lock.json # 跟踪被安装的每个软件包的确切版本├── public # 本地开发服务器提供的静态资源目录│ ├── favicon.ico # 网站图标、显示在浏览器的标签栏中│ ├── index.html # 项目的 HTML 模板│ ├── logo192.png # react logo 图片 (示例代码中用于设置 IOS 移动端网站图标)│ ├── logo512.png # react logo 图片│ ├── manifest.json # web 应用清单如名称, 作者, 图标和描述 (主要用于将 Web 应用程序安装到设备的主屏幕)│ └── robots.txt # 爬虫协议文件└── src # 项目源码目录 ├── App.css # 示例程序中的根组件样式文件 ├── App.js # 示例程序中的根组件文件 ├── App.test.js # 示例程序中的根组件测试文件 ├── index.css # 示例程序中的全局样式文件 ├── index.js # 项目的入口文件 ├── logo.svg # 示例程序中根组件中显示的网站图标文件 ├── reportWebVitals.js # 测试应用程序的性能 └── setupTests.js # 项目的测试文件 3.react 初使用123456789101112#创建h1元素#参数属性-》(标记名称，标记属性，子元素...);const title = React.createElement( &quot;h1&quot;, &#123;title:&quot;hello&quot;,id:1&#125;, &quot;hello react&quot;)document.createElement(&quot;h1&quot;);#获取public文件下的index.html中的div盒子idconst root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;))#使用render方法生成template模板root.render(title); 4.JSX 概述 jsx 概念 jsx 语法是 React 提供另一种创建用户界面的方式，看起来很像 HTML,但他绝不是 HTML,他是一只 JavaScript 语法扩展。facebook 处于性能考虑，解决必须通过 React.createElement 创建元素，创建出了 jsx，在应用构建的过程中 jsx 由 babel(js 编译器)转换成 React.createElement 方法调用 代码样式 1234567891011const list = ( &lt;div className=&quot;list&quot;&gt; &lt;h2&gt;Hello React&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;hello&lt;/li&gt; &lt;li&gt;react&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;);const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(list); 5.JSX 注意事项(1)JSX 格式美化 当 jsx 中存在多个标记使用小括号（）进行包裹，使代码格式美化排列，创建元素时，元素的最外层必须要有一个根标记 1234567const jsx = ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;); (2)避免出现无意义标记，可使用幽灵标记&lt;&gt;&lt;&#x2F;&gt;(完整语法&lt;React.Fragment&gt;&lt;&#x2F;React.Fragment&gt;) 123456const jsx = ( &lt;&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;/&gt;); (3)JSX 中使用单标签必须是闭合状态 12&lt;input type=&quot;text&quot;/&gt;&lt;img src=&quot;&quot; alt=&quot;&quot;/&gt; (4)在 JSX 中标记属性使用小驼峰命名法 （由多个单词组成，第一个单词首字符小写，其他单词首字符大写） 1&lt;input maxLength=&quot;100&quot; readOnly autoFocus /&gt; (5)在 JSX 中为元素添加属性时使用 className 代替 class、htmlFor 代替 for （jsx 本质上是 javaScript） 12&lt;input type=&quot;text&quot; className=&quot;todos&quot;/&gt;&lt;label htmlFor=&quot;demo&quot;/&gt; 6.JSX 嵌入表达式含义：将表达式产生的值渲染到用户界面中。 表达式就是一个能够产生结果的式子,jsx 里面只能放表达式，非表达式不能被嵌入 JSX 插入值（{}花括号）包裹插入属性值 123//插入文本内容const name = &quot;张三&quot;;const jsx = &lt;div&gt;&#123;name&#125;&lt;/div&gt;; 123//插入属性值const activeName = &quot;active&quot;;const jsx = &lt;input type=&quot;text&quot; className=&#123;activeName&#125; /&gt;; 1234//计算const x = 10;const y = 20;const jsx = &lt;p&gt;&#123;x * y&#125;&lt;/p&gt;; 12345//渲染函数返回值function getValue() &#123; return &quot;jsx&quot;;&#125;const jsx = &lt;p&gt;&#123;getValue()&#125;&lt;/p&gt;; 123//表达式const status = true;const jsx = status ? &lt;div&gt;true&lt;/div&gt; : &lt;div&gt;false&lt;/div&gt;; 12//插入对象 内容中不能直接插入对象const jsx = &lt;p style=&#123;&#123; width: 200 &#125;&#125;&gt;&#123;&#123; name: &quot;jsx&quot; &#125;&#125;&lt;/p&gt;; 1234//注释&#123; /**/&#125; 7.条件渲染（1）使用 if 分支语句进行条件渲染 123456789const Status = fasle;function getContent() &#123; if (Status) &#123; return &lt;span&gt;true&lt;/span&gt;; &#125; else &#123; return &lt;span&gt;fasle&lt;/span&gt;; &#125;&#125;const jsx = &lt;div&gt;&#123;getContent()&#125;&lt;/div&gt;; （2）使用三元运算符进行条件渲染 12const Status = false;const jsx = Status:&lt;span&gt;true&lt;/span&gt;:&lt;span&gt;false&lt;/span&gt; (3)使用逻辑运算符进行条件渲染 123逻辑运算符 &amp;&amp;,全为真时返回真，有一个为假返回假true&amp;&amp;truefalse&amp;&amp;true","tags":["React"],"categories":["React使用"]},{"title":"React性能优化","path":"/React/react性能优化/","content":"React 组件性能优化1. memoReact.memo 可以对组件输入数据进行浅层比较(简单数据类型比较值，引用数据类型比较内存的引用地址)，如果输入数据没有变化则阻止组件更新。 2. useMemoReact.useMemo 用于在函数式组件中缓存值，避免重复操作执行影响组件运行性能。 3. useCallbackReact.useCallback 用于在函数式组件中缓存方法，避免组件每次重新渲染时都返回一个新方法。 4. useDeferredValueReact.useDeferredValue 用于获取一个延时更新的值，让 React 在空闲时去更新值；在频繁更新视图的场景下可以避免出现视图卡顿现象。 5. useTransitionReact.useTransition 用于允许开发者点赞状态渲染的优先级；可以将资源密集型任务优先级降低，等待 React 空闲时执行，避免页面出现卡顿现象。","tags":["React"],"categories":["React使用"]},{"title":"React + TypeScript - 类组件","path":"/React/react-ts-类组件/","content":"React + TypeScript - 类组件1.应用创建使用官方提供脚手架，创建指令后添加–template typescript 即可 1npm create-react-app 文件名 --template typescript 创建应用后项目中包含 jsx 代码文件后缀为.tsx，不包含 jsx 代码的文件为.ts 2.Component 泛型类标注 Props 和 States 对象的类型 123456789101112131415161718192021222324interface Props &#123; name: string;&#125;interface States &#123; count: number;&#125;//使用泛型类export default class App extends React.Components&lt;Props, States&gt; &#123; constructor(props: Readonly&lt;Props&gt;) &#123; super(props); this.state = &#123; count: 0, &#125;; &#125; render() &#123; return ( &lt;&gt; &lt;div&gt;&#123;name&#125;&lt;/div&gt; &lt;/&gt; ); &#125;&#125;//index.tsx&lt;APP name=&#123;&quot;张三&quot;&#125; /&gt;; 3.标注 React 元素类型01.React 元素含义：通过 React.createElement 方法创建的元素、通过 JSX 语法创建的元素。（虚拟 DOM 对象） 12const title = React.createElement(&quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;);const title2 = &lt;h1 className=&quot;one&quot;&gt;Hello&lt;/h1&gt;; 02.标注 React 元素类型 使用 ReactElement 和 JSX.Element 都可以标注元素的类型 1234567891011import &#123; ReactElement &#125; from &quot;react&quot;;const title: ReactElement = React.createElement( &quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;);const titl2: JSXElement = React.createElement( &quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;); 4.ReactPortal(了解)ReactPortal 表示 ReactDOM.createPortal 方法的返回值类型 123render():ReactPortal&#123; return createPortal(&lt;div&gt;&lt;/div&gt;)&#125; 5.ReactNodeReactNode 表示可渲染的任意值，包括布尔值，数字，字符串，数组等，是 React 中最泛化的类型 123456789type ReactNode = | ReactElement | string | number | ReactFragment | ReactPortal | boolean | null | undefined; 6.ReactFragmentReactFragment 表示一组可以被遍历渲染的任意值，只用于标注组件 children 属性的类型。 123456789//type ReactFragment = Interble&lt;ReactNode&gt;interface Props &#123; children: ReactFragment;&#125;&lt;App&gt; &#123;/* 不能只有一个, 只能多个 */&#125; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/App&gt;; 7.CSSPropertiesCSSProperties 用于标注 styles 属性值的类型，对样式值对象的属性及属性值的类型进行约束。 1234interface Props &#123; style?: React.CSSProperties;&#125;&lt;div style=&#123;this.props.style&#125;&gt;&lt;/div&gt;; 8.标注事件对象的类型MouseEvent 用于标注鼠标事件对应的事件对象的类型。onClickHandler KeyboardEvent 用于标注键盘事件对应的事件对象的类型。onKeyUpHandler FormEvent 用于标注表单提交事件对应的事件对象的类型。onSubmitHandler UIEvent 通用的和用户界面相关的事件的事件对象类型，一般我们使用 UIEvent 标注滚动事件的事件对象类型、加载事件的事件对象类型等。onScrollHandler 123function on事件名(event:React.标注事件类型&lt;HTML事件Element&gt;)&#123;&#125;//等价写法const on事件名:React.标注事件类型Handler&lt;HTML事件Element&gt;=(event)=》&#123;&#125; 9.DefaultPropsdefaultProps 中添加属性之后，该属性变为可选，在调用当前组件时不传递该属性也可以通过 ts 的编译 123456789101112131415interface Props&#123; name:string; age:number;&#125;export default class App extends React.Component&lt;Props&gt;&#123; static defaultProps:Pick&lt;Props&gt; = &#123; name:&quot;默认&quot; &#125;; render() &#123; return &lt;div&gt;APP&lt;/div&gt;; &#125;&#125;//index.tsx&lt;App /&gt;&lt;App greetings=&#123;&quot;Hello world&quot;&#125; age=&#123;20&#125; /&gt;","tags":["React"],"categories":["React使用"]},{"path":"/about/index.html","content":"联系方式 手机：156****9428 Email：331****&#x33;&#50;&#48;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#109; QQ&#x2F;微信号：331***320&#x2F;A331****420 个人信息 国朋&#x2F;男&#x2F;2001 本科&#x2F;上海开发大学 工作年限：3 年 技术博客：http://mistbollon.github.io Github：http://github.com/mistbollon 期望职位：Web 前端程序员 期望薪资：税前月薪 15k~20k，特别喜欢的公司可例外 期望城市：北京 工作经历（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组） ABC 公司 （ 2012 年 9 月 ~ 2014 年 9 月 ）DEF 项目我在此项目负责了哪些工作，分别在哪些地方做得出色&#x2F;和别人不一样&#x2F;成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写 2~3 个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） 开源项目和作品开源项目 STU：项目的简要说明，Star 和 Fork 数多的可以注明 WXYZ：项目的简要说明，Star 和 Fork 数多的可以注明 技能清单 Web 开发：PHP&#x2F;Hack&#x2F;Node Web 框架：ThinkPHP&#x2F;Yaf&#x2F;Yii&#x2F;Lavaral&#x2F;LazyPHP 前端框架：Bootstrap&#x2F;AngularJS&#x2F;EmberJS&#x2F;HTML5&#x2F;Cocos2dJS&#x2F;ionic 前端工具：Bower&#x2F;Gulp&#x2F;SaSS&#x2F;LeSS&#x2F;PhoneGap 数据库相关：MySQL&#x2F;PgSQL&#x2F;PDO&#x2F;SQLite 版本管理、文档和自动化部署工具：Svn&#x2F;Git&#x2F;PHPDoc&#x2F;Phing&#x2F;Composer 单元测试：PHPUnit&#x2F;SimpleTest&#x2F;Qunit 云和开放平台：SAE&#x2F;BAE&#x2F;AWS&#x2F;微博开放平台&#x2F;微信应用开发 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"这是分页标题","path":"/wiki/conduit/07-综合案例-conduit.html","content":"综合案例 - conduit"},{"title":"项目配置","path":"/wiki/React/支持 TypeScript 的 React 应用.html","content":"React+ Type Script 应用1.应用创建12create-react-app 项目名称 --template typescriptnpm start 2.配置路径别名 (使用@可以找到要导入的部分)配置路径别名分为两部分，第一部分是使 Vs Code 识别路径别名(代码提示)，第二部分是使 web pack 识别路径别名(编译代码)。 ① 在应用的根目录下创建 tsconfig.paths.json 文件用于扩展 TS 配置选项，当前用于配置路径别名。 12345678910111213141516&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@shared/*&quot;: [&quot;./src/shared/*&quot;], &quot;@pages/*&quot;: [&quot;./src/pages/*&quot;], &quot;@router/*&quot;: [&quot;./src/router/*&quot;], &quot;@store/*&quot;: [&quot;./src/store/*&quot;], &quot;@slice/*&quot;: [&quot;./src/store/slice/*&quot;], &quot;@service/*&quot;: [&quot;./src/store/service/*&quot;], &quot;@middlewares/*&quot;:[&quot;./src/store/middlewares/*&quot;], &quot;@styles/*&quot;: [&quot;./src/assets/styles/*&quot;], &quot;@images/*&quot;: [&quot;./src/assets/images/*&quot;] &#125; &#125;&#125; ② 在 tsconfig.json 文件中添加以下配置使用扩展配置文件生效 123&#123; &quot;extends&quot;: &quot;./tsconfig.paths.json&quot;&#125; ③ 覆盖 CRA 默认配置使 webpack 能够支持解析路径别名 1npm install react-app-rewired@2.2.1 react-app-alias@2.2.2 --save-dev 1234567// config-overrides.jsconst &#123; aliasWebpack &#125; = require(&quot;react-app-alias&quot;);module.exports = function override(config) &#123; aliasWebpack(&#123; tsconfig: &quot;./tsconfig.json&quot; &#125;)(config); return config;&#125;; 123456// package.json&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;,&#125;, 3.配置应用环境变量文件根目录创建.env 文件配置项目 API 接口地址 12# .env.developmentREACT_APP_BASE_URL=开发环境接口地址 12# .env.productionREACT_APP_BASE_URL=生产环境接口地址 VS Code 中添加 12345// settings.json&quot;files.associations&quot;: &#123; &quot;*.env.development&quot;: &quot;env&quot;, &quot;*.env.production&quot;: &quot;env&quot;&#125; 4.配置全局状态管理库① 在应用中下载 redux toolkit 和 react-redux 1npm install @reduxjs/toolkit@1.9.1 react-redux@8.0.5 ② 创建全局的 API 状态切片 12345678910// src/store/service/index.tsimport &#123; createApi, fetchBaseQuery &#125; from &quot;@reduxjs/toolkit/query/react&quot;;const apiService = createApi(&#123; reducerPath: &quot;apiReducer&quot;, baseQuery: fetchBaseQuery(&#123; baseUrl: process.env.REACT_APP_BASE_URL &#125;), endpoints: () =&gt; (&#123;&#125;),&#125;);export default apiService; ③ 创建 store 对象并配置 API 状态切片 123456789101112131415161718192021// src/store/index.tsimport &#123; configureStore &#125; from &quot;@reduxjs/toolkit&quot;;import apiService from &quot;@service/index&quot;;import &#123; useDispatch, TypedUseSelectorHook, useSelector &#125; from &quot;react-redux&quot;;const store = configureStore(&#123; devTools: process.env.NODE_ENV !== &quot;production&quot;, reducer: &#123; [apiService.reducerPath]: apiService.reducer, &#125;, middleware: (getDefaultMiddleware) =&gt; getDefaultMiddleware().concat([apiService.middleware]),&#125;);export default store;export type AppDispatch = typeof store.dispatch;export const useTypedDispatch = () =&gt; useDispatch&lt;AppDispatch&gt;();export type AppState = ReturnType&lt;typeof store.getState&gt;;export const useTypedSelector: TypedUseSelectorHook&lt;AppState&gt; = useSelector; ④ 配置 Provider 组件 123456789// src/index.tsximport &#123; Provider &#125; from &quot;react-redux&quot;;import store from &quot;@store/index&quot;;root.render( &lt;Provider store=&#123;store&#125;&gt; &lt;div&gt;App works&lt;/div&gt; &lt;/Provider&gt;); 5.配置路由管理库① 下载 react-router-dom 路由库 12# 该库自带 TypeScript 类型声明文件 不需要单独下载npm install react-router-dom@6.6.1 ② 创建登录页面路由组件用于测试路由是否配置成功 1234// src/pages/home/index.tsxexport default function HomePage() &#123; return &lt;div&gt;HomePage&lt;/div&gt;;&#125; ③ 创建 AppRouter 组件用于配置应用路由规则 1234567891011121314// src/router/index.tsximport HomePage from &quot;@pages/home&quot;;import &#123; createBrowserRouter, RouterProvider &#125; from &quot;react-router-dom&quot;;export const router = createBrowserRouter([ &#123; path: &quot;/&quot;, element: &lt;HomePage /&gt;, &#125;,]);export default function AppRouter() &#123; return &lt;RouterProvider router=&#123;router&#125; /&gt;;&#125; ④ 在应用入口文件中调用 AppRouter 组件使路由系统生效 12345678// src/index.tsximport AppRouter from &quot;@router/index&quot;;root.render( &lt;Provider store=&#123;store&#125;&gt; &lt;AppRouter /&gt; &lt;/Provider&gt;); 6.配置 CSS 预处理器 LESS1npm i less@4.1.3 less-loader@11.1.0 123456789101112// config-overrides.jsfunction addLessLoader(config) &#123; config.module.rules[1].oneOf.splice(2, 0, &#123; test: /\\.less$/i, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;);&#125;module.exports = function override(config) &#123; addLessLoader(config); return config;&#125;; 1234567891011121314151617// src/assets/styles/color.less// 主色@mainColor: #fc6627;// 文字颜色@textColor: #646566;// 文字辅助颜色@textHelperColor: #faab0c;// 边框色@borderColor: #ebedf0;// 成功色@successColor: #07c160;// 报错色@errorColor: #ee0a24;// 通知消息中的文本色@noticeTextColor: #ed6a0c;// 背景色@bgColor: #f8f8f8; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// src/assets/styles/base.less@import &quot;@styles/color.less&quot;;*,*::before,*::after &#123; box-sizing: border-box;&#125;* &#123; margin: 0;&#125;body &#123; -webkit-font-smoothing: antialiased; color: @textColor; font-size: 3.4667vw;&#125;img,picture,video,canvas,svg &#123; display: block; max-width: 100%;&#125;input,button,textarea,select &#123; font: inherit; outline: none; border: none; background: none; color: @textColor;&#125;p,h1,h2,h3,h4,h5,h6 &#123; overflow-wrap: break-word;&#125;ul &#123; padding: 0; list-style: none;&#125;a &#123; text-decoration: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125; 12// src/index.tsximport &quot;@styles/base.less&quot;; 7.解决移动端 1px 边框问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174// src/assets/styles/hairline.less@import &quot;./color&quot;;.scale-hairline-common(@color, @top, @right, @bottom, @left) &#123; content: &quot;&quot;; position: absolute; background-color: @color; display: block; z-index: 1; top: @top; right: @right; bottom: @bottom; left: @left;&#125;.hairline(@direction, @color: @borderColor) when (@direction = &quot;top&quot;) &#123; border-top: 1px solid @color; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; border-top: none; &amp;::before &#123; .scale-hairline-common(@color, 0, auto, auto, 0); width: 100%; height: 1px; transform-origin: 50% 50%; transform: scaleY(0.5); @media (min-resolution: 3dppx) &#123; transform: scaleY(0.33); &#125; &#125; &#125; &#125;&#125;.hairline(@direction, @color: @borderColor) when (@direction = &quot;right&quot;) &#123; border-right: 1px solid @color; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; border-right: none; &amp;::after &#123; .scale-hairline-common(@color, 0, 0, auto, auto); width: 1px; height: 100%; background: @color; transform-origin: 100% 50%; transform: scaleX(0.5); @media (min-resolution: 3dppx) &#123; transform: scaleX(0.33); &#125; &#125; &#125; &#125;&#125;.hairline(@direction, @color: @borderColor) when (@direction = &quot;bottom&quot;) &#123; border-bottom: 1px solid @color; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; border-bottom: none; &amp;::after &#123; .scale-hairline-common(@color, auto, auto, 0, 0); width: 100%; height: 1px; transform-origin: 50% 100%; transform: scaleY(0.5); @media (min-resolution: 3dppx) &#123; transform: scaleY(0.33); &#125; &#125; &#125; &#125;&#125;.hairline(@direction, @color: @borderColor) when (@direction = &quot;left&quot;) &#123; border-left: 1px solid @color; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; border-left: none; &amp;::before &#123; .scale-hairline-common(@color, 0, auto, auto, 0); width: 1px; height: 100%; transform-origin: 100% 50%; transform: scaleX(0.5); @media (min-resolution: 3dppx) &#123; transform: scaleX(0.33); &#125; &#125; &#125; &#125;&#125;.hairline(@direction, @color: @borderColor, @radius: 0) when (@direction = &quot;all&quot;) &#123; border: 1px solid @color; border-radius: @radius; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; position: relative; border: none; &amp;::before &#123; content: &quot;&quot;; position: absolute; left: 0; top: 0; width: 200%; height: 200%; border: 1px solid @color; border-radius: @radius * 2; transform-origin: 0 0; transform: scale(0.5); box-sizing: border-box; pointer-events: none; // @media (min-resolution: 3dppx) &#123; // width: 300%; // height: 300%; // border-radius: @radius * 3; // transform: scale(0.33); // &#125; &#125; &#125; &#125;&#125;.hairline-remove(@position) when (@position = &quot;left&quot;) &#123; border-left: 0; &amp;:before &#123; display: none !important; &#125;&#125;.hairline-remove(@position) when (@position = &quot;right&quot;) &#123; border-right: 0; &amp;:after &#123; display: none !important; &#125;&#125;.hairline-remove(@position) when (@position = &quot;top&quot;) &#123; border-top: 0; &amp;:before &#123; display: none !important; &#125;&#125;.hairline-remove(@position) when (@position = &quot;bottom&quot;) &#123; border-bottom: 0; &amp;:after &#123; display: none !important; &#125;&#125;.hairline-remove(@position) when (@position = &quot;all&quot;) &#123; border: 0; &amp;:before &#123; display: none !important; &#125;&#125; 1234567891011// src/pages/home/index.tsximport styles from &quot;./styles.module.less&quot;;export default function HomePage() &#123; return ( &lt;&gt; &lt;div className=&#123;styles.one&#125;&gt;&lt;/div&gt; &lt;div className=&#123;styles.two&#125;&gt;&lt;/div&gt; &lt;/&gt; );&#125; 12345678910111213// src/pages/home/styles.module.less@import &quot;@styles/hairline.less&quot;;.one &#123; border-bottom: 1px solid red; margin: 10px 0;&#125;.two &#123; /* 注意: 设置1像素边框的元素必须是相对定位的 */ position: relative; .hairline(&quot;bottom&quot;, green);&#125; 1234567// src/@types/less.d.tsdeclare module &quot;*.module.less&quot; &#123; const classes: &#123; readonly [key: string]: string; &#125;; export default classes;&#125;"}]