[{"title":"JavaScript面试题","path":"/面试题/JavaScript面试题/","content":"01. 变量赋值JavaScript 中的基本数据类型包括字符串、数值、布尔值、undefined、Symbol。 JavaScript 中的引用数据类型包括对象、数组、函数、null。 1234let m = 100;let n = m;m = 200;console.log(n); // ? 基本数据类型在进行变量赋值时采用的是复制值的方式，n &#x3D; m 其实就是将 m 变量的值 100 复制了一份给了变量 n，重新为 m 变量赋值时变量 n 不会受到影响，所以变量 n 的值依然是 100。 1234let p1 = &#123; age: 20 &#125;;let p2 = p1;p2.age = 21;console.log(p1.age); 123456789101112let m = 10;let n = 20;function display(m, n) &#123; m = 100; n = 200;&#125;display(m, n);console.log(m); // ?console.log(n); // ? 复杂数据类型在进行变量赋值时采用的是复制地址的方式，p2 &#x3D; p1 其实就是将变量 p1 对应的对象引用地址复制了一份给了变量 p2，此时 p1 变量和 p2 变量同时指向了同一个对象，所以无论是使用 p1 更改 age 还是使用 p2 更改 age，双方都会受到影响。 123456789const o1 = &#123; x: 100, y: 200,&#125;;const o2 = o1;let x = o1.x;o2.x = 101;x = 102;console.log(o1.x); 12345678let p = &#123; name: &quot;张三&quot; &#125;;function person(p) &#123; p.name = &quot;李四&quot;;&#125;person(p);console.log(p.name); // ? 在 JavaScript 中，var、let、const 有什么区别？ var、const、let 是 JavaScript 中用于声明变量的关键字，它们之间的主要区别在于作用域和是否可重新赋值。 var 声明的变量具有函数作用域（function scope），这意味着它们在整个函数体内都可见。 var 可以在任何时候重新赋值，也可以在声明之前使用（hoisted）。 12345678function testVar() &#123; console.log(foo); // 输出 &quot;undefined&quot;，因为 var 变量会提升（hoisted） var foo = &quot;Hello&quot;; console.log(foo); // 输出 &quot;Hello&quot; foo = &quot;World&quot;; console.log(foo); // 输出 &quot;World&quot;&#125;testVar(); let 声明的变量具有块级作用域（block scope），这意味着它们只在定义它们的代码块内可见。 let 可以在任何时候重新赋值，但不能在声明之前使用。 1234567891011121314function testLet() &#123; // console.log(bar); 在此时使用会报错，因为 let 变量不会提升 let bar = &quot;Hello&quot;; console.log(bar); // 输出 &quot;Hello&quot; bar = &quot;World&quot;; console.log(bar); // 输出 &quot;World&quot; &#123; let bar = &quot;Inside block&quot;; console.log(bar); // 输出 &quot;Inside block&quot;，因为这是一个新的作用域 &#125; console.log(bar); // 输出 &quot;World&quot;&#125;testLet(); const 用于声明一个常量，它具有与 let 相同的块级作用域，但在声明时必须初始化，且之后不能重新赋值。 12345678910111213function testConst() &#123; // console.log(baz); 在此时使用会报错，因为 const 变量不会提升 const baz = &quot;Hello&quot;; console.log(baz); // 输出 &quot;Hello&quot; // baz = &quot;World&quot;; // 如果尝试重新赋值，将会导致错误 &#123; const baz = &quot;Inside block&quot;; console.log(baz); // 输出 &quot;Inside block&quot;，因为这是一个新的作用域 &#125; console.log(baz); // 输出 &quot;Hello&quot;&#125;testConst(); 在现代 JavaScript 开发中，一般建议尽量使用 let 和 const，以避免因 var 变量提升和函数作用域可能导致的意外行为。 02. typeof 运算符typeof 运算符可以识别所有的基本数据类型、函数、可以识别是否是引用数据类型。 12345678910111213141516171819let str = &quot;Hello JavaScript&quot;;let m = 100;let isMarry = true;let unique = Symbol(&quot;unique&quot;);let n = undefined;function fn() &#123;&#125;let arr = [&quot;a&quot;, &quot;b&quot;];let obj = &#123; name: &quot;张三&quot; &#125;;let empty = null;console.log(typeof str); // &quot;string&quot;console.log(typeof m); // &quot;number&quot;console.log(typeof isMarry); // &quot;boolean&quot;console.log(typeof unique); // &quot;symbol&quot;console.log(typeof n); // &quot;undefined&quot;console.log(typeof fn); // &quot;function&quot;console.log(typeof arr); // &quot;object&quot;console.log(typeof obj); // &quot;object&quot;console.log(typeof null); // &quot;object&quot; 03. 深拷贝1234567891011121314151617181920function deepClone(target) &#123; // 如果要拷贝的数据不是引用数据类型或要拷贝的数据为 null // 表示不需要深拷贝, 直接返回该数据即可 if (typeof target !== &quot;object&quot; || target === null) return target; // 创建新的变量用于保存拷贝结果 区分要拷贝的数据是数组还是对象 let result = target instanceof Array ? [] : &#123;&#125;; // 遍历要拷贝的数据 for (let key in target) &#123; // 拷贝时排除原型对象中的属性 if (target.hasOwnProperty(key)) &#123; // 递归拷贝 result[key] = deepClone(target[key]); &#125; &#125; // 返回拷贝结果 return result;&#125;function clone(target) &#123; if (typeof target !== &quot;object&quot; || target === null) return target;&#125; 123456789101112let obj1 = &#123; a: 1, p: &#123; name: &quot;张三&quot;, &#125;,&#125;;let obj2 = deepClone(obj1);console.log(obj1 === obj2);console.log(obj2);obj2.p.name = &quot;李四&quot;;console.log(obj1.p.name); 编写一个方法用于比较两个对象是否深度相等。 在 JavaScript 中，可以使用递归方法来实现深度比较两个对象是否相等。 123456789101112131415161718192021222324252627282930313233function isEqual(obj1, obj2) &#123; if (obj1 === obj2) &#123; return true; &#125; if ( typeof obj1 !== &quot;object&quot; || typeof obj2 !== &quot;object&quot; || obj1 === null || obj2 === null ) &#123; return false; &#125; const keys1 = Object.keys(obj1); const keys2 = Object.keys(obj2); if (keys1.length !== keys2.length) &#123; return false; &#125; for (const key of keys1) &#123; if (!keys2.includes(key)) &#123; return false; &#125; if (!isEqual(obj1[key], obj2[key])) &#123; return false; &#125; &#125; return true;&#125; 这个 isEqual 方法首先比较两个对象的引用是否相等，如果相等则返回 true。然后，检查两个对象是否都是对象类型，如果不是，则返回 false。接下来，比较两个对象的键的数量，如果不相等，则返回 false。最后，使用递归方法逐个比较键值，如果存在不相等的键值，则返回 false。如果所有键值都相等，则返回 true。 04. 数据类型转换规则① 其他类型的值转换为字符串 12345678910111213141516String(null); // &quot;null&quot;String(undefined); // &quot;undefined&quot;String(true); // &quot;true&quot;String(false); // &quot;false&quot;String(10); // &quot;10&quot;// 数组转为字符串是将数组中的所有元素按照 &quot;,&quot; 连接起来// 相当于调用数组的 Array.prototype.join(&quot;,&quot;) 方法// 如 [1, 2, 3] 转为 &quot;1,2,3&quot;// 空数组 [] 转为空字符串// 数组中的 null 或 undefined, 会被当做空字符串处理String([1, 2, 3]); // &quot;1,2,3&quot;String([]); // &quot;&quot;String([null]); // &quot;&quot;String([1, undefined, 3]); // &quot;1,,3&quot;// 普通对象转为字符串相当于直接使用 Object.prototype.toString() 方法String(&#123;&#125;); // &quot;[object Object]&quot; ② 其他类型的值转换为数值 123456789101112Number(null); // 0Number(undefined); // NaNNumber(&quot;10&quot;); // 10Number(&quot;10px&quot;); // NaNNumber(&quot;&quot;); // 0Number(true); // 1Number(false); // 0// 数组会先被转换为原始类型, 然后再将转换后的原始类型转换为数值类型Number([]); // 0Number([&quot;10&quot;]); // 10Number([&quot;10&quot;, &quot;20&quot;]); // NaNNumber(&#123;&#125;); // NaN ③ 其他类型转换为布尔值 12345678Boolean(null); // falseBoolean(undefined); // falseBoolean(&quot;&quot;); // falseBoolean(NaN); // falseBoolean(0); // falseBoolean([]); // trueBoolean(&#123;&#125;); // trueBoolean(Infinity); // true ④ 对象、数组转换为原始类型 当对象类型需要被转为原始类型时，它会先查找对象的 valueOf 方法，如果 valueOf 方法返回原始类型的值，就使用这个值作为转换结果。 如果 valueOf 方法返回的不是原始类型的值，尝试调用对象的 toString 方法，使用该方法的返回值作为转换结果。 valueOf 方法用于返回对象的原始类型，一般由系统自动调用。 12345678// 创建字符串对象let strObject = new String(&quot;Hello&quot;);// 输出字符串对象strObject; // String &#123; 0: &quot;H&quot;, 1: &quot;e&quot;, 2: &quot;l&quot;, 3: &quot;l&quot;, 4: &quot;o&quot; &#125;// 输出它字符串对象的类型typeof strObject; // &quot;object&quot;// 获取字符串对象 strObject 的原始值strObject.valueOf(); // &quot;Hello&quot; 12345let object = &#123;&#125;;let array = [];object.valueOf(); // &#123;&#125;console.log(array.valueOf()); // [] 123456789let object = &#123;&#125;;let array = [];Object.prototype.valueOf = function () &#123; return 100;&#125;;console.log(object.valueOf()); // 100console.log(array.valueOf()); // 100 1234// 将数组转换为数值类型// 系统会先调用数组下的 valueOf 方法, 但是当前 valueOf 方法返回的就是数组, 所以系统去调用 toString 方法// toString 方法调用之后返回了一个空字符串, 将空字符串转换为数值会得到 0Number([]); 1234// 在以下运算式中由于 + 号两边都不是数值, 所以要进行字符串连接操作// 系统会先调用对象下的 valueOf 方法, 但是当前 valueOf 方法返回的就是对象, 所以系统去调用 toString 方法// toString 方法调用后返回了 &#x27;[object Object]&#x27;, 所以最终连接的结果就是 &#x27;[object Object][object Object]&#x27;(&#123;&#125;) + &#123;&#125;; 05. 宽松比较中的隐式转换在 JavaScript 中宽松比较会发生隐式类型转换，严格比较不会发生隐式类型转换。 ① 布尔类型和其他类型的相等比较 布尔类型的值在参数比较时值会被转换为数值类型，true 转换为 1，false 转换为 0 123false == 0; // truetrue == 1; // truetrue == 2; // false 1234const x = 10;if (x == true) &#123; console.log(x); // ? 是否会被输出&#125; ② 数值类型和字符串类型的相等比较 当数值类型和字符串类型做相等比较时，字符串类型会被转换为数值类型。 如果字符串为数值字符串，则将其转换为对应的数值，如果是空字符串转换为 0，其他一律转换为 NaN。 NaN 和任何值比较都不相等，包括它自己。 123450 == &quot;&quot;; // true1 == &quot;1&quot;; // truetrue == &quot;1&quot;; // truefalse == &quot;0&quot;; // truefalse == &quot;&quot;; // true ③ 对象类型和原始类型的相等比较 当对象类型和原始类型做相等比较时，对象类型要被转换为原始类型。 12&quot;[object Object]&quot; == &#123;&#125;; // true&quot;1,2,3&quot; == [1, 2, 3]; // true 1234// 在以下比较中, 数组需要被转换为原始类型, 系统先调用 valueOf 方法, 但返回值不是原始值// 系统继续调用 toString 方法, 得到 &quot;2&quot;// &quot;2&quot; == 2 比较, 字符串会被转换为数值 2, 所以 2 == 2 比较, 得到的结果是 true[2] == 2; 123[null] == 0 // true[undefined] == 0 // true[] == 0 // true 1234// &quot;&quot; == false// &quot;&quot; == 0// 0 == 0[] == ![]; // true 1234// &quot;[object Object]&quot; == false// &quot;[object Object]&quot; == 0// NaN == 0&#123;&#125; == !&#123;&#125; // false 123// 当两个操作数都是对象时，JavaScript 会比较其内存中的引用地址[] == []&#123;&#125; == &#123;&#125; ④ null、undefined 和其他类型的比较 null 和 undefined 宽松相等的结果为 true，null 和 null 相等，undefined 和 undefined 相等。 null 和 undefined 和其他值比较时都不相等。 null 和 undefined 都是假值。 123null == undefined; // truenull == false; // falseundefined == false; // false 总结：在日常工作中进行相等比较时一律使用严格比较避免隐式类型转换产生的不可预知问题。 只有一种情况除外，当我们要判断对象中是否存在某一个属性时，可以使用宽松比较。 如果一个对象中的属性的值是 null 或是 undefined，我们都认为这个属性是不存在的。 123456789const object = &#123; x: 100,&#125;;// 因为 x 无论是 null 还是 undefined, 和 null 进行比较时都会相等if (object.x == null) &#123; console.log(&quot;不存在&quot;);&#125; else &#123; console.log(&quot;存在&quot;);&#125; 06. 运算中的隐式转换在使用 + - * &#x2F; 进行运算时，数据类型会发生隐式类型转换。 + 号两边只要有一个运算数是字符串类型，其他运算数都会被转换成字符串类型。 除了 + 号以外的其他运算符，比如 - * &#x2F; 等都会将运算数转换为数值类型。 + 作为正号使用会将运算数转换为数值类型。 123&quot;11&quot; + 11;&quot;11&quot; - 11;11 + +&quot;11&quot;; 07. 原型对象基本使用在 JavaScript 中每一个构造函数都会配备一个名字叫做 prototype 的对象，我们称它为原型对象。 原型对象的作用是为了在实例对象之间进行属性共享。 1234// Person 构造函数function Person() &#123;&#125;// Person 构造函数的原型对象console.log(Person.prototype); 12345678910111213141516171819202122// Person 构造函数function Person(name) &#123; this.name = name;&#125;// 在 Person 构造函数的原型对象中添加 sayHello 方法// 所有通过 Person 构造函数创建出来的实例对象都可以调用该方法Person.prototype.sayHello = function () &#123; alert(`Hello, 我是$&#123;this.name&#125;`);&#125;;// 创建 p1 实例const p1 = new Person(&quot;张三&quot;);// 创建 p2 实例const p2 = new Person(&quot;李四&quot;);// 验证 p1 实例是否可以调用 sayHello 方法p1.sayHello();// 验证 p2 实例是否可以调用 sayHello 方法p2.sayHello();// 验证 p1 和 p2 调用的是否是同一个 sayHello 方法alert(p1.sayHello === p2.sayHello); 实例对象在查找属性时，先在自身进行查找，自身如果找不到再去构造函数的原型对象中查找。 123456p1.sayHello = function () &#123; alert(`Hello, 我是$&#123;this.name&#125;, 我是实例对象自身身上的 sayHello 方法`);&#125;;p1.sayHello();p2.sayHello(); 在实例对象身上有一个属性叫做 __proto__，它指向了实例的构造函数的原型对象，实例对象在查找属性时就是通过它找到的原型对象。 1alert(p1.__proto__ === Person.prototype); __proto__ 被称之为隐式原型对象，实例会自动通过它去原型对象中查找，开发者不需要显式的去调用它。 1alert(p2.sayHello === p2.__proto__.sayHello); 在每一个原型对象中都会有一个名字叫做 constructor 的属性，该属性指向了构造函数。 12alert(Person.prototype.constructor === Person);alert(p1.constructor === Person); 08. 原型对象进阶Person.prototype 对象是 Object 构造函数的实例。 12// 以下代码不需要开发者编写Person.prototype = new Object(); 123// 此处 p1 调用的 hasOwnProperty 方法以及 toString 方法均来自 Object 构造函数的原型对象alert(p1.hasOwnProperty(&quot;name&quot;));alert(p1.toString()); 12345function Person() &#123;&#125;let p1 = new Person();p1.__proto__ === Person.prototype; // truePerson.prototype.__proto__ === Object.prototype; // trueObject.prototype.__proto__ === null; // true 1234function Person() &#123;&#125;Person.__proto__ === Function.prototype; // trueFunction.prototype.__proto__ === Object.prototype; // trueObject.prototype.__proto__ === null; // true 09. 继承123456789function Person(name) &#123; this.name = name;&#125;function Student(name, number) &#123; this.number = number;&#125;const s1 = new Student(&quot;张三&quot;, 01); 12345678function Student(name, number) &#123; // 继承父类实例属性 Person.call(this, name);&#125;// 继承父类原型属性Student.prototype.__proto__ = Person.prototype;const s1 = new Student(&quot;张三&quot;, 01); 123456789101112131415161718192021222324// ES6 语法糖class Person &#123; constructor(name) &#123; this.name = name; &#125; sayHello() &#123; console.log(`Hello, 我是$&#123;this.name&#125;`); &#125;&#125;class Student extends Person &#123; constructor(name, number) &#123; super(name); this.number = number; &#125; sayNumber() &#123; console.log(`我是$&#123;this.name&#125;, 我的学号是$&#123;this.number&#125;`); &#125;&#125;console.log(typeof Person); // &quot;function&quot;const tom = new Student(&quot;Tom&quot;, 1);tom.sayHello();tom.sayNumber(); 10. instanceofinstanceof 运算符用于检查对象的类型，它返回一个布尔值，如果为真则表示该对象是特定类的实例，如果为假则不是。 123tom instanceof Student; // truetom instanceof Person; // truetom instanceof Object; // true 123[] instanceof Array // true[] instanceof Object // true&#123;&#125; instanceof Object // true 11. 作用域作用域是指变量和函数的可访问范围。 JavaScript 中有全局作用域、局部作用域和块级作用域。 (1) 全局作用域 在全局作用域中声明的变量和函数可以在代码中的任何位置被访问。 12345678910111213141516// 全局作用域中声明变量var globalVariable = &quot;global variable&quot;;// 全局作用域中声明函数function globalFunction() &#123; console.log(&quot;global function&quot;);&#125;// 在函数中访问全局变量和函数function myFunction() &#123; console.log(globalVariable); globalFunction();&#125;// 输出：global variable 和 global functionmyFunction(); (2) 局部作用域 局部作用域是指在函数内部声明的变量和函数，只能在函数内部访问。 123456789101112131415function myFunction() &#123; // 在函数内部声明局部变量 var localVariable = &quot;local variable&quot;; // 在函数内部声明局部函数 function localFunction() &#123; console.log(&quot;local function&quot;); &#125; console.log(localVariable); localFunction();&#125;myFunction(); // 输出：local variable 和 local functionconsole.log(localVariable); // 报错：localVariable is not defined (3) 块级作用域 块级作用域是指在 if、for、while 等语句中产生的作用域，在其中声明的变量和函数只在该代码块内部有效。 在 ES6 中使用关键字 let 和 const 声明的变量具有块级作用域。 1234567// 使用 let 和 const 声明变量具有块级作用域if (true) &#123; let x = 1; const y = 2;&#125;console.log(x); // 报错：x is not definedconsole.log(y); // 报错：y is not defined 123456789var a = 100;function print(fn) &#123; var a = 200; fn();&#125;function fn() &#123; console.log(a);&#125;print(fn); 12345for (var i = 1; i &lt;= 3; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 0);&#125; 12345for (let i = 1; i &lt;= 3; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 0);&#125; 12345678console.log(a);var a = 12;function fn() &#123; console.log(a); var a = 13;&#125;fn();console.log(a); 12345678console.log(a);var a = 12;function fn() &#123; console.log(a); a = 13;&#125;fn();console.log(a); 12345678console.log(a);a = 12;function fn() &#123; console.log(a); a = 13;&#125;fn();console.log(a); 12345678var foo = 1;function bar() &#123; if (!foo) &#123; var foo = 10; &#125; console.log(foo);&#125;bar(); 12345678910var foo = 1;function bar() &#123; // 不管条件是否成立都会进行变量提升 var foo = undefined; // if (!undefined) =&gt; 将 undefined 转换为布尔值再取反 !false =&gt; true if (!foo) &#123; var foo = 10; &#125; console.log(foo);&#125;bar(); 123456789101112131415var a = 10, b = 11, c = 13;function test(a) &#123; a = 1; var b = 2; c = 3;&#125;test(10);console.log(a);console.log(b);console.log(c); 1234if (!(&quot;a&quot; in window)) &#123; var a = 10;&#125;console.log(a); 1234567891011var a = 4;function b(x, y, a) &#123; console.log(a); // 在 JS 非严格模式下实参集合与形参变量存在映射关系, 严格模式下该关系比切断了 arguments[2] = 10; console.log(a);&#125;a = b(1, 2, 3);console.log(a); 1234567var foo = &quot;hello&quot;;(function (foo) &#123; console.log(foo); var foo = foo || &quot;world&quot;; console.log(foo);&#125;)(foo);console.log(foo); 12. 闭包闭包就是一个函数，一个引用了上级作用域链中的变量的函数，即使外部函数已不存在，也可以通过作用域链访问到外部函数中声明的变量。 123456789function outer() &#123; var testVar = &quot;test&quot;; return function () &#123; console.log(testVar); &#125;;&#125;var inner = outer();inner(); 使用闭包实现模块化开发 1234567891011121314151617var module = (function () &#123; var privateVar = &quot;这个变量是私有的&quot;; function privateFunction() &#123; console.log(&quot;私有函数&quot;); &#125; return &#123; publicVar: &quot;这个变量是公开的&quot;, publicFunction: function () &#123; console.log(&quot;公开函数&quot;); &#125;, &#125;;&#125;)();console.log(module.publicVar);module.publicFunction(); 使用闭包实现计数器功能 1234567891011function counter() &#123; var count = 0; return function () &#123; count++; console.log(count); &#125;;&#125;var countFunc = counter();countFunc(); // 1countFunc(); // 2 使用闭包实现缓存功能 12345678910111213141516function cache() &#123; var results = &#123;&#125;; return function (key, val) &#123; if (results[key]) &#123; return results[key]; &#125; else &#123; results[key] = val; return val; &#125; &#125;;&#125;var getResults = cache();console.log(getResults(&quot;a&quot;, 1)); // 1console.log(getResults(&quot;a&quot;, 2)); // 1console.log(getResults(&quot;b&quot;, 2)); // 2 使用闭包实现一次性函数 123456789101112131415function singleUse() &#123; var isUsed = false; return function () &#123; if (!isUsed) &#123; console.log(&quot;执行一次&quot;); isUsed = true; &#125; else &#123; console.log(&quot;无法执行！&quot;); &#125; &#125;;&#125;var useFunc = singleUse();useFunc(); // 执行一次useFunc(); // 无法执行！ 面试题 1234567891011121314var n = 0;function a() &#123; var n = 10; function b() &#123; n++; console.log(n); &#125; b(); return b;&#125;var c = a();c();console.log(n); 13. thisJavaScript 中的 this 是一个指向当前执行环境的关键字，用来访问当前执行环境的上下文。 this 具体指向的对象要取决于当前调用方式。 (1) 默认绑定：函数调用时没有明确指定 this 的指向，或者使用的是独立的函数调用方式时，this 会绑定到全局对象上。 1234function test() &#123; console.log(this);&#125;test(); // Window (浏览器) / global (Node.js) (2) 隐式绑定：函数作为对象的属性调用时，this 会绑定到该对象。 1234567const obj = &#123; name: &quot;Alice&quot;, sayName() &#123; console.log(this.name); &#125;,&#125;;obj.sayName(); // Alice (3) 显式绑定：使用 apply、call、bind 等函数显式调用时，可以指定 this 的指向。 123456789function greet() &#123; console.log(`Hello, $&#123;this.name&#125;!`);&#125;const person1 = &#123; name: &quot;Alice&quot; &#125;;const person2 = &#123; name: &quot;Bob&quot; &#125;;greet.call(person1); // Hello, Alice!greet.apply(person2); // Hello, Bob!const boundGreet = greet.bind(person1); // bind 方法返回一个新函数boundGreet(); // Hello, Alice! (4) new 绑定：使用 new 关键字创建对象时，this 会绑定到新创建的对象上。 12345function Person(name) &#123; this.name = name;&#125;const person = new Person(&quot;Alice&quot;);console.log(person.name); // Alice (5) 箭头函数：箭头函数没有自己的 this 绑定，会继承上一层作用域中的 this。 1234567const obj = &#123; name: &quot;Alice&quot;, logMyName: () =&gt; &#123; console.log(this.name); &#125;,&#125;;obj.logMyName(); // undefined 需要注意的是，箭头函数中的 this 不可以被显式地绑定或修改，因为箭头函数根本没有自己的 this。 14. 手写 bind 方法12345678910111213141516171819202122232425// 创建一个自定义的bind函数Function.prototype.myBind = function (context) &#123; // 保存调用 myBind() 函数的函数对象 var fn = this; // 获取 myBind() 函数调用时传入的参数，不包括第一个参数（即需要绑定的 this 值或上下文对象） var args = Array.prototype.slice.call(arguments, 1); // 返回一个新函数 return function () &#123; // 获取新函数调用时的参数 var newArgs = Array.prototype.slice.call(arguments); // 将新函数的参数和调用myBind()函数时传入的参数合并 var allArgs = args.concat(newArgs); // 返回调用原函数时的结果 return fn.apply(context, allArgs); &#125;;&#125;;/* 上述代码首先在 Function.prototype 上添加了一个 myBind 方法，以实现自定义的 bind 方法。 当我们使用 myBind() 函数的时候，需要传入一个上下文对象（即需要绑定的 this 值）， 以及可以传入一系列参数，稍后会与新函数的参数合并。在myBind()函数中，先将调用myBind() 函数的原函数对象保存下来，并获取传入myBind()函数的参数数组，去除第一个参数（即上下文对象）。然后返回一个新函数， 新函数的作用是将调用新函数的参数与新函数之前已经传入myBind()函数中的参数合并起来，再通过 apply() 方法来调用原函数， 同时将上下文对象和所有参数传递给apply()方法，确保原函数能够正确的使用上下文和参数。*/ 15. 获取元素索引123456789101112131415161718192021&lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 获取 ul var ul = document.getElementById(&quot;ul&quot;); // 获取 ul 的所有子元素 var lis = ul.children; // 获取 ul 子元素的个数 var length = lis.length; // 遍历所有 li for (var i = 0; i &lt; length; i++) &#123; // 为 li 添加点击事件 lis[i].onclick = function () &#123; // 弹出 i 的值 alert(i); &#125;; &#125;&lt;/script&gt; 12// 解决办法一: 使用 let 关键字声明变量 i, 使其产生块级作用域for (let i = 0; i &lt; length; i++) &#123;&#125; 12345678910// 解决办法二: 使用闭包使局部变量 i 不销毁for (var i = 0; i &lt; length; i++) &#123; (function (i) &#123; // 为 li 添加点击事件 lis[i].onclick = function () &#123; // 弹出 i 的值 alert(i); &#125;; &#125;)(i);&#125; 16. 同步和异步在 JavaScript 中，同步和异步是指代码的执行方式。 同步代码会按照代码的书写顺序一行一行地执行，每行代码必须等待前一行代码执行完成后才能执行。 在同步代码中如果某个操作需要执行的时间较长，代码的执行会被阻塞，直到操作完成才能继续执行下一行代码。 异步代码则是在某些代码执行完成前(ajax 请求、定时器等) ，允许继续执行其他的代码。 异步代码的执行结果不会立即得到，异步操作完成后再通过回调函数获取执行结果。 1234// 同步代码console.log(&quot;Step 1&quot;);console.log(&quot;Step 2&quot;);console.log(&quot;Step 3&quot;); 123Step 1Step 2Step 3 123456// 异步代码console.log(&quot;Step 1&quot;);setTimeout(function () &#123; console.log(&quot;Step 2&quot;);&#125;, 1000);console.log(&quot;Step 3&quot;); 123Step 1Step 3Step 2 JavaScript 是单线的，这意味着它只能在一个时间点执行一个任务，无法同时执行多个任务。 如果某一个任务的执行需要耗费比较长的时间，那么程序将会被卡住，所以异步应运而生。 123456789console.log(1);setTimeout(() =&gt; &#123; console.log(2);&#125;, 1000);console.log(3);setTimeout(() =&gt; &#123; console.log(4);&#125;, 0);console.log(5); 17. JavaScript 运行原理(1) JavaScript 为单线程语言 JavaScript 是单线程语言，这意味着 JavaScript 在同一个时间点只能执行一项任务，该项任务未完成之前其他任务需要等待。 123456789101112console.log(&quot;开始任务&quot;);// 同步任务function sleep(ms) &#123; const start = new Date().getTime(); while (new Date().getTime() &lt; start + ms) &#123;&#125;&#125;sleep(2000);console.log(&quot;同步任务完成&quot;);console.log(&quot;结束任务&quot;); (2) JavaScript 是如何实现异步的? 既然 JavaScript 是单线程的，那么它是怎样实现非阻塞(异步)的呢? 上面我们所说的 JavaScript 指的是 EcmaScript，所有 EcmaScript 代码都在同一个线程中执行，这个单线程通常我们称它为主线程。 但是当 JavaScript 在浏览器中运行时，它不仅包含了 EcmaScript 还包含了浏览器提供的 web API，比如 window、document、setInterval、fetch 等，浏览器提供的 web API 不能在主线程中执行，浏览器提供了另外的线程供它们执行。 所以更加准确的说，JavaScript 本身可以只在一个线程中执行，但是运行在浏览器中的 JavaScript 由多个线程共同的执行。 123console.log(&quot;Learning&quot;);console.log(&quot;About&quot;);console.log(&quot;The Event Loop&quot;); 1234const recursion = () =&gt; &#123; recursion();&#125;;recursion(); 123console.log(&quot;🐹&quot;);setTimeout(() =&gt; console.log(&quot;🐹🐹&quot;), 0);console.log(&quot;🐹🐹🐹&quot;); 12345// 如果调用堆栈为空并且任务队列中有待执行任务// 依次将任务函数移动到调用堆栈中执行if (callStack.isEmpty &amp;&amp; taskQueue.length) &#123; eventLoop();&#125; (3) 宏任务与微任务 宏任务包括 script（整体代码），setTimeout, setInterval, setImmediate, requestAnimationFrame 等。 微任务包括 Promise.then&#x2F;catch&#x2F;finally、process.nextTick (NodeJS)、MutationObserver 等。 微任务执行的优先级高于宏任务，因为微任务都是 ECMAScript，宏任务都是 WebAPI。 123456789101112131415console.log(&quot;开始执行&quot;);setTimeout(() =&gt; &#123; console.log(&quot;setTimeout&quot;);&#125;, 0);Promise.resolve() .then(() =&gt; &#123; console.log(&quot;Promise 1&quot;); &#125;) .then(() =&gt; &#123; console.log(&quot;Promise 2&quot;); &#125;);console.log(&quot;结束执行&quot;); 18. PromiseJavaScript 的异步编程中最常见的问题之一就是回调地狱。 即一个异步操作完成后，需要执行另一个异步操作，而这个异步操作完成后又需要执行另一个异步操作，如此往复嵌套下去，代码变得十分冗长和难以维护。 123456789getData(function (data1) &#123; getMoreData(data1, function (data2) &#123; getMoreData(data2, function (data3) &#123; getMoreData(data3, function (data4) &#123; // 继续嵌套下去... &#125;); &#125;); &#125;);&#125;); 为了避免回调地狱的问题，我们可以使用 Promise 来简化异步调用链。 123456getData() .then((data1) =&gt; getData(data1)) .then((data2) =&gt; getData(data2)) .then((data3) =&gt; getData(data3)) .then((data4) =&gt; getData(data4)) .catch((error) =&gt; &#123;&#125;); Promise 解决回调地狱问题，它是一种用于异步编程的语法结构，可以使异步操作变得更加简单、易读和可维护。 12345678910111213141516171819function getData(url) &#123; return new Promise((resolve, reject) =&gt; &#123; let xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.onload = function () &#123; if (xhr.status === 200) &#123; resolve(xhr.response); &#125; else &#123; reject(Error(&quot;请求失败，错误码：&quot; + xhr.statusText)); &#125; &#125;; xhr.onerror = () =&gt; reject(Error(&quot;网络请求错误&quot;)); xhr.send(); &#125;);&#125;getData(&quot;https://jsonplaceholder.typicode.com/todos/1&quot;) .then((response) =&gt; console.log(&quot;成功获取数据：&quot;, response)) .catch((error) =&gt; console.error(&quot;获取数据失败：&quot;, error)); 封装 loadImage 方法使用 Promise 加载图片。 12345678910111213141516171819202122function loadImage(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const img = new Image(); img.onload = () =&gt; resolve(img); img.onerror = (err) =&gt; reject(err); img.src = url; &#125;);&#125;// https://img95.699pic.com/photo/50046/5562.jpg_wh300.jpg// https://img95.699pic.com/photo/50136/1351.jpg_wh300.jpg// 使用方法loadImage(&quot;https://img95.699pic.com/photo/50136/1351.jpg_wh300.jpg&quot;) .then((img) =&gt; &#123; // 加载成功 console.log(&quot;Image loaded&quot;); &#125;) .catch((err) =&gt; &#123; // 加载失败 console.error(err); &#125;); 题一：Promise 的基本用法是什么？如何使用 Promise 处理异步操作？ 答：Promise 是用于异步编程的一种解决方案，它可以更加优雅和可读地处理异步操作。Promise 有三种状态：Pending（等待态）、Resolved（成功态）和 Rejected（失败态）。在 Promise 构造函数中，可以传入一个 executor（执行器）函数，该函数接受两个参数，resolve 和 reject，代表 Promise 的成功和失败。在 executor 函数中，我们可以执行异步操作，并在操作成功或失败时调用相应的回调函数，例如： 1234567891011121314151617const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (Math.random() &gt; 0.5) &#123; resolve(&quot;success&quot;); &#125; else &#123; reject(&quot;failure&quot;); &#125; &#125;, 1000);&#125;);promise .then((result) =&gt; &#123; console.log(&quot;Promise resolved: &quot; + result); &#125;) .catch((error) =&gt; &#123; console.log(&quot;Promise rejected: &quot; + error); &#125;); 题二：如何使用 Promise.all 处理多个异步操作？ 答：Promise.all 方法接受一个 Promise 对象数组作为参数，将返回一个新的 Promise 对象。只有当数组中所有 Promise 对象都成功时，该 Promise 对象才会被 resolved；如果数组中任一个 Promise 对象失败，该 Promise 对象立即被 rejected，并返回失败的原因。 12345678910111213const promises = [ new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;a&quot;), 1000)), new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;b&quot;), 2000)), new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;c&quot;), 3000)),];Promise.all(promises) .then((results) =&gt; &#123; console.log(&quot;Promise.all resolved: &quot; + results); &#125;) .catch((error) =&gt; &#123; console.log(&quot;Promise.all rejected: &quot; + error); &#125;); 题三：如何使用 Promise.race 处理多个异步操作？ 答：Promise.race 方法接受一个 Promise 对象数组作为参数，将返回一个新的 Promise 对象。只要有一个 Promise 对象率先改变状态，该 Promise 对象就会采用第一个率先改变状态的 Promise 对象的状态。 12345678910111213const promises = [ new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;a&quot;), 1000)), new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;b&quot;), 2000)), new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(&quot;c&quot;), 3000)),];Promise.race(promises) .then((result) =&gt; &#123; console.log(&quot;Promise.race resolved: &quot; + result); &#125;) .catch((error) =&gt; &#123; console.log(&quot;Promise.race rejected: &quot; + error); &#125;); 题四：说出输出结果。 12345678910Promise.resolve() .then(() =&gt; &#123; console.log(1); &#125;) .catch(() =&gt; &#123; console.log(2); &#125;) .then(() =&gt; &#123; console.log(3); &#125;); 1234567891011Promise.resolve() .then(() =&gt; &#123; console.log(1); throw new Error(); &#125;) .catch(() =&gt; &#123; console.log(2); &#125;) .then(() =&gt; &#123; console.log(3); &#125;); 1234567891011Promise.resolve() .then(() =&gt; &#123; console.log(1); throw new Error(); &#125;) .catch(() =&gt; &#123; console.log(2); &#125;) .catch(() =&gt; &#123; console.log(3); &#125;); 12345678const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1); console.log(2);&#125;);promise.then(() =&gt; &#123; console.log(3);&#125;);console.log(4); 123456789const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1); resolve(&quot;success&quot;); console.log(2);&#125;);promise.then(() =&gt; &#123; console.log(3);&#125;);console.log(4); 123456789const promise1 = new Promise((resolve, reject) =&gt; &#123; console.log(0); resolve(3);&#125;);const promise2 = promise1.then((res) =&gt; &#123; console.log(res);&#125;);console.log(1);console.log(2); 123456789const fn = () =&gt; new Promise((resolve, reject) =&gt; &#123; console.log(1); resolve(&quot;success&quot;); &#125;);fn().then((res) =&gt; &#123; console.log(res);&#125;);console.log(&quot;start&quot;); 12345678console.log(&quot;start&quot;);setTimeout(() =&gt; &#123; console.log(&quot;time&quot;);&#125;);Promise.resolve().then(() =&gt; &#123; console.log(&quot;resolve&quot;);&#125;);console.log(&quot;end&quot;); 12345678910111213const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1); setTimeout(() =&gt; &#123; console.log(&quot;timerStart&quot;); resolve(&quot;success&quot;); console.log(&quot;timerEnd&quot;); &#125;, 0); console.log(2);&#125;);promise.then((res) =&gt; &#123; console.log(res);&#125;);console.log(4); 12345678910setTimeout(() =&gt; &#123; console.log(&quot;timer1&quot;); setTimeout(() =&gt; &#123; console.log(&quot;timer3&quot;); &#125;, 0);&#125;, 0);setTimeout(() =&gt; &#123; console.log(&quot;timer2&quot;);&#125;, 0);console.log(&quot;start&quot;); 12345678910setTimeout(() =&gt; &#123; console.log(&quot;timer1&quot;); Promise.resolve().then(() =&gt; &#123; console.log(&quot;promise&quot;); &#125;);&#125;, 0);setTimeout(() =&gt; &#123; console.log(&quot;timer2&quot;);&#125;, 0);console.log(&quot;start&quot;); 12345678910111213Promise.resolve().then(() =&gt; &#123; console.log(&quot;promise1&quot;); const timer2 = setTimeout(() =&gt; &#123; console.log(&quot;timer2&quot;); &#125;, 0);&#125;);const timer1 = setTimeout(() =&gt; &#123; console.log(&quot;timer1&quot;); Promise.resolve().then(() =&gt; &#123; console.log(&quot;promise2&quot;); &#125;);&#125;, 0);console.log(&quot;start&quot;); 1234567891011121314const promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;success&quot;); &#125;, 1000);&#125;);const promise2 = promise1.then(() =&gt; &#123; throw new Error(&quot;error!!!&quot;);&#125;);console.log(&quot;promise1&quot;);console.log(&quot;promise2&quot;);setTimeout(() =&gt; &#123; console.log(&quot;promise1&quot;); console.log(&quot;promise2&quot;);&#125;, 2000); 123456789101112const promise = new Promise((resolve, reject) =&gt; &#123; resolve(&quot;success1&quot;); reject(&quot;error&quot;); resolve(&quot;success2&quot;);&#125;);promise .then((res) =&gt; &#123; console.log(&quot;then: &quot;, res); &#125;) .catch((err) =&gt; &#123; console.log(&quot;catch: &quot;, err); &#125;); 1234567891011121314151617const promise = new Promise((resolve, reject) =&gt; &#123; reject(&quot;error&quot;); resolve(&quot;success2&quot;);&#125;);promise .then((res) =&gt; &#123; console.log(&quot;then1: &quot;, res); &#125;) .then((res) =&gt; &#123; console.log(&quot;then2: &quot;, res); &#125;) .catch((err) =&gt; &#123; console.log(&quot;catch: &quot;, err); &#125;) .then((res) =&gt; &#123; console.log(&quot;then3: &quot;, res); &#125;); 12// 透传Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log); 19. async await(1) async&#x2F;await 概述 async&#x2F;await 是 ECMAScript 2017 中引入的新的异步编程特性。它是建立在 Promise 基础之上的，主要的不同是它提供了更为简单直接的语法机制来处理异步操作，并且可以让异步代码看起来像同步代码，这样可以提高代码的可读性和可维护性。 对于一个函数，只要在它的声明前面使用 async 关键字来修饰，那么它就可以使用 await 来等待异步操作的结果。以下是一个简单的例子： 12345async function fetchRemoteData() &#123; const response = await fetch(&quot;https://api.example.com/data&quot;); const data = await response.json(); return data;&#125; 上述代码中，fetchRemoteData 函数声明了 async，这意味着它可以通过 await 等待异步函数 fetch 的返回值。fetchRemoteData 函数等待 fetch 函数的响应，然后再等待它的 JSON 内容，最后返回包含 JSON 消息的数据对象。 (2) async&#x2F;await 原理 async 函数是 Promise 对象的语法糖，async 函数本身返回的是一个 Promise 对象，因此可以与其他 Promise 对象进行链式调用。 123456789101112async function asyncFunc1() &#123; return &quot;hello world&quot;;&#125;async function asyncFunc2() &#123; const result = await asyncFunc1(); return result.toUpperCase();&#125;asyncFunc2().then((res) =&gt; &#123; console.log(res); // -&gt; &#x27;HELLO WORLD&#x27;&#125;); 在 async 函数中使用 await 表达式时，它的作用就是将异步调用的结果分割开来，使得后面的代码可以在异步调用返回结果之后继续执行。 12345678async function demo () &#123; console.log(&#x27;step 1&#x27;) const result = await fetch(&#x27;https://api.example.com/data&#x27;) console.log(&#x27;step 2&#x27;) return result&#125;demo().then(...) 在以上例子中，当我们调用 demo() 函数时，第一行代码会打印一个“step 1”的消息，但注意此时代码并不会阻塞。随后，代码中的 await 表达式会发起一个异步调用，该调用需要一些时间来完成，我们称为“await point”。 (3) 异常处理 await 操作符也可以捕获异步操作产生的异常，就像 Promise.catch() 方法一样。因此，建议在 async 函数中使用 try-catch 块来处理可能出现的异常。以下是一个例子： 12345678910async function divide (x, y) &#123; try &#123; const result = await Promise.resolve(x / y) return result &#125; catch (err) &#123; console.error(&#x27;Error:&#x27;, err) &#125;&#125;divide(10, 0).then(...) (4) 异步函数代码执行顺序说明 12345678910async function async1() &#123; console.log(&quot;async1 start&quot;); await async2(); console.log(&quot;async1 end&quot;);&#125;async function async2() &#123; console.log(&quot;async2&quot;);&#125;async1();console.log(&quot;start&quot;); 12345678910111213141516171819function double(m) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(m * 2); &#125;, 1000); &#125;);&#125;const arr = [1, 2, 3];(async function () &#123; for (var i = 0; i &lt; arr.length; i++) &#123; let r = await double(arr[i]); console.log(r); &#125; console.log(i);&#125;)();console.log(&quot;start&quot;); 20. 优化 DOM 操作性能(1) 优化操作 DOM 的频率 操作 DOM 的次数越少，页面反应就越快。 比如，我们使用一个 for 循环向一个 ul 列表里添加 1000 个 li 元素，这会导致 1000 次 DOM 操作，对页面性能的影响很大。 1234567const list = document.querySelector(&quot;ul&quot;);for (let i = 0; i &lt; 1000; i++) &#123; const li = document.createElement(&quot;li&quot;); li.textContent = `Item $&#123;i&#125;`; list.appendChild(li);&#125; 可以使用 DocumentFragment 来高效地添加大量的 DOM 元素。 DocumentFragment 是一个虚拟的节点，可以将多个节点添加到 DocumentFragment 中，再将它一次性添加到 DOM 中，减少 DOM 操作的次数。 12345678910const list = document.querySelector(&quot;ul&quot;);const fragment = document.createDocumentFragment();for (let i = 0; i &lt; 1000; i++) &#123; const li = document.createElement(&quot;li&quot;); li.textContent = `Item $&#123;i&#125;`; fragment.appendChild(li);&#125;list.appendChild(fragment); (2) 缓存 DOM 元素的引用 每次获取 DOM 对象都会造成一定的性能浪费，所以我们可以使用变量来缓存 DOM 对象的引用。 123456789101112// 未优化document.querySelector(&quot;#myButton&quot;).addEventListener(&quot;click&quot;, function () &#123; document.querySelector(&quot;#myDiv&quot;).innerHTML = &quot;Button clicked&quot;;&#125;);// 优化后const myButton = document.querySelector(&quot;#myButton&quot;);const myDiv = document.querySelector(&quot;#myDiv&quot;);myButton.addEventListener(&quot;click&quot;, function () &#123; myDiv.innerHTML = &quot;Button clicked&quot;;&#125;); (3) 使用事件委托 添加事件监听器也会影响性能，我们可以使用事件委托的方式来减少事件监听器的数量。 事件委托就是利用事件冒泡，将事件监听器添加到父元素上，然后根据事件冒泡的原理，在父元素上捕获事件，从而减少事件监听器的数量。 1234567891011121314151617// 未优化const listItems = document.querySelectorAll(&quot;li&quot;);for (let i = 0; i &lt; listItems.length; i++) &#123; listItems[i].addEventListener(&quot;click&quot;, function () &#123; console.log(`Item $&#123;i&#125; clicked`); &#125;);&#125;// 优化后const list = document.querySelector(&quot;ul&quot;);list.addEventListener(&quot;click&quot;, function (e) &#123; if (e.target.tagName === &quot;LI&quot;) &#123; console.log(`Item $&#123;e.target.textContent&#125; clicked`); &#125;&#125;); (4) 使用 classList 代替 className className 常用于添加、删除、替换元素的 CSS 类，但是每次操作都会重新渲染元素，影响性能。 所以我们可以使用 classList 来代替 className 属性。 1234567// 未优化const myDiv = document.querySelector(&quot;#myDiv&quot;);myDiv.className = &quot;foo&quot;;// 优化后const myDiv = document.querySelector(&quot;#myDiv&quot;);myDiv.classList.add(&quot;foo&quot;); (5) 避免多次修改样式 在 JavaScript 代码中频繁修改样式也会影响性能，我们可以将多个样式合并成一个字符串，然后一次性修改。 12345678910// 未优化const myDiv = document.querySelector(&quot;#myDiv&quot;);myDiv.style.backgroundColor = &quot;red&quot;;myDiv.style.color = &quot;white&quot;;myDiv.style.fontSize = &quot;20px&quot;;// 优化后const myDiv = document.querySelector(&quot;#myDiv&quot;);myDiv.style.cssText = &quot;background-color: red; color: white; font-size: 20px;&quot;; 21. property 与 attribute在 HTML 中，attribute 是指在 HTML 标签属性，property 是指 DOM 对象属性。 HTML 中的 attribute： 1&lt;div id=&quot;myDiv&quot; class=&quot;box&quot; data-value=&quot;123&quot;&gt;This is a box&lt;/div&gt; 可以使用 JavaScript 获取 attribute 的值： 12const myDiv = document.getElementById(&quot;myDiv&quot;);console.log(myDiv.getAttribute(&quot;data-value&quot;)); // &quot;123&quot; 也可以使用 JavaScript 动态设置 attribute 的值： 1myDiv.setAttribute(&quot;data-value&quot;, &quot;456&quot;); DOM 对象属性通过 DOM 对象点上属性的方式进行访问： 1234const myDiv = document.getElementById(&quot;myDiv&quot;);console.log(myDiv.id); // &quot;myDiv&quot;console.log(myDiv.className); // &quot;box&quot;console.log(myDiv.innerHTML); // &quot;This is a box&quot; 也可以通过赋值语句来修改它们的值： 12myDiv.className = &quot;new-box&quot;;myDiv.innerHTML = &quot;This is a new box&quot;; HTML 标签属性和 DOM 对象属性都是为 HTML 元素提供附加信息的方式。它们之间有一定的联系，但在使用和目的方面有所不同。 HTML 标签属性： HTML 标签属性主要用于在 HTML 文档中为元素提附加信息。 例如，id 属性用于为一个 HTML 元素分配唯一的标识符，class 属性可以分配一个或多个类名，以便使用 CSS 进行样式设置。例如： 123456&lt;input type=&quot;text&quot; id=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;请输入用户名&quot;/&gt; DOM 对象属性： DOM 即文档对象模型（Document Object Model），是一个编程接口，允许我们使用 JavaScript 操作 HTML 文档的结构、样式和内容。 浏览器在读取 HTML 标签时，会生成标签对应的 DOM 对象，标准的 HTML 标签属性会成为 DOM 对象属性。 DOM 对象属性是我们在 JavaScript 中与 HTML 元素互动时所使用的属性，它不仅包括 HTML 属性，还包括其他与元素相关的属性。例如： 123const element = document.getElementById(&quot;username&quot;);console.log(element.tagName); // 输出元素的标签名称element.disabled = true; // 将输入框设置为禁用状态 不同点： HTML 标签属性仅仅存在于 HTML 文档中，而 DOM 对象属性是我们 在 JavaScript 中使用的属性。 DOM 对象属性包含更多信息，除了标准的 HTML 标签属性以外还包括元素事件处理、元素宽高等。 有时，DOM 对象属性和 HTML 标签属性可能有区别。 checked 和 selected 在 HTML 中是布尔属性，但在 DOM 中是布尔值。 value 属性，HTML 标签的 value 属性始终存储的是设置属性时赋的默认值，而 DOM 对象中的 value 属性保存的是用户输入的内容。 class 属性用于在 HTML 标签中为元素设置类名，className 属性用于在 DOM 对象中设置元素类名。 一些 HTML 标签属性没有对应的 DOM 对象属性, 比如 aria-*, colspan 等 一些 DOM 对象属性没有对应的 HTML 标签属性, 比如 textContent 等 在实际项目中，你应该根据需要进行选择： 在 HTML 标签中，使用 HTML 属性定义元素的特征和基础数据。 在 JavaScript 代码中，通过操作 DOM 对象属性实现动态交互和修改元素状态。 代码示例： 123456789101112131415161718&lt;!-- 设置HTML标签属性 --&gt;&lt;button id=&quot;toggleBtn&quot; class=&quot;btn btn-primary&quot;&gt;切换禁用状态&lt;/button&gt;&lt;input type=&quot;text&quot; id=&quot;username&quot; class=&quot;form-control&quot; placeholder=&quot;请输入用户名&quot;/&gt;&lt;script&gt; // JavaScript访问和操作DOM对象属性 const toggleBtn = document.getElementById(&quot;toggleBtn&quot;); const inputElement = document.getElementById(&quot;username&quot;); toggleBtn.addEventListener(&quot;click&quot;, () =&gt; &#123; inputElement.disabled = !inputElement.disabled; &#125;);&lt;/script&gt; 上面的代码中，我们在 HTML 中设置了基本的属性，然后在 JavaScript 中操作 DOM 对象属性实现点击按钮时切换输入框的禁用状态。 22. 通用的绑定事件的方法123456789function addEvent(el, eventType, callback) &#123; if (el.addEventListener) &#123; el.addEventListener(eventType, callback, false); &#125; else if (el.attachEvent) &#123; el.attachEvent(&quot;on&quot; + eventType, callback); &#125; else &#123; el[&quot;on&quot; + eventType] = callback; &#125;&#125; el 是要绑定事件的元素，eventType 是要绑定的事件类型，callback 是事件处理程序。 这个方法支持现代浏览器、IE8+及更低版本的 IE 浏览器，以及不支持 addEventListener 的其他浏览器。 说出 onLoad (window) 事件与 DOMContentLoaded (document) 事件的区别？ 23. 事件冒泡事件冒泡是指当一个元素上的事件被触发时，该事件会向父元素传递，如果父元素也绑定了该事件，则会接着触发父元素上的事件，以此类推直至到达最外层的祖先元素为止。 12345&lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;middle&quot;&gt; &lt;button id=&quot;inner&quot;&gt;Click me!&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314const outer = document.getElementById(&quot;outer&quot;);outer.addEventListener(&quot;click&quot;, function (event) &#123; console.log(&quot;Outer div clicked!&quot;);&#125;);const middle = document.getElementById(&quot;middle&quot;);middle.addEventListener(&quot;click&quot;, function (event) &#123; console.log(&quot;Middle div clicked!&quot;);&#125;);const inner = document.getElementById(&quot;inner&quot;);inner.addEventListener(&quot;click&quot;, function (event) &#123; console.log(&quot;Button clicked!&quot;);&#125;); 当点击按钮时，控制台会打印以下内容： 123Button clicked!Middle div clicked!Outer div clicked! 24. 事件委托事件委托是指将事件处理程序绑定在某一元素的祖先元素上，通过祖先元素处理该事件，这能够优化性能并减少事件处理程序的数量。 下面是一个示例，当单击一个 ul 元素的下拉菜单项时，会执行相应的操作： HTML 代码： 12345&lt;ul class=&quot;menu&quot;&gt; &lt;li&gt;菜单项 1&lt;/li&gt; &lt;li&gt;菜单项 2&lt;/li&gt; &lt;li&gt;菜单项 3&lt;/li&gt;&lt;/ul&gt; JavaScript 代码： 123456var menu = document.querySelector(&quot;.menu&quot;);menu.addEventListener(&quot;click&quot;, function (event) &#123; if (event.target.tagName === &quot;LI&quot;) &#123; console.log(&quot;你点击了菜单项：&quot;, event.target.textContent); &#125;&#125;); 25. Ajax在原生 JavaScript 中，我们可以使用 XMLHttpRequest 对象发送 Ajax 请求。 一、概述 Ajax 是 Asynchronous JavaScript and XML 的缩写，它是一种使用 JavaScript 在不刷新页面的情况下与服务器交换数据的技术。 二、创建 XMLHttpRequest 对象 要使用 XMLHttpRequest，首先需要创建一个 XMLHttpRequest 对象的实例。 1var xhr = new XMLHttpRequest(); 三、设置请求 当实例创建完毕后，可以使用 XMLHttpRequest 对象的 open() 方法来设置请求，open() 方法接受三个参数： 请求的类型（GET 或 POST） 请求的 URL 请求是否异步（true 表示异步，false 表示同步） 1xhr.open(&quot;GET&quot;, &quot;https://api.example.com/data&quot;, true); 四、发送请求 设置好请求之后，可以使用 XMLHttpRequest 对象的 send() 方法来发送请求。 如果是 GET 请求，send() 方法不需要参数； 如果是 POST 请求，send() 方法需要传递一个字符串或 FormData 对象。 1xhr.send(); 五、处理响应 要处理服务器返回的响应，可以使用 XMLHttpRequest 对象的 onreadystatechange 事件处理程序。 当请求的状态（readyState）发生变化时，onreadystatechange 事件处理程序将被触发。 readyState 的可能值包括： 0：请求未初始化（已创建 XMLHttpRequest 实例，但尚未调用 open() 方法） 1：请求已经设置（已调用 open() 方法，但尚未调用 send() 方法） 2：请求已发送（已调用 send() 方法，但尚未收到响应） 3：请求处理中（已收到部分响应数据） 4：请求已完成（已收到所有的响应数据） 当 readyState 等于 4 且 HTTP 状态码为 200 时，表示请求成功，此时可以获取并处理服务器返回的数据。 12345678910var xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(JSON.parse(xhr.responseText)); &#125;&#125;;xhr.open(&quot;GET&quot;, &quot;https://api.example.com/data&quot;, true);xhr.send(); 实际项目中的代码示例： 获取 GitHub 用户信息： 1234567891011var xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; var user = JSON.parse(xhr.responseText); console.log(&quot;GitHub 用户名：&quot; + user.login); &#125;&#125;;xhr.open(&quot;GET&quot;, &quot;https://api.github.com/users/octocat&quot;, true);xhr.send(); 从 API 中获取一条随机笑话： 1234567891011var xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; var joke = JSON.parse(xhr.responseText); console.log(&quot;随机笑话：&quot; + joke.value.joke); &#125;&#125;;xhr.open(&quot;GET&quot;, &quot;https://api.icndb.com/jokes/random&quot;, true);xhr.send(); 26. 跨域(1) 跨域概述 跨域是指跨越原始访问控制(domains)的访问。 在 Web 应用中，浏览器出于安全考虑一般情况下是只允许同源请求。 所谓同源就是协议、域名以及端口号相同，如果请求的资源来自于不同的源（域名、端口、协议），则会出现跨域。 这种安全策略被称为 “同源策略”，同源策略的主要目的是为了保证用户信息的安全，阻止恶意攻击。 如果没有同源策略，攻击者可以通过编写脚本，从一个网站发送请求绕过用户认证，获取用户的隐私数据。 (2) 如何解决跨域问题 ① JSONP JSONP (JSON with Padding) 是一种通过 script 标签跨域访问数据的方式，因为 script 标签本身就允许跨域。 123456789101112// 客户端function jsonp(url, callbackName) &#123; const script = document.createElement(&quot;script&quot;); script.src = `$&#123;url&#125;?callback=$&#123;callbackName&#125;`; document.body.appendChild(script);&#125;function handleData(data) &#123; console.log(data);&#125;jsonp(&quot;https://example.com/jsonp&quot;, &quot;handleData&quot;); 1234567891011121314151617// 服务端const http = require(&quot;http&quot;);const url = require(&quot;url&quot;);http .createServer(function (req, res) &#123; const query = url.parse(req.url, true).query; const callback = query.callback; const data = &#123; name: &quot;Jack&quot;, age: 20, &#125;; res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;application/javascript&quot; &#125;); res.end(`$&#123;callback&#125;($&#123;JSON.stringify(data)&#125;)`); &#125;) .listen(3000); 需要注意的是，JSONP 总是发起一个 GET 请求，所以仅仅适用于请求数据，而不能发送数据。 ② CORS (跨域资源共享) CORS 是一种更为现代化的跨域方案，它允许浏览器与服务器之间进行跨域通信。 服务端需要在响应头中添加 CORS 相关配置，例如 Access-Control-Allow-Origin，这样客户端就可以跨域访问该资源。 123456789// 客户端const xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;, &quot;https://example.com/api/data&quot;);xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(JSON.parse(xhr.responseText)); &#125;&#125;;xhr.send(); 123456789101112131415161718// 服务端const http = require(&quot;http&quot;);http .createServer(function (req, res) &#123; res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, // &quot;*&quot; 表示允许任何域名跨域访问，也可以设置指定域名 &#125;); const data = &#123; name: &quot;Lily&quot;, age: 22, &#125;; res.end(JSON.stringify(data)); &#125;) .listen(3000); 除了以上两种方法，还有其他一些常用的跨域解决方案，如使用代理服务器、postMessage 通信等。 27. 本地存储cookie 是浏览器保存用户数据的一种方式。 localStorage 和 sessionStorage 是 HTML5 引入的 Web Storage，同样是用于在浏览器中保存数据。 1234567// 设置cookiedocument.cookie = &quot;name=John Doe; expires=Thu, 18 Dec 2022 12:00:00 UTC; path=/&quot;;// 获取cookielet name = document.cookie;console.log(name); 123456789// 存储数据localStorage.setItem(&quot;name&quot;, &quot;John Doe&quot;);localStorage.setItem(&quot;age&quot;, &quot;30&quot;);// 获取数据let name = localStorage.getItem(&quot;name&quot;);let age = localStorage.getItem(&quot;age&quot;);console.log(name, age); 123456789// 存储数据sessionStorage.setItem(&quot;name&quot;, &quot;John Doe&quot;);sessionStorage.setItem(&quot;age&quot;, &quot;30&quot;);// 获取数据let name = sessionStorage.getItem(&quot;name&quot;);let age = sessionStorage.getItem(&quot;age&quot;);console.log(name, age); cookie 保存数据的容量较小，只有 4KB 左右，而 localStorage 和 sessionStorage 可以存储更多数据。 cookie 可以设置过期时间，不过需要手动管理，而 localStorage 和 sessionStorage 可以无限期保存数据。 cookie 可以跨域传递数据，而 localStorage 和 sessionStorage 只能在同源页面之间共享数据。 cookie 保存在浏览器的 cookie 文件夹中，localStorage 和 sessionStorage 保存在浏览器中的特定位置，更安全。 如果需要跨页面或跨域传递数据，或者需要在用户不主动清除浏览器缓存的情况下保存数据，建议使用 cookie。 如果需要在同源页面中保存少量数据，建议使用 localStorage。 如果需要在同源页面中保存临时数据，建议使用 sessionStorage。 28. HTTP 协议(1) HTTP 协议概述 HTTP (Hypertext Transfer Protocol) 是一种在 Web 应用中进行数据通信的协议。 在客户端和服务器之间交换的所有数据（例如 HTML 文件、图像文件、查询结果等）都必须遵循 HTTP 协议中规定的格式。 HTTP 协议基于客户端服务器模型，客户端发送请求，服务器发送响应。 通常，Web 浏览器是作为客户端出现的。当您在浏览器中输入一个 URL 时，这实际上向服务器发出了一个请求，以获取网页。 服务器将响应包含在一个 HTTP 格式的消息中，并将其发送回给浏览器。浏览器将消息解析并显示响应的文本、图像等内容。 HTTP 格式的消息分为两类：请求和响应。 (2) HTTP 请求 HTTP 请求由三个部分组成： 请求方法：指定对服务器执行的操作类型。常用方法包括 GET、POST、PUT、DELETE 等。 请求 URI：指定要操作的资源的 URI。 HTTP 版本：该消息所使用的 HTTP 版本。 例如，以下是一个 HTTP GET 请求的示例： 12GET /index.html HTTP/1.1Host: www.example.com 这个请求由 GET 方法（请求获取资源）组成，请求的 URI 是 /index.html，HTTP 版本是 1.1。 请求消息可以包含其他信息，如下所示： 1234GET /search?q=example HTTP/1.1Host: www.google.comAccept-Encoding: gzip, deflate, brUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3 其中，Accept-Encoding 和 User-Agent 是请求首部。 (3) HTTP 响应 HTTP 响应也由三个部分组成： 状态码：指定执行该请求后服务器的状态。常见的状态码包括 200 OK（请求成功）、404 Not Found（未找到请求的资源）等。 响应首部：包含与响应相关的元数据，如服务器类型、响应时间等。 实体：包含响应的实际内容，例如网页、图像等。 以下是一个 HTTP 响应的示例： 12345678910111213HTTP/1.1 200 OKContent-Type: text/html; charset=UTF-8Content-Length: 138Date: Tue, 06 Jun 2017 09:45:32 GMT&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to Example.com&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 状态码为 200（请求成功），并且响应实体中包含一个 HTML 页面。 (4) HTTP 方法 HTTP 协议支持多种请求方法。以下是一些常见的方法： GET：请求获取资源。应该只用于获取数据，不应更改数据。 POST：请求向服务器提交数据。该请求可能导致服务器更改状态或执行其他操作。 PUT：请求更新服务器上的资源。 DELETE：请求删除服务器上的资源。 (5) HTTP 状态码 HTTP 响应状态码指示 HTTP 请求是否已成功完成。以下是一些常见的状态码及其含义： 200 OK：请求已成功完成。 201 Created：服务器已成功创建新资源。 400 Bad Request：请求无效，例如缺少一些必需的参数。 401 Unauthorized：未授权，需要身份验证。 404 Not Found：请求的资源不存在。 500 Internal Server Error：服务器遇到了错误，无法完成请求。 29. restful APIRESTful（Representational State Transfer）是一种软件架构风格，主要用于网络上的 web 服务。 RESTful API 按照资源进行设计，使用标准的 HTTP 方法，如 GET、POST、PUT 和 DELETE，实现资源的创建、读取、更新和删除操作（CRUD 操作）。 资源：RESTful API 中的资源可以是一篇文章、用户信息或者商品等，这些资源可以通过 URI（统一资源标识符）进行标识，例如：&#x2F;users、&#x2F;articles 等。 方法：RESTful API 中的方法是 HTTP 请求动词，例如：GET、POST、PUT、DELETE 等。不同的动词表示对资源的不同操作。 状态：资源的状态表示请求操作的结果，使用 HTTP 状态码来传达，如 200 表示操作成功，404 表示资源未找到，500 表示服务器内部错误等。 以下是一个使用 Node.js 的 Express 框架创建的简单 RESTful 风格的 API 的代码示例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 导入模块const express = require(&quot;express&quot;);const app = express();// 使用中间件app.use(express.json());// 资源：用户const users = [];// 方法：// 1. 获取所有用户：GET /usersapp.get(&quot;/users&quot;, (req, res) =&gt; &#123; res.status(200).json(users);&#125;);// 2. 创建用户：POST /usersapp.post(&quot;/users&quot;, (req, res) =&gt; &#123; const newUser = &#123; id: users.length + 1, name: req.body.name, age: req.body.age, &#125;; users.push(newUser); res.status(201).json(newUser);&#125;);// 3. 获取单个用户：GET /users/:idapp.get(&quot;/users/:id&quot;, (req, res) =&gt; &#123; const user = users.find((u) =&gt; u.id === parseInt(req.params.id)); if (!user) res.status(404).send(&quot;用户未找到。&quot;); res.status(200).json(user);&#125;);// 4. 修改用户信息：PUT /users/:idapp.put(&quot;/users/:id&quot;, (req, res) =&gt; &#123; const user = users.find((u) =&gt; u.id === parseInt(req.params.id)); if (!user) res.status(404).send(&quot;用户未找到。&quot;); user.name = req.body.name; user.age = req.body.age; res.status(200).json(user);&#125;);// 5. 删除用户：DELETE /users/:idapp.delete(&quot;/users/:id&quot;, (req, res) =&gt; &#123; const user = users.find((u) =&gt; u.id === parseInt(req.params.id)); if (!user) res.status(404).send(&quot;用户未找到。&quot;); const index = users.indexOf(user); users.splice(index, 1); res.status(204).send();&#125;);const port = process.env.PORT || 3000;app.listen(port, () =&gt; console.log(`Listening on port $&#123;port&#125;...`)); 30. 数组 splice、slice在 JavaScript 中，数组的 splice 和 slice 是两个用于操作数组的方法，它们的用法和区别如下： splice 方法用于在数组内插入、删除或替换元素。语法如下： 1array.splice(startIndex, deleteCount, item1, ..., itemN) startIndex：开始变更的索引（包括该位置的元素） deleteCount：要删除的元素个数，可选。如果省略该参数，那么 startIndex 之后的所有元素都会被删除。 item1, …, itemN：要插入到数组中的元素，可选。 splice 方法的返回值是一个包含被删除元素的数组。如果没有元素被删除，则返回一个空数组。 1234const arr = [1, 2, 3, 4, 5];const removed = arr.splice(1, 2, 7, 8);console.log(arr); // [1, 7, 8, 4, 5]console.log(removed); // [2, 3] slice 方法用于截取数组的子数组。它不会修改原数组，而是返回一个新的数组。 1array.slice(startIndex, endIndex); startIndex：起始索引（包含），可选。默认值为 0。 endIndex：结束索引（不包含），可选。默认值为数组的长度。 1234const arr = [1, 2, 3, 4, 5];const newArr = arr.slice(1, 4);console.log(arr); // [1, 2, 3, 4, 5] （原数组不变）console.log(newArr); // [2, 3, 4] splice 和 slice 区别： splice 方法会修改原数组，而 slice 方法不会修改原数组，而是返回一个新数组。 splice 方法可以插入、删除、替换元素，而 slice 方法用于截取子数组。 endIndex 参数在 slice 中是不包含在返回数组中的，而 splice 的 deleteCount 则是包含在被删除的元素个数中。 31. map 与 parseInt请说出下列代码的返回值是什么 1[10, 20, 30].map(parseInt); 以上代码是想将数组 [10, 20, 30] 中的每个元素用 parseInt 函数解析成整数，然而实际执行结果却与预期不符：执行后的结果是 [10, NaN, NaN]。 为了理解这个现象，我们需要深入了解 map 和 parseInt 函数的工作原理。 map 是数组的一个方法，它接收一个函数作为参数。map 会遍历数组的每一个元素，并对每个元素执行传入的函数。 传入的函数有三个参数：当前元素、当前元素的索引和整个数组。 map 函数返回一个新的数组，这个新数组中的元素是原数组每个元素经过传入函数处理后的结果。 parseInt 是一个全局函数，用于将字符串转换为整数。 它接受两个参数：要解析的字符串和一个可选的基数（例如 2 表示二进制，10 表示十进制等）。 当提供基数时，parseInt 会按照给定的进制把字符串转换为对应的整数。 当我们将 parseInt 传入 map 函数时，map 函数会依次为数组中每个元素调用 parseInt 函数，并把当前元素值、索引和整个数组分别传给 parseInt 的第一个、第二个和第三个参数。然而此时 parseInt 函数的第二个参数并非作为解析的基数，而是把数组索引作为基数了。这就导致了实际执行结果与预期不符。 当处理第一个元素（10）时，parseInt 接收到的参数是 parseInt(10, 0)（0 是数组索引）。基数为 0 时，parseInt 会默认按照十进制进行解析，因此结果是 10。 当处理第二个元素（20）时，parseInt 接收到的参数是 parseInt(20, 1)（1 是数组索引）。此时基数为 1，但 1 是一个无效的基数，因此 parseInt 函数会返回 NaN。 当处理第三个元素（30）时，parseInt 接收到的参数是 parseInt(30, 2)（2 是数组索引）。此时基数为 2，即二进制，而 30 并不符合二进制表示，所以 parseInt 返回 NaN。 因此，[10, 20, 30].map(parseInt) 的执行结果是 [10, NaN, NaN]。 如果你想用 map 函数将 [10, 20, 30] 中的每个元素转换为整数，可以这样做： 1[10, 20, 30].map((num) =&gt; parseInt(num)); 这样就可以得到预期的结果 [10, 20, 30]。 32. 函数声明与函数表达式函数声明（Function Declaration）和函数表达式（Function Expression）都是在 JavaScript 中定义和创建函数的两种方法。 1. 函数声明（Function Declaration） 函数声明是使用 function 关键字后跟函数名称和函数体来定义函数的方法。函数声明会在代码执行前被初始化，因此可以在声明之前调用。这种行为被称为函数提升（hoisting）。 1234567// 函数声明function greeting(name) &#123; return &quot;Hello, &quot; + name;&#125;// 调用函数console.log(greeting(&quot;John&quot;)); 2. 函数表达式（Function Expression） 函数表达式是将一个函数赋值给一个变量。函数表达式在执行到其所在行时，通过变量名进行调用。 1234567// 函数表达式const greeting = function (name) &#123; return &quot;Hello, &quot; + name;&#125;;// 调用函数console.log(greeting(&quot;John&quot;)); 函数声明与函数表达式的区别： 提升：函数声明在执行前会被提升，这意味着你可以在声明之前调用它。而函数表达式需要等到其所在行被执行后，才可被调用。 语法：函数声明需要提供一个函数名，而函数表达式可以是命名的也可以是匿名的。 1234567891011// 函数声明提升示例console.log(square(5)); // 输出：25function square(num) &#123; return num * num;&#125;// 函数表达式提升示例console.log(square(5)); // 会抛出 TypeError: square is not a functionconst square = function (num) &#123; return num * num;&#125;; 33. 手写 trim 方法在 JavaScript 中，字符串对象自带了 trim() 方法，可以用来去除字符串两端的空格。 但是如果需要自己手动实现一个 trim() 方法，可以使用正则表达式来去除字符串两端的空格。 1234567String.prototype.trim = function () &#123; return this.replace(/^\\s+|\\s+$/g, &quot;&quot;);&#125;;// 使用自定义的 trim() 方法let str = &quot; Hello, World! &quot;;console.log(str.trim()); // 输出：&#x27;Hello, World!&#x27; 我们扩展了 String.prototype 对象，添加了一个名为 trim() 的方法。该方法使用正则表达式来去除字符串两端的空格，并返回处理后的字符串。 正则表达式 /^\\s+|\\s+$/g 匹配字符串两端的空格。其中： ^ 表示匹配字符串开头； \\s+ 表示匹配一个或多个空格； | 表示或者； $ 表示匹配字符串结尾； g 表示全局匹配。 因此，/^\\s+|\\s+$/g 可以匹配字符串开头和结尾的空格，并将其替换为空字符串。 34. 手写 max 方法 目标：编写 myMax 方法模拟 Math.max 方法的功能 可以使用 apply() 方法来模拟 Math.max 方法的功能。 apply() 方法可以接受一个数组作为参数，并将其展开为一系列参数，传递给函数。 12345678910111213function myMax() &#123; let max = arguments[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; if (arguments[i] &gt; max) &#123; max = arguments[i]; &#125; &#125; return max;&#125;let nums = [1, 5, 3, 9, 2];let maxNum = myMax.apply(null, nums);console.log(maxNum); // 输出：9 35. 捕获异常在 JavaScript 中，可以使用 try-catch 语句来捕获异常。 try-catch 语句包含两个关键字：try 和 catch。try 代码块中包含可能会引发异常的代码，而 catch 代码块用于处理异常情况。 1234567try &#123; // 可能会引发异常的代码 let x = y + 1;&#125; catch (e) &#123; // 处理异常情况 console.log(&quot;发生了异常：&quot; + e.message);&#125; onerror 事件：用于捕获全局范围内发生的异常。可以使用 window.onerror 事件来捕获全局范围内的异常。例如： 1234// 该事件会在发生异常时自动触发，并将异常信息作为参数传递给事件处理函数。window.onerror = function (message, url, line, column, error) &#123; console.log(&quot;发生了异常：&quot; + message);&#125;; 36. JSON 介绍JSON 是一种轻量级的数据交换格式，它的全称是 JavaScript Object Notation。 JSON 最初是由 Douglas Crockford 在 2001 年提出的，它是一种基于文本的数据格式，具有易于阅读和编写的特点。 JSON 格式通常用于通过网络传输数据，因为它可以被多种编程语言解析和生成。 JSON 与 JavaScript 密切相关，因为 JSON 的语法是 JavaScript 对象的子集。 这意味着在 JavaScrip t 中，我们可以轻松地将 JSON 格式的数据转换为 JavaScript 对象，反之亦然。 JavaScript 提供了两个内置方法来解析和生成 JSON 数据：JSON.parse() 和 JSON.stringify()。 序列化：将对象转换为 JSON 字符串 反序列化：将 JSON 字符串转换为 JSON 对象。 37. 获取查询参数编写一个方法用于获取 url 中的查询参数并返回其对象格式。 123456789101112131415161718192021function getQueryParams() &#123; var queryParams = &#123;&#125;; var queryString = window.location.search.substring(1); var pairs = queryString.split(&quot;&amp;&quot;); for (var i = 0; i &lt; pairs.length; i++) &#123; var pair = pairs[i].split(&quot;=&quot;); var key = decodeURIComponent(pair[0]); var value = decodeURIComponent(pair[1]); if (typeof queryParams[key] === &quot;undefined&quot;) &#123; queryParams[key] = value; &#125; else if (Array.isArray(queryParams[key])) &#123; queryParams[key].push(value); &#125; else &#123; queryParams[key] = [queryParams[key], value]; &#125; &#125; return queryParams;&#125; 当用户需要从 URL 中获取查询参数时，可以使用以下 JavaScript 函数来实现： 12345678function getUrlParams(url) &#123; const params = &#123;&#125;; const regex = /([^&amp;?+]+)=([^&amp;?+]+)/g; url.replace(regex, function () &#123; params[arguments[1]] = arguments[2]; &#125;); return params;&#125; 这个函数使用正则表达式来匹配 URL 中的查询参数，然后将它们存储在一个对象中并返回。 1https://example.com/search?q=javascript&amp;lang=en&amp;page=2 我们可以调用 getUrlParams 函数来获取查询参数： 1234const urlParams = getUrlParams( &quot;https://example.com/search?q=javascript&amp;lang=en&amp;page=2&quot;);console.log(urlParams); 这将输出以下内容： 12345&#123; q: &quot;javascript&quot;, lang: &quot;en&quot;, page: &quot;2&quot;&#125; 38. 拍平多维数组例如，调用 flatten([1, [2, 3], [4, [5, 6]]]) 将返回 [1, 2, 3, 4, 5, 6]。 1234567891011function flatten(arr) &#123; let result = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (Array.isArray(arr[i])) &#123; result = result.concat(flatten(arr[i])); &#125; else &#123; result.push(arr[i]); &#125; &#125; return result;&#125; 1234567function flatten(arr) &#123; return arr.reduce(function (flat, toFlatten) &#123; return flat.concat( Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten ); &#125;, []);&#125; 39. 数组去重以下是使用 JavaScript 编写的一个函数，可以对数组进行去重，包括三种不同的去重方法： 1234567891011121314151617181920function uniqueArray(arr) &#123; // 方法一：使用 Set 数据结构 const set = new Set(arr); const uniqueArr1 = [...set]; // 方法二：使用 indexOf() 方法 const uniqueArr2 = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (uniqueArr2.indexOf(arr[i]) === -1) &#123; uniqueArr2.push(arr[i]); &#125; &#125; // 方法三：使用 filter() 方法 const uniqueArr3 = arr.filter(function (item, index, array) &#123; return array.indexOf(item) === index; &#125;); return &#123; uniqueArr1, uniqueArr2, uniqueArr3 &#125;;&#125; 这个函数接收一个数组作为参数，并返回一个包含三种不同去重方法结果的对象。其中： 方法一使用了 ES6 中的 Set 数据结构，将数组转换为 Set，然后再将 Set 转换为数组。 方法二使用了 for 循环和 indexOf() 方法来遍历数组，如果元素在新数组中不存在，就将其添加到新数组中。 方法三使用了 filter() 方法来遍历数组，只保留第一次出现的元素。 40. vue2 声明周期函数在 Vue2 中，生命周期函数是 Vue 组件会经历的一系列依次触发的函数。它们在特定时候执行，并允许开发者执行响应逻辑。 这些生命周期函数主要包括以下几种: beforeCreate：在 Vue 实例初始化之后，数据观测和事件配置之前被调用。 表示含义：Vue 实例已经创建，但数据观测和事件还未设置。 执行时机：页面渲染前。 应用：这个阶段不能访问到 data、methods 等，通常用得较少。 12345new Vue(&#123; beforeCreate() &#123; console.log(&quot;beforeCreate&quot;); &#125;,&#125;); created：在 Vue 实例创建完成后被立即调用，此时已完成数据观测，方法和计算属性的运算。 表示含义：Vue 实例创建完成，数据观测以及 data、methods 等已设置。 执行时机：页面渲染前。 应用：可以用于转换数据格式、初始化、扩展 methods 方法等。 123456789new Vue(&#123; data: &#123; message: &quot;Hello Vue!&quot;, &#125;, created() &#123; console.log(&quot;created&quot;); console.log(this.message); &#125;,&#125;); beforeMount：在挂载开始之前被调用，相关的 render 函数首次被调用。 表示含义：模板编译完成，但 DOM 还没有挂载。 执行时机：页面渲染前。 应用：一般不会在这个阶段操作，因为没有渲染出 DOM。 123456new Vue(&#123; el: &quot;#app&quot;, beforeMount() &#123; console.log(&quot;beforeMount&quot;); &#125;,&#125;); mounted：在 Vue 实例挂载完成时调用。此时已完成模板到 DOM 的挂载。 表示含义：完成 DOM 挂载，可以操作 DOM。 执行时机：页面渲染后。 应用：你可以在这里操作 DOM，比如插入插件或者调用接口。 123456new Vue(&#123; el: &quot;#app&quot;, mounted() &#123; console.log(&quot;mounted&quot;); &#125;,&#125;); beforeUpdate：数据发生变化时，且发生在虚拟 DOM 重新渲染和打补丁之前调用。 表示含义：数据已更新，但 DOM 还没有更新。 执行时机：页面更新前。 应用：可以在更新之前进行某些操作，比如离开当前页面前做个提示。 12345678new Vue(&#123; data: &#123; message: &quot;Hello Vue!&quot;, &#125;, beforeUpdate() &#123; console.log(&quot;beforeUpdate&quot;); &#125;,&#125;); updated：在虚拟 DOM 重新渲染和打补丁后调用，表示 DOM 已完成更新。 表示含义：DOM 更新完成。 执行时机：页面更新后。 应用：可以执行依赖于 DOM 的操作，但要注意避免无限循环更新。 12345678new Vue(&#123; data: &#123; message: &quot;Hello Vue!&quot;, &#125;, updated() &#123; console.log(&quot;updated&quot;); &#125;,&#125;); beforeDestroy：在 Vue 实例销毁之前调用。此时实例仍然可以完全正常使用。 表示含义：实例即将销毁，但仍可正常使用。 执行时机：销毁前。 应用：可以用来解绑事件或者清除定时器等。 12345new Vue(&#123; beforeDestroy() &#123; console.log(&quot;beforeDestroy&quot;); &#125;,&#125;); destroyed：在 Vue 实例销毁完成后调用。此时所有的绑定、实例方法等均已解除。表示含义：实例已完全销毁。执行时机：销毁后。应用：这个阶段实例已被销毁，很少会用到。 12345new Vue(&#123; destroyed() &#123; console.log(&quot;destroyed&quot;); &#125;,&#125;); 以上就是 Vue2 中的生命周期函数及其作用和应用。在实际项目中，我们可以根据不同需求选择合适的生命周期函数来执行相应操作。 41. vue2 父子组件生命周期调用顺序在 Vue2 中，父子组件的生命周期调用顺序如下： 挂载阶段（Mounting） 父组件：beforeCreate 父组件：created 父组件：beforeMount 子组件：beforeCreate 子组件：created 子组件：beforeMount 子组件：mounted 父组件：mounted 更新阶段（Updating） 父组件：beforeUpdate 子组件：beforeUpdate 子组件：updated 父组件：updated 卸载阶段（Unmounting） 父组件：beforeDestroy 子组件：beforeDestroy 子组件：destroyed 父组件：destroyed 42. vue2 keep-alive 组件在 Vue2 中，keep-alive 是一个抽象组件，它的作用是缓存非活动的组件实例，以避免反复重渲染，提高性能。 keep-alive 自身实际上不会渲染成一个 DOM 元素。 (1) 应用场景 列表切换渲染时：当有多个列表页面时，用户在不同的列表页面之间切换，需要保持每个列表页面的滚动位置、数据状态等。 页面级别的缓存：SPA 应用中，用户在不同页面之间切换时，需要保持一些页面的缓存，以提升性能并减少页面加载时间。 菜单切换渲染：当有多个菜单需要切换渲染时，为了保持之前菜单的状态，可以使用 keep-alive 来缓存这些菜单组件。 (2) 特有生命周期函数 activated：当被包裹的组件激活时，执行此钩子函数。这个钩子函数表示组件被缓存后，再次被渲染到页面时调用。 deactivated：当被包裹的组件被缓存时，执行此钩子函数。这个钩子函数表示组件被缓存时调用。 (3) 实现原理 keep-alive 的实现原理主要基于 Vue 的虚拟 DOM 和组件的生命周期函数。 当一个组件被包裹在 keep-alive 中时，keep-alive 会监听它的 activated 和 deactivated 钩子函数，缓存&#x2F;激活&#x2F;子组件。 keep-alive 使用了 Vue 的虚拟 DOM 实现，通过创建一个 &lt;keep-alive&gt; 的虚拟节点将对应组件的虚拟节点放入属性对应的缓存，为被包裹的组件额外添加 activated 和 deactivated 的生命周期处理，以达到激活和停用组件的目的。 当组件被激活时，keep-alive 会使用缓存中的组件 VNode 进行渲染，而不是重新创建一个新的 VNode。 这样，缓存的组件实例仍然保持之前的状态，不需要进行重新渲染。 当组件被停用时，keep-alive 会将其放入缓存，组件实例并未销毁，可用来再次激活组件。 可以使用 include 和 exclude 属性来指定哪些组件需要被缓存或排除。 (4) 示例代码 假设我们有两个组件： Home.vue 和 About.vue。当导航从 Home 组件切换到 About 组件时，我们希望保留 Home 组件的状态。 首先，创建两个组件文件：Home.vue 和 About.vue。 123456789101112&lt;!-- Home.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;Home Page&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Home&quot;,&#125;;&lt;/script&gt; 123456789101112&lt;!-- About.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;About Page&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;About&quot;,&#125;;&lt;/script&gt; 接下来，在App.vue文件中设置我们的路由视图以及keep-alive组件。 123456789101112&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;nav&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/nav&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt; 然后，在router.js文件里配置我们的路由。 1234567891011121314151617181920212223// router.jsimport Vue from &quot;vue&quot;;import Router from &quot;vue-router&quot;;import Home from &quot;./components/Home.vue&quot;;import About from &quot;./components/About.vue&quot;;Vue.use(Router);export default new Router(&#123; mode: &quot;history&quot;, routes: [ &#123; path: &quot;/&quot;, name: &quot;home&quot;, component: Home, &#125;, &#123; path: &quot;/about&quot;, name: &quot;about&quot;, component: About, &#125;, ],&#125;); 最后，在项目入口文件main.js中导入路由配置。 1234567891011// main.jsimport Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;Vue.config.productionTip = false;new Vue(&#123; router, render: (h) =&gt; h(App),&#125;).$mount(&quot;#app&quot;); 现在，当你在 Home 和 About 组件之间切换时，组件的状态应该被保留在 keep-alive 组件中。 43. vue2 生命周期与异步请求在 Vue2 中，可以执行异步请求的生命周期函数有以下几个： created：组件实例被创建后，在渲染 DOM 之前执行。 mounted：组件实例被挂载到 DOM 元素上之后执行。 updated：组件数据更新导致的虚拟 DOM 重新渲染后执行。 beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave：在路由导航守卫中执行。 在这些生命周期里，通常推荐在 created 生命周期进行异步请求。理由如下： created 生命周期会在渲染 DOM 之前执行。这意味着，在数据请求返回前，可以进行其他的逻辑处理，例如展示加载状态等。 如果在 mounted 生命周期发起异步请求，可能会让用户在等待数据返回时看到一个空的页面，影响用户体验。 在 updated 生命周期发起异步请求会增加不必要的更新，因为每次数据更新都会触发这个生命周期。 通常情况下，我们需要根据具体需求调用和更新数据。 在路由导航守卫中进行异步请求适用于那些依赖特定路由参数的场景，如需要在页面跳转前获取数据。 综上，对于普通的异步请求推荐使用 created 生命周期。当然，在特定情况下，请根据具体需求选择合适的生命周期。 44. Vue2 v-if vs v-show在 Vue2 中，v-show 和 v-if 是两个用于条件渲染的指令。 下面分别介绍这两个指令的相同点和不同点，以及哪个指令的性能更好。 相同点： 都是用于条件渲染。v-show 和 v-if 这两个指令都可以根据条件去渲染或者隐藏某个 HTML 元素。 不同点： v-if 是”真正”的条件渲染指令，它会根据表达式的值在 DOM 树中插入或者删除对应的元素。 v-show 只是简单地切换元素的 CSS 属性 display，控制元素的显示和隐藏。 当表达式的值为 false 时，v-if 不会渲染元素到 DOM 树中 v-show 无论表达式的值为何始终都会渲染元素，在元素的 display 属性中设置为 none 来控制隐藏。 v-if 由于需要插入和删除 DOM 元素，当条件切换频繁时，对性能消耗较大。 v-show 只是简单地修改 CSS 属性，性能消耗较小。 如果需要频繁切换显示隐藏的场景，建议使用 v-show，因为它只需要修改 CSS 属性，性能开销较小。 如果元素不需要频繁切换，或者切换时需要重新获取数据、处理逻辑等，建议使用 v-if，因为它不会多次渲染不需要的元素，从而减少性能消耗。 45. v-for key问题：v-for 为什么要配合 key 一起使用？ 在 Vue2 中，v-for 和 key 被一起使用是出于性能优化的考虑，有助于提高列表渲染的性能。 v-for 指令是 Vue.js 中用于循环渲染列表元素的一个重要特性。在数据发生变化时，Vue 将更新 DOM 来匹配新的数据。 然而，有时候我们只是对列表进行简单的添加或删除操作，如果每次都重新计算整个列表并重新渲染，则会造成浪费，降低性能。 为解决此问题，Vue 实现了一种名为“就地复用”的策略。 当列表发生变化时，它会尽可能地减少重新创建和销毁 DOM 元素的次数。如果一个元素没有 key，Vue 将尝试使用 tag 复用现有元素。 然而，这种复用策略可能会导致一些问题。例如当列表元素的顺序发生变化时，它可能会导致不必要的更新，从而导致性能问题。 这时我们需要使用 key 属性来指定一个唯一标识符，使得 Vue 可以准确地识别每一个列表项。 key 属性应该为每一个列表项分配一个唯一的值，便于 Vue 知道如何对应新旧元素。 这样，当数据发生变化时，Vue 可以通过 key 属性来识别哪个元素被添加、修改或者删除，从而实现更有效的局部更新，提高列表渲染性能。 46. Vue2 组件通讯在 Vue2 中，我们可以使用以下方式实现组件之间的通信： (1) 父组件向子组件传递数据：通过 props 123456789101112131415161718192021&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;div&gt; &lt;child-component :parent-data=&quot;data&quot;&gt;&lt;/child-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import ChildComponent from &quot;./ChildComponent.vue&quot;; export default &#123; components: &#123; ChildComponent, &#125;, data() &#123; return &#123; data: &quot;父组件数据&quot;, &#125;; &#125;, &#125;;&lt;/script&gt; 123456789101112131415&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;div&gt;&#123;&#123; parentData &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; parentData: &#123; type: String, required: true, &#125;, &#125;, &#125;;&lt;/script&gt; (2) 子组件向父组件传递数据，通过自定义事件和 $emit 123456789101112131415161718192021&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;div&gt; &lt;child-component @child-event=&quot;handleChildEvent&quot;&gt;&lt;/child-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import ChildComponent from &quot;./ChildComponent.vue&quot;; export default &#123; components: &#123; ChildComponent, &#125;, methods: &#123; handleChildEvent(payload) &#123; console.log(&quot;子组件传递的数据：&quot;, payload); &#125;, &#125;, &#125;;&lt;/script&gt; 1234567891011121314&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;button @click=&quot;sendDataToParent&quot;&gt;发送数据至父组件&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; sendDataToParent() &#123; this.$emit(&quot;child-event&quot;, &quot;来自子组件的数据&quot;); &#125;, &#125;, &#125;;&lt;/script&gt; (3) 兄弟组件之间通信需要通过共同的父组件，或者使用事件总线（Event Bus） 首先创建一个新的事件总线实例： 123// event-bus.jsimport Vue from &quot;vue&quot;;export const EventBus = new Vue(); 组件 A 发送数据至组件 B： 123456789101112131415&lt;template&gt; &lt;button @click=&quot;sendDataToSibling&quot;&gt;发送数据至兄弟组件&lt;/button&gt;&lt;/template&gt;&lt;script&gt; import &#123; EventBus &#125; from &quot;@/event-bus.js&quot;; export default &#123; methods: &#123; sendDataToSibling() &#123; EventBus.$emit(&quot;sibling-event&quot;, &quot;来自组件 A 的数据&quot;); &#125;, &#125;, &#125;;&lt;/script&gt; 组件 B 接收数据： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt;接收到的数据：&#123;&#123; receivedData &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; EventBus &#125; from &quot;@/event-bus.js&quot;; export default &#123; data() &#123; return &#123; receivedData: null, &#125;; &#125;, created() &#123; EventBus.$on(&quot;sibling-event&quot;, this.handleSiblingData); &#125;, beforeDestroy() &#123; EventBus.$off(&quot;sibling-event&quot;, this.handleSiblingData); &#125;, methods: &#123; handleSiblingData(payload) &#123; this.receivedData = payload; &#125;, &#125;, &#125;;&lt;/script&gt; 注意：使用事件总线时，不要忘记在组件销毁时移除对应的事件监听，避免内存泄漏。 47. v-model 的实现原理Vue.js 中的 v-model 是实现表单控件与数据双向绑定的指令。 其实现原理主要基于两个部分：数据到视图的绑定（数据驱动视图更新）和视图到数据的绑定（视图驱动数据更新）。 数据到视图的绑定：当数据发生变化时，通过数据劫持（Vue.js 2.x 使用 Object.defineProperty，Vue.js 3.x 使用 Proxy）触发数据变化的侦听函数，然后通过订阅者模式通知相应的指令更新，最后视图更新。 视图到数据的绑定：当用户与视图交互（如输入文本、选择选项等）时，通过监听视图的 input 事件，获取视图的最新值，然后将其赋值给相应的数据，实现视图到数据的绑定。 下面是一个 Vue.js 的代码示例： 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;!-- 使用 v-model 进行双向数据绑定 --&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; message: &quot;&quot;, &#125;; &#125;, &#125;;&lt;/script&gt; 在这个示例中，我们使用 v-model 指令将输入框与 data 中的 message 属性进行双向绑定。当用户输入文本时，视图到数据的绑定将用户的输入赋值给 message 属性；同时，数据到视图的绑定会自动将 message 的最新值更新到视图上，展示在 &lt;p&gt; 标签中。 在原生 JavaScript 中，你可以使用事件监听器和数据代理来实现一个简单的双向数据绑定。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;input&quot; /&gt; &lt;p id=&quot;output&quot;&gt;&lt;/p&gt; &lt;script&gt; // 1. 获取 DOM 元素 const input = document.getElementById(&quot;input&quot;); const output = document.getElementById(&quot;output&quot;); // 2. 初始化一个数据对象 let data = &#123; value: &quot;&quot;, &#125;; // 3. 代理数据对象，监听数据变化 const proxy = new Proxy(data, &#123; set(target, key, value) &#123; target[key] = value; // 更新 DOM output.innerText = value; return true; &#125;, &#125;); // 4. 监听 input 事件，并更新数据对象 input.addEventListener(&quot;input&quot;, (e) =&gt; &#123; proxy.value = e.target.value; &#125;); // 初始更新 proxy.value = &quot;&quot;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这个示例中，我们创建了一个简单的数据代理，使用 Proxy 对象来代理一个初始数据对象并在数据对象的值被设置时更新 DOM。然后，我们使用事件监听器监听 input 元素的输入事件，并在输入值发生变化时更新数据代理对象的值。通过这样的方式，我们实现了一个简单的双向数据绑定。 48. 如何理解 MVVMMVVM（Model-View-ViewModel）模式是一种软件架构设计模式，主要用于分离应用程序的界面表示层（View）和业务逻辑层（Model）。它的核心思想是基于数据驱动的视图更新。ViewModel 作为 View 和 Model 之间的连接器，负责将 Model 中的数据转换成 View 可以显示的数据，并处理从 View 接收到的用户交互事件。MVVM 让应用程序的不同部分更容易分离、测试和维护。 MVVM 的优点如下： 解耦：MVVM 模式可以将 UI（用户界面）和业务逻辑分离，在一定程度上简化了代码编写和程序设计。 双向数据绑定：ViewModel 和 View 之间的数据同步是自动完成的，这意味着当数据发生变化时，不需要手动更新视图，从而减少了很多重复和繁琐的工作。 可维护性：由于 UI 和业务逻辑分离，维护成本较低。当需要更新视图或业务逻辑时，可以只关注对应的部分，而不会对其他部分产生影响。 可测试性：可以对 ViewModel 进行单元测试，提高应用程序的可靠性和健壮性。 可重用性：可以重用 ViewModel 中的代码，提高开发效率。 MVVM 的缺点如下： 过度抽象：当应用程序的功能或逻辑不是很复杂时，MVVM 可能会导致过度抽象，增加了代码的复杂性和学习成本。 内存占用：由于持续监听数据变化和双向绑定，可能导致更高的内存占用和性能损失。 依赖框架：为实现 MVVM，通常需要依赖于特定的框架（如：Vue.js、Angular、React 等），在某种程度上限制了技术选型。 总结一下，MVVM 为前端应用带来了更好的可维护性、可测试性和解耦。它尤其适用于复杂数字、逻辑复杂的大型应用程序。但对于简单的应用程序来说，可能会导致过度抽象和依赖于特定框架。 在 JavaScript 中，Object.create() 是一个用于创建新对象的方法。它是基于现有对象创建新对象的一种方式，新对象可以继承现有对象的属性和方法。 使用 Object.create() 方法时，需要传入一个原型对象作为参数。该方法将返回一个新对象，该对象的原型是传入的原型对象。这个新对象可以通过访问原型对象来获取属性和方法。 以下是一个简单的示例，说明如何使用 Object.create() 方法： 1234567891011121314151617181920// 定义一个原型对象let person = &#123; name: &quot;John&quot;, age: 30, greeting: function () &#123; console.log( &quot;Hello, my name is &quot; + this.name + &quot; and I am &quot; + this.age + &quot; years old.&quot; ); &#125;,&#125;;// 使用 Object.create() 方法创建一个新对象let student = Object.create(person);// 设置新对象的属性student.name = &quot;Jane&quot;;student.age = 20;// 调用新对象的方法student.greeting(); // 输出：Hello, my name is Jane and I am 20 years old. 在这个示例中，我们首先定义了一个名为 person 的原型对象，它有三个属性：name、age 和 greeting。然后，我们使用 Object.create() 方法创建了一个名为 student 的新对象，并将 person 对象作为其原型。最后，我们设置了 student 对象的 name 和 age 属性，并调用了其 greeting() 方法。 需要注意的是，使用 Object.create() 方法创建的新对象并不具有自己的属性和方法，它们都是从原型对象继承而来的。如果需要添加新的属性或方法，可以直接在新对象上定义。 49 computed 计算属性Vue 中的计算属性（Computed properties）是一种特殊类型的属性，它依赖其他属性值的变化进行自动计算和更新。 计算属性的主要作用是将一些复杂的逻辑和计算放入独立的属性中，使 Vue 模板更简洁、可读性更强。 计算属性具有以下特性： 响应式依赖：计算属性依赖其他响应式属性值，当依赖属性值发生变化时，计算属性自动更新。 缓存优化：计算属性具有缓存机制，只有当依赖的属性值发生变化时，计算属性才重新计算值。否则，直接使用缓存的值。 可读性：通过计算属性可以将复杂数值计算和转换逻辑移到独立的属性中，使 Vue 模板更简洁、便于理解和维护。 支持 getter 和 setter：计算属性默认只有 getter 方法，但也可以指定一个 setter 方法，实现对计算属性的赋值操作。 实际项目中，计算属性的应用主要包括： 动态计算属性值：当一个属性值依赖于其他属性值时，可以使用计算属性。 格式化显示数据：当需要对数据进行格式化或转换时，可以使用计算属性。 过滤数组或对象：当需要根据一定条件筛选出数据列表或对象的子集时，可以使用计算属性。 以下是一个代码示例： 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;input v-model=&quot;firstName&quot; placeholder=&quot;First Name&quot; /&gt; &lt;input v-model=&quot;lastName&quot; placeholder=&quot;Last Name&quot; /&gt; &lt;p&gt;Full name: &#123;&#123; fullName &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; firstName: &quot;John&quot;, lastName: &quot;Doe&quot;, &#125;; &#125;, computed: &#123; // 计算属性 fullName 依赖于 firstName 和 lastName fullName() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;, &#125;, &#125;;&lt;/script&gt; 在这个示例中，我们有两个输入框，用于填写名和姓。我们定义了一个计算属性 fullName，它的值依赖于 firstName 和 lastName。当我们在输入框中更改名字或姓氏时，fullName 自动更新，显示完整的名字。这使我们的模板非常简洁，便于理解。 50. vue data 函数为什么 vue 中的 data 配置项必须是一个函数? 在 Vue 中，data 配置项必须是一个函数，主要原因是为了避免组件实例之间共享数据。 若不是一个函数，那么所有组件实例将引用相同的数据对象，这样当其中一个组件实例改变数据时，其他组件实例中的数据也将受到影响。 假设我们有一个简单的组件，用于显示一个计数器： 12345678Vue.component(&quot;counter&quot;, &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, data: function () &#123; return &#123; count: 0, &#125;; &#125;,&#125;); 我们将 data 配置项定义为一个函数，它返回一个对象，包含该组件实例的初始数据。 在这个例子中，我们为每个 counter 组件实例定义了一个 count 属性，并将其初始值设置为 0。 当我们在应用程序中多次使用 counter 组件时： 12345&lt;div id=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt; 每个组件实例都会拥有自己独立的 count 数据。可以想象，如果我们将 data 直接定义为一个对象，如下所示： 123456Vue.component(&quot;counter&quot;, &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, data: &#123; count: 0, &#125;,&#125;); 那么所有的 counter 组件实例将共享同一个 count 数据，并且当一个实例的 count 值发生变化时，其他实例的 count 值也会受到影响。 因此，将 data 定义为一个函数，确保了每个组件实例都能拥有独立的数据副本，从而避免了潜在的问题。 51. vue2 抽取逻辑如何将多个组件中的公共逻辑抽取出来？ 在 Vue2 中，有两种主要的方式可以将多个组件中的相同逻辑抽取出来： Mixins（混入） 和高阶组件（Higher-Order Components，简称 HOC）。 Mixins（混入） Mixins 是一种在多个组件之间共享可复用的功能的方法。一个 mixin 的方法可以被其他组件混入，这样这些组件就可以获得 mixin 中定义的数据、组件、指令、生命周期方法等。 假设我们有以下相同逻辑需要在多个组件中使用： 12345678910111213141516// commonLogic.jsexport default &#123; data() &#123; return &#123; message: &quot;Hello from mixin!&quot;, &#125;; &#125;, created() &#123; console.log(this.message); &#125;, methods: &#123; showAlert() &#123; alert(this.message); &#125;, &#125;,&#125;; 在其他组件中使用 Mixin： 1234567// ComponentA.vueimport commonLogic from &quot;./commonLogic.js&quot;;export default &#123; mixins: [commonLogic], // ...&#125;; 1234567// ComponentB.vueimport commonLogic from &quot;./commonLogic.js&quot;;export default &#123; mixins: [commonLogic], // ...&#125;; 高阶组件（Higher-Order Components） 高阶组件（HOC）是一个接收组件作为参数并返回一个新组件的函数。该新组件包含了原组件的所有功能，并且可以向原组件注入新的逻辑。 1234567891011121314151617181920212223242526// withCommonLogic.jsexport default function withCommonLogic(WrappedComponent) &#123; return &#123; name: `withCommonLogic($&#123;WrappedComponent.name&#125;)`, data() &#123; return &#123; message: &quot;Hello from HOC!&quot;, &#125;; &#125;, created() &#123; console.log(this.message); &#125;, methods: &#123; showAlert() &#123; alert(this.message); &#125;, &#125;, render(h) &#123; return h(WrappedComponent, &#123; props: this.$props, on: this.$listeners, scopedSlots: this.$scopedSlots, &#125;); &#125;, &#125;;&#125; 在其他组件中使用 HOC： 1234567// ComponentA.vueimport withCommonLogic from &quot;./withCommonLogic.js&quot;;export default withCommonLogic(&#123; name: &quot;ComponentA&quot;, // ...&#125;); 1234567// ComponentB.vueimport withCommonLogic from &quot;./withCommonLogic.js&quot;;export default withCommonLogic(&#123; name: &quot;ComponentB&quot;, // ...&#125;); 以上两种方法都可以在 Vue2 中将多个组件中的相同逻辑抽取出来。你可以根据具体的需求和项目场景决定使用哪种方式。 52. vue2 异步组件异步组件在 Vue.js 中可以帮助我们实现代码分割和按需加载，优化性能和加载速度。这对于大型应用程序是非常有用的。以下是 4 个场景的例子： (1) 路由懒加载 可以把某个路由对应的组件编写成异步组件，这样在初始加载时，只需要加载首页的组件，其他页面的组件可以在实际访问时按需加载。 1234567891011121314import Vue from &quot;vue&quot;;import Router from &quot;vue-router&quot;;Vue.use(Router);const Foo = () =&gt; import(&quot;@/components/Foo.vue&quot;);const Bar = () =&gt; import(&quot;@/components/Bar.vue&quot;);export default new Router(&#123; routes: [ &#123; path: &quot;/foo&quot;, component: Foo &#125;, &#123; path: &quot;/bar&quot;, component: Bar &#125;, ],&#125;); (2) 按需加载弹窗组件 某些场景下，我们需要在用户点击某个按钮后展示一个弹窗组件。这种组件在页面加载时可能并不需要，可以使用异步组件按需加载。 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;openModal&quot;&gt;打开弹窗&lt;/button&gt; &lt;Modal v-if=&quot;showModal&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const Modal = () =&gt; import(&quot;@/components/Modal.vue&quot;); export default &#123; data() &#123; return &#123; showModal: false, &#125;; &#125;, components: &#123; Modal &#125;, methods: &#123; openModal() &#123; this.showModal = true; &#125;, &#125;, &#125;;&lt;/script&gt; (3) 大型选项卡式应用 在一个包含多个选项卡的应用中，可以将每个选项卡对应的组件编写为异步组件，这样可以在切换选项卡时按需加载相应的组件。 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;tabs&gt; &lt;tab name=&quot;A&quot; :component=&quot;A&quot;&gt;&lt;/tab&gt; &lt;tab name=&quot;B&quot; :component=&quot;B&quot;&gt;&lt;/tab&gt; &lt;tab name=&quot;C&quot; :component=&quot;C&quot;&gt;&lt;/tab&gt; &lt;/tabs&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const A = () =&gt; import(&quot;@/components/A.vue&quot;); const B = () =&gt; import(&quot;@/components/B.vue&quot;); const C = () =&gt; import(&quot;@/components/C.vue&quot;); export default &#123; components: &#123; A, B, C, &#125;, &#125;;&lt;/script&gt; (4) 根据不同设备加载不同组件 当我们需要根据不同设备展示不同的组件时，可以在运行时动态加载相应的异步组件。 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;component :is=&quot;currentComponent&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const DesktopComponent = () =&gt; import(&quot;@/components/DesktopComponent.vue&quot;); const MobileComponent = () =&gt; import(&quot;@/components/MobileComponent.vue&quot;); export default &#123; data() &#123; return &#123; currentComponent: null, &#125;; &#125;, created() &#123; if (window.innerWidth &lt; 768) &#123; this.currentComponent = MobileComponent; &#125; else &#123; this.currentComponent = DesktopComponent; &#125; &#125;, &#125;;&lt;/script&gt; 53. vue 作用域插槽Vue 中的作用域插槽（Scoped Slots）是一种特殊类型的插槽，它允许父组件向子组件传递数据，同时还允许子组件在其插槽中使用该数据。这使得子组件可以更灵活地渲染父组件传递的数据，而不仅仅是简单地显示它们。 1234567891011121314151617181920&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;div&gt; &lt;child-component&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.message &#125;&#125; World! &lt;/template&gt; &lt;/child-component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import ChildComponent from &quot;./ChildComponent.vue&quot;; export default &#123; components: &#123; ChildComponent, &#125;, &#125;;&lt;/script&gt; 12345678910111213141516&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;div&gt; &lt;slot :message=&quot;message&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; message: &quot;Hello&quot;, &#125;; &#125;, &#125;;&lt;/script&gt; 在这个示例中，父组件包含一个名为 child-component 的子组件。父组件使用 v-slot 指令来定义一个默认插槽，并将其绑定到一个名为 slotProps 的变量上。该变量是一个对象，其中包含子组件需要使用的数据。在这种情况下，子组件需要使用名为 message 的数据。 子组件包含一个名为 message 的数据属性，并将其传递给插槽。父组件中的模板使用 slotProps.message 来访问该数据，并将其与字符串 World!连接起来。 54. vuex action mutation在 Vuex 中，mutation 和 action 都是用于管理应用程序状态的重要概念。 它们的作用是不同的，mutation 用于修改状态，而 action 用于处理异步逻辑。 mutation 是 Vuex 中用于修改状态的方法。它们必须是同步的，这意味着它们不能包含异步逻辑。mutation 只能通过提交(commit)来调用。 下面是一个简单的示例： 123456789101112const store = new Vuex.Store(&#123; state: &#123; count: 0, &#125;, mutations: &#123; increment(state) &#123; state.count++; &#125;, &#125;,&#125;);store.commit(&quot;increment&quot;); action 是 Vuex 中用于处理异步逻辑的方法。它们可以包含任何异步代码，例如 API 调用或 setTimeout()函数。action 可以通过 dispatch 来调用。 12345678910111213141516171819const store = new Vuex.Store(&#123; state: &#123; count: 0, &#125;, mutations: &#123; increment(state) &#123; state.count++; &#125;, &#125;, actions: &#123; incrementAsync(context) &#123; setTimeout(() =&gt; &#123; context.commit(&quot;increment&quot;); &#125;, 1000); &#125;, &#125;,&#125;);store.dispatch(&quot;incrementAsync&quot;); 55. vue router 路由模式Vue Router 提供了三种路由模式：hash 模式、history 模式和 abstract 模式。 (1) Hash 模式 Hash 模式使用 URL 的 hash 部分（即#号后面的内容）来管理路由。在这种模式下，当 URL 的 hash 部分发生变化时，Vue Router 会自动更新视图。Hash 模式不需要服务器配置，因此它非常适合在静态文件服务器上部署单页应用程序。 1234const router = new VueRouter(&#123; mode: &#x27;hash&#x27;, routes: [...]&#125;) (2) History 模式 History 模式使用 HTML5 History API 来管理路由。在这种模式下，URL 的路径部分被用来管理路由。当 URL 的路径部分发生变化时，Vue Router 会自动更新视图。History 模式需要服务器配置，以便在用户直接访问页面时正确地响应请求。 1234const router = new VueRouter(&#123; mode: &#x27;history&#x27;, routes: [...]&#125;) (3) Abstract 模式 Abstract 模式不会改变浏览器的 URL，而是将路由信息保存在内存中。这种模式常用于服务器端渲染或单元测试中。 1234const router = new VueRouter(&#123; mode: &#x27;abstract&#x27;, routes: [...]&#125;) 在选择路由模式时，需要考虑以下几个因素： 服务器配置：如果你的应用程序需要在服务器上运行，则需要选择支持 HTML5 History API 的路由模式。 SEO 优化：如果你的应用程序需要进行 SEO 优化，则需要选择支持 HTML5 History API 的路由模式。 兼容性：如果你的应用程序需要在旧版浏览器上运行，则需要选择支持 Hash 模式的路由模式。 综上所述，选择哪种路由模式取决于你的应用程序的需求和服务器配置。 在大多数情况下，我们建议使用 History 模式，因为它可以提供更好的用户体验和 SEO 优化。 55. JavaScript 模拟前端路由前端路由可以通过监听 URL 的变化，并根据 URL 的不同渲染不同的视图来实现。下面是使用 JavaScript 模拟前端路由的示例代码： 12345678910111213141516171819202122232425262728293031const routes = &#123; &quot;/&quot;: home, &quot;/about&quot;: about, &quot;/contact&quot;: contact,&#125;;const content = document.querySelector(&quot;.content&quot;);function render(path) &#123; content.innerHTML = routes[path];&#125;function router() &#123; const path = window.location.pathname; render(path);&#125;window.addEventListener(&quot;popstate&quot;, router);document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; &#123; document.body.addEventListener(&quot;click&quot;, (e) =&gt; &#123; if (e.target.tagName === &quot;A&quot;) &#123; e.preventDefault(); const href = e.target.getAttribute(&quot;href&quot;); window.history.pushState(null, null, href); router(); &#125; &#125;); router();&#125;); 在这个示例中，我们首先定义了一个 routes 对象，其中包含了不同路径对应的视图。 然后，我们定义了一个 render 函数，用于根据 URL 渲染不同的视图。 接下来，我们定义了一个 router 函数，用于监听 popstate 事件并根据 URL 的变化渲染不同的视图。我们还在 DOMContentLoaded 事件中添加了一个事件监听器，用于处理用户点击链接时的行为。当用户点击链接时，我们使用 pushState 方法将新的 URL 添加到浏览器历史记录中，并调用 router 函数来渲染新的视图。 最后，在 DOMContentLoaded 事件中调用 router 函数来初始化路由，并开始监听 popstate 事件的触发。 需要注意的是，这只是一个简单的示例代码，实际的前端路由实现可能需要更复杂的逻辑和处理。 在 JavaScript 中，执行顺序是由事件循环（Event Loop）来实现的。事件循环中主要有两种任务：宏任务（Macro-task）和微任务（Micro-task）。DOM 渲染通常在宏任务和微任务之间执行。 执行顺序如下： 首先处理宏任务（例如整个 script 代码执行完毕） 完成 DOM 渲染。 处理微任务队列中的所有微任务 进行下一轮的宏任务（例如 setTimeout） 依赖注入（Dependency Injection，简称 DI）是一种软件设计模式，它通过将对象的依赖关系从对象内部解耦，使得对象实例在运行时可以更加灵活地接收依赖项。依赖注入主要有以下好处： 提高了代码的可维护性，使得组件之间的耦合度降低。 提高了代码的可测试性，因为依赖关系可以根据测试需求动态注入。 下面举一个简单的 TypeScript 代码例子说明依赖注入的工作方式。 假设我们需要为一个电子商务系统设计一个购物车功能。购物字功能内部需要调用一系列子服务，例如库存服务、付款服务和邮寄服务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 定义子服务interface IStockService &#123; checkStock(product: string): boolean;&#125;interface IPayService &#123; pay(amount: number): boolean;&#125;interface IShippingService &#123; ship(products: string[], address: string): boolean;&#125;// 创建依赖于子服务的购物车类class ShoppingCart &#123; private stockService: IStockService; private payService: IPayService; private shippingService: IShippingService; constructor( stockService: IStockService, payService: IPayService, shippingService: IShippingService ) &#123; this.stockService = stockService; this.payService = payService; this.shippingService = shippingService; &#125; purchase(products: string[], address: string): boolean &#123; for (const product of products) &#123; if (!this.stockService.checkStock(product)) &#123; console.log(`库存不足: $&#123;product&#125;`); return false; &#125; &#125; const amount = products.length * 10; if (!this.payService.pay(amount)) &#123; console.log(&quot;付款失败&quot;); return false; &#125; if (!this.shippingService.ship(products, address)) &#123; console.log(&quot;邮寄失败&quot;); return false; &#125; console.log(&quot;购物成功&quot;); return true; &#125;&#125; 在这个例子中，购物车类（ShoppingCart）的实例需要接收三个子服务实例作为创建实例的输入。这样做的好处是： 查看购物车类，可以很明显地看到它依赖于哪些子服务，便于理解和维护。 在运行时，可以根据需要灵活地为购物车类注入不同版本的子服务，例如在测试环境中使用模拟数据的子服务。 为了完成依赖注入，你需要创建子服务的实现类并将它们传递给购物车类。例如，你可以这样使用购物车类： 12345678910111213141516171819202122232425262728293031// 定义子服务的实现类class StockService implements IStockService &#123; checkStock(product: string): boolean &#123; return true; // 在实际项目中，此处应从数据库或其他来源检查库存 &#125;&#125;class PayService implements IPayService &#123; pay(amount: number): boolean &#123; return true; // 在实际项目中，此处应调用支付接口完成付款 &#125;&#125;class ShippingService implements IShippingService &#123; ship(products: string[], address: string): boolean &#123; return true; // 在实际项目中，此处应调用物流接口完成邮寄 &#125;&#125;// 实例化子服务const stockService = new StockService();const payService = new PayService();const shippingService = new ShippingService();// 依赖注入：实例化购物车类，并将子服务的实例注入const shoppingCart = new ShoppingCart( stockService, payService, shippingService);shoppingCart.purchase([&quot;product-1&quot;, &quot;product-2&quot;], &quot;北京市海淀区&quot;); 在这个例子中，我们首先实现了子服务的实现类，接着创建了子服务的实例，最后将他们注入到购物车类中。这样就实现了购物车类对子服务的灵活依赖。","tags":["面试题"],"categories":["前端面试题"]},{"title":"CSS面试题","path":"/面试题/CSS面试题/","content":"CSS 高频面试题01. 盒模型宽度计算在如下代码中类名为 box 的 div，它的 offsetWidth 是多少? 123456789101112&lt;style&gt; #box &#123; width: 100px; padding: 10px; border: 1px solid skyblue; margin: 10px; &#125;&lt;/style&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;script&gt; console.log(document.getElementById(&quot;box&quot;).offsetWidth);&lt;/script&gt; offsetWidth &#x3D; 内容宽度 + 内边距 + 边框 box 的内容宽度为 100、左右内边距各为 10、左右边框各为 1、所以盒子的 offsetWidth 为 122。 通过 box-sizing 可以设置到底要如何计算一个元素的总宽度和总高度。 它的默认值为 content-box，即指定 width 属性值为内容宽度，盒子的实际宽度为内容宽度 + 内边距 + 边框。 它的值也可以是 border-box，即指定 width 属性值为盒子的总宽度，在设置了内边距和边框的情况下会挤压盒子内容的宽度。 02. 外边距负值外边距在四个方向上设置负值会产生什么效果。 margin-top 设置正值元素向下移动、设置负值向上移动。 margin-left 设置正值元素向右移动、设置负值向左移动。 margin-right 设置正值右侧元素向左移动、设置负值右侧元素向右移动。 margin-bottom 设置正值下方元素向上移动，设置负值下方元素向下移动。 1234567891011121314&lt;style&gt; .box1 &#123; width: 100px; height: 100px; background: skyblue; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; &#125;&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; 03. 外边距重叠① 什么是外边距重叠 两个块级元素的上外边距和下外边距可能会合并为一个外边距，这种现象被称之为外边距重叠。 外边距重叠只发生在垂直方向，水平方向不会重叠。浮动的元素和绝对定位的元素的外边距不会折叠。 ② 外边距重叠的计算方式 (1) 如果两者都是正数，取最大值为最终的外边距值。 12345678910111213141516&lt;style&gt; .box1 &#123; width: 100px; height: 100px; background: skyblue; margin-bottom: 20px; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; margin-top: 30px; &#125;&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; (2) 如果两者一正一负，使用正值减去负值的绝对值，得到的结果为最终的外边距值。 12345678910111213141516&lt;style&gt; .box1 &#123; width: 100px; height: 100px; background: skyblue; margin-bottom: 20px; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; margin-top: -10px; &#125;&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; (3) 如果两者都是负值，使用 0 减去两个中值中绝对值大的那个，得到的结果为最终的外边距值 1234567891011121314&lt;style&gt; .box1 &#123; width: 100px; height: 100px; background: skyblue; margin-bottom: -20px; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; margin-top: -10px; &#125;&lt;/style&gt; ③ 如何解决外边距重叠 (1) 不要同时为两个相邻的块级元素同时设置垂直方向上的边距(推荐) (2) 为下层元素设置浮动或定位(绝对定位、固定定位)或 inline-block 04. 外边距塌陷① 什么是外边距塌陷 两个嵌套关系的(一般为父子关系)块元素，当父元素有上外边距子元素也有上外边距时，两个上外边距会合成一个上外边距。 12345678910111213141516171819&lt;style&gt; body &#123; margin: 0; &#125; .box1 &#123; width: 100px; background: skyblue; margin-top: 10px; &#125; .box2 &#123; width: 100px; height: 100px; background: purple; margin-top: 10px; &#125;&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt; ② 如何解决外边距塌陷 (1) 为父元素设置 overflow: auto&#x2F;hidden (2) 为父元素设置浮动 (3) 为父元素设置 display: inline-block (4) 为父元素设置 border: 1px solid transparent (5) 为父元素设置 padding: 1px 05. 清除浮动子元素浮动后父元素高度撑不开的问题如何解决 12345678910111213141516&lt;style&gt; .parent &#123; width: 100%; background: skyblue; &#125; .item &#123; width: 200px; height: 100px; background: purple; float: left; &#125;&lt;/style&gt;&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;&lt;/div&gt; ① 为父级元素添加 overflow: hidden 或 overflow: auto 123.parent &#123; overflow: hidden;&#125; ② 通过伪类元素解决浮动父级元素高度问题 1234567.clearfix::after &#123; content: &quot; &quot;; visibility: hidden; display: block; height: 0; clear: both;&#125; 1&lt;div class=&quot;parent clearfix&quot;&gt;&lt;/div&gt; 06. 理解 BFC① 什么是 BFC BFC 全称 Block Formatting Context， 意为块级格式化上下文。 BFC 其实就是指一块能够独立渲染的区域，并对这块区域内部的块级元素如何布局进行了规定。 比如块级元素默认在盒子的左上角进行渲染、块级盒子独占一行垂直排列、块级盒子之间的间距由 margin 设置。 由于通过 BFC 产生了一块独立渲染的区域，所以该区域内的元素无论怎样布局都不会影响到区域以外的元素。 只有块级元素可以具备 BFC 特性。 通过理解和 BFC 相关的知识能够对布局过程中产生问题进行快速解决，比如外边距重叠、外边距塌陷、浮动父级高度无法撑开等问题。 ② 如何使元素具有 BFC 特性 (1) 根元素(HTML) (2) 浮动之后的元素(float 属性的值不为 none) (3) 绝对定位和固定定位之后的元素 (4) 行内块元素 (5) 表格单元格(display: table-cell)、表格标题(display: table-caption) (6) overflow 属性值不为 visible 的块元素 (7) 弹性盒元素(display: flex) (8) 网格元素 (display: grid) ③ BFC 特性 在同一个 BFC 中相邻的两个块级元素垂直方向上的外边距会被折叠 BFC 盒子的不会与浮动盒子产生交集而是紧贴着浮动元素的边缘 计算 BFC 盒子的高度时也会检测浮动盒子的高度 07. 圣杯布局① 什么是圣杯布局 圣杯布局是指三栏布局，左右两栏宽度固定、中间宽度自适应。 在圣杯布局中要求中间一栏最先加载出来。 ② 实现圣杯布局 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; body &#123; margin: 0; &#125; .container &#123; padding: 0 150px 0 200px; &#125; .column &#123; float: left; &#125; .left &#123; width: 200px; background: skyblue; margin-left: -100%; position: relative; left: -200px; &#125; .center &#123; width: 100%; background: purple; &#125; .right &#123; width: 150px; background: palegreen; margin-left: -150px; position: relative; left: 150px; &#125; .clearfix::after &#123; content: &quot; &quot;; visibility: hidden; display: block; height: 0; clear: both; &#125;&lt;/style&gt;&lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;center column&quot;&gt;center&lt;/div&gt; &lt;div class=&quot;left column&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right column&quot;&gt;right&lt;/div&gt;&lt;/div&gt; 08. 双飞翼布局① 什么是双飞翼布局 双飞翼布局和圣杯布局一样都是要实现三栏布局，两侧栏宽度固定，中间栏宽度自适应。 ② 实现双飞翼布局 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; body &#123; margin: 0; &#125; .main-wrap &#123; width: 100%; background: purple; &#125; .main &#123; margin: 0 150px 0 200px; &#125; .column &#123; float: left; &#125; .left &#123; width: 200px; background: skyblue; margin-left: -100%; &#125; .center &#123; width: 100%; &#125; .right &#123; width: 150px; background: palegreen; margin-left: -150px; &#125; .clearfix::after &#123; content: &quot; &quot;; visibility: hidden; display: block; height: 0; clear: both; &#125;&lt;/style&gt;&lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;main-wrap column&quot;&gt; &lt;div class=&quot;main&quot;&gt;center&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left column&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right column&quot;&gt;right&lt;/div&gt;&lt;/div&gt; 09. 弹性盒布局1234567891011121314151617181920212223242526&lt;style&gt; .container &#123; width: 1200px; height: 500px; border: 2px solid #000; &#125; .item &#123; width: 200px; height: 100px; &#125; .item_1 &#123; background: skyblue; &#125; .item_2 &#123; background: purple; &#125; .item_3 &#123; background: orangered; &#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item item_1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item item_2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item item_3&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456789.container &#123; /* 通过 display: flex 将 container 设置为弹性容器 container 的直接一级子元素自动成为弹性盒子 弹性盒子默认按照主轴方向进行排列, 而主轴方向默认又是水平的, 从左到右 所以当 container 被设置为弹性容器以后, 弹性盒子自动在水平方向上从左到右排列 */ display: flex;&#125; 123456789101112.container &#123; /* 通过 justify-content 可以设置弹性盒子在主轴方向上的对应方式 flex-start: 左对齐 flex-end: 右对齐 center: 居中对齐 space-between: 盒子与盒子之间平均分配空间(不包含第一个盒子的左边和最后一个盒子的右边) space-evenly: 在盒子与盒子之间凭据分配间距(包含第一个盒子的左边和最后一个盒子的右边) space-around: 在盒子的两边凭据分配间距 */ justify-content: space-around;&#125; 123456789.container &#123; /* 通过 align-items 可以设置弹性盒子在侧轴方向上的对齐方式 flex-start: 顶对齐 flex-end: 底对齐 center: 垂直居中对齐 */ align-items: center;&#125; 1234567.container &#123; align-items: center;&#125;.item_3 &#123; /* 通过 align-self 属性可以单独设置某一个弹性盒子的侧轴方向上的对齐方式 */ align-self: flex-end;&#125; 123456789.container &#123; /* 设置弹性盒子在主轴方向上左对齐 */ justify-content: flex-start;&#125;.item_3 &#123; /* 通过 margin auto 可以单独设置某一个弹性盒子在主轴方向上位置 */ /* 将第三个盒子推向最右侧 */ margin-left: auto;&#125; 1234.item_2 &#123; /* 当父级有剩余空间时, 通过扩展当前元素的宽度占据所有剩余空间 */ flex-grow: 1;&#125; 12345678910/* 将父级剩余空间划分为4分, 通过扩展弹性盒子占据剩余空间, item_1, item_3 占四分之一, item_2 占四分之二*/.item_1 &#123; flex-grow: 1;&#125;.item_2 &#123; flex-grow: 2;&#125;.item_3 &#123; flex-grow: 1;&#125; 123456789.container &#123; width: 1200px;&#125;.item &#123; width: 500px;&#125;/* 当父级宽度不足以放置所有弹性盒子时, 所有弹性盒子的宽度默认会被缩减, 直到父级可以放置所有弹性盒子*/ 1234567.item_1 &#123; /* 通过 flex-shrink 属性可以改变盒子缩减行为, 它的默认值为1, 即每个盒子的缩减比例一致 可以将 flex-shrink 属性的值设置为 0, 表示不缩减当前盒子, 增加其他盒子的缩减比例 */ flex-shrink: 0;&#125; 1234.item &#123; width: 500px; flex-shrink: 0;&#125; 1234.container &#123; /* 当弹性容器的宽度不够时, 可以通过设置 flex-wrap: wrap 让弹性盒子换行显示 */ flex-wrap: wrap;&#125; 1234.container &#123; /* 通过 align-content 属性可以设置弹性盒子的行对齐方式 */ align-content: flex-start;&#125; 12345678910/* 通过 order 属性可以调整元素的显示顺序 */.item_1 &#123; order: 3;&#125;.item_2 &#123; order: 1;&#125;.item_3 &#123; order: 2;&#125; 12345678910111213.container &#123; /* 通过设置 flex-direction 属性可以调整主轴方向, 默认值为 row, 即主轴方向为水平, 盒子从左到右排列 flex-direction: column 设置主轴方向为垂直, 盒子从上到下排列 flex-direction: column-reverse 设置主轴方向为垂直, 盒子从下到上排列 flex-direction: row-reverse 设置主轴方向为水平, 盒子从右到左排列 */ flex-direction: column; /* 设置盒子在主轴方向居中对齐 (垂直) */ justify-content: center; /* 设置盒子在侧轴方向居中对齐 (水平) */ align-items: center;&#125; 10. 定位12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;style&gt; /* 定位是指确定元素的位置 元素位置的调整可以有不同的参数对象 可以参数自身, 可以参考有定位的父级, 可以参数浏览器窗口 css 中可以通过 position 属性来确认元素位置调整时的参数对象 */ /* 静态定位 position: static; 元素在不设置定位时, 元素的 position 属性值就是 static 一般在使用它时都是在取消该元素的其他定位特性. */ /* 相对定位 position: relative 相对定位的元素是相对于元素自身在文档流中原本的位置进行定位 采用相对定位的元素没有脱离文档流, 所以当相对定位的元素被调整位置时, 原有位置会被保留, 不会影响文档流中的其他元素的位置 一般在进行网页布局时, 极少改变相对定位元素的位置 极大多数情况下, 相对定位的元素都是为绝对定位的元素提供位置参考 */ /* 绝对定位 position: absolute 绝对定位的元素参考它最近的有定位的父级元素进行定位, 该定位可以是 sticky relative absolute fixed 若没有定位父级, 则参考窗口元素的位置进行定位 设置了绝对定位的元素会脱离正常的文档流, 元素原有位置将会被其他元素占据，可以使用绝对定位实现盒子堆叠效果 */ /* 固定定位 position: fixed; 设置了固定定位的元素, 它的位置参考浏览器窗口, 在页面内容滚动时, 它的位置不会改变。 设置了固定定位的元素会脱离文档流, 原有位置将会被其他元素占据。 */ /* 黏性定位 position: sticky 相对于父级进行固定定位, 当父级元素出现在窗口中并进行滚动时, 粘性定位的元素出现 fixed 定位效果 当父级元素离开窗口后, 粘性定位随父级元素离开窗口 注意父级元素不需要设置任何定位 */ .outer &#123; width: 800px; height: 2000px; background-color: #ccc; &#125; .inner &#123; width: 200px; height: 100px; background-color: skyblue; position: sticky; top: 100px; left: 0; &#125; .box &#123; width: 800px; height: 2000px; background-color: purple; &#125;&lt;/style&gt;&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;!-- 问题：两个元素, 一个固定定位, 一个绝对定位, 它们两个都相对于窗口定位, 它们有什么区别。 --&gt; 11. 盒子水平垂直居中1&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 1234567891011/* 知道元素宽高的情况下 */.box &#123; width: 100px; height: 100px; background: skyblue; position: absolute; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px;&#125; 12345678910/* 不知道元素宽高的情况下 */.box &#123; width: 100px; height: 100px; background: skyblue; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);&#125; 123456789101112/* 知道元素宽高的情况下 */.box &#123; width: 100px; height: 100px; background: skyblue; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto;&#125; 123456789101112131415161718&lt;style&gt; .wrap &#123; width: 100%; height: 500px; border: 2px solid skyblue; display: flex; justify-content: center; align-items: center; &#125; .box &#123; width: 100px; height: 100px; background: skyblue; &#125;&lt;/style&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819&lt;style&gt; .wrap &#123; width: 800px; height: 500px; border: 2px solid skyblue; display: table-cell; text-align: center; vertical-align: middle; &#125; .box &#123; width: 100px; height: 100px; display: inline-block; background: skyblue; &#125;&lt;/style&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12. 多行文本垂直居中12345678910111213141516171819&lt;style&gt; .wrap &#123; width: 100px; height: 500px; border: 2px solid skyblue; display: table; &#125; .box &#123; width: 100%; height: 100%; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;box&quot;&gt; 多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本 &lt;/div&gt;&lt;/div&gt; 13. 行高如何继承12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; font-size: 20px; /* 直接被子元素继承, 即子元素的行高就是 20px */ /* line-height: 20px; */ /* 子元素继承该行高后, 会使用子元素字体大小乘以行高比例, 16 * 1.4 = 24 */ /* line-height: 1.5; */ /* 当行高值写成百分比以后, 会先使用当前字体大小乘以该百分比, 得到的值会被子元素继承, 20 * 2 = 40px */ line-height: 200%; &#125; .wrap &#123; font-size: 16px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;wrap&quot;&gt;这是一段文字&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 14. rem 单位rem 是 css 中的长度单位用于实现移动端适配。 移动端适配是指页面元素的宽、高都要随着设备的宽度进行等比缩放，即移动设备的宽度大，页面元素大，移动设备的宽度小，页面元素小。 rem 是一个相对单位，相对于根元素的字体大小进行计算。 比如根元素的字体大小是 20px，那么 1rem 就等于 20px，那么宽度 5rem 和高度 3rem 的盒子最终的宽高就为 100px，高度就为 60px。 123456789html &#123; font-size: 20px;&#125;.box &#123; /* 100px */ width: 5rem; /* 60px */ height: 3rem;&#125; 要实现移动端适配效果，rem 单位需要和 css 中的媒体查询进行配合使用。 通过媒体查询检测设备的视口宽度，针对不同的设备视口宽度为根元素设置不同的字号大小。 如果设备视口宽度较大就为其设置较大的字号大小，如果设备的视口宽度较小就为其设置较小的字号大小。 1234567891011@media (width: 375px) &#123; html &#123; font-size: 20px; &#125;&#125;@media (width: 414px) &#123; html &#123; font-size: 30px; &#125;&#125; 在真实的项目开发中针对不同的设备的视口宽度，根元素的字号大小要如何进行设置呢？ 在 rem 移动端适配方案中，我们通常将网页宽度等分为十份，然后将根元素的字号大小设置为视口宽度的十分之一，这样就将视口宽度和字号进行了关联。 1234567891011121314151617@media (width: 320px) &#123; html &#123; font-size: 32px; &#125;&#125;@media (width: 375px) &#123; html &#123; font-size: 37.5px; &#125;&#125;@media (width: 414px) &#123; html &#123; font-size: 41.4px; &#125;&#125; 设计稿的宽度是 750px，设计稿中有一个盒子的宽高分别为 100px 和 50px，如何将它们转换为 rem 单位？ 我们可以将设计稿的宽度看成是某一个移动设备的视口宽度，那么在该视口宽度下根元素的字号大小为 75px。 我们只需要使用 100px 除以 75px ，50px 除以 75px，就可以得到盒子的对应的宽高 rem 值。 1234567891011@media (width: 750px) &#123; html &#123; font-size: 75px; &#125;&#125;.box &#123; /* 盒子原本的像素值除以根元素字号大小: 100 / 75 = 1.333 50 / 75 = 0.666 */ width: 1.333rem; height: 0.666rem; background: skyblue;&#125; 通过 VSCode 编辑器中的 px to rem &amp; rpx &amp; vw (cssrem) 插件自动计算 rem 值。 先在 VSCode 编辑器中安装该插件，然后在 VSCode 编辑器的配置文件中设置参考的根元素字号大小 触发转换的快捷键默认为 Alt+Z 123&#123; &quot;cssrem.rootFontSize&quot;: 75&#125; 改进媒体查询以适配所有移动端设备 123456789101112@media (min-width: 320px) &#123;&#125;@media (min-width: 481px) &#123;&#125;@media (min-width: 641px) &#123;&#125;@media (min-width: 961px) &#123;&#125;@media (min-width: 1025px) &#123;&#125;@media (min-width: 1281px) &#123;&#125; 也可以通过 flexible.js 替换媒体查询，该 js 可以动态获取设备的视口宽度，为根元素动态设置十分之一的字号大小。 12345678910111213141516171819202122232425262728293031323334353637383940414243(function flexible(window, document) &#123; var docEl = document.documentElement; var dpr = window.devicePixelRatio || 1; // adjust body font size function setBodyFontSize() &#123; if (document.body) &#123; document.body.style.fontSize = 12 * dpr + &quot;px&quot;; &#125; else &#123; document.addEventListener(&quot;DOMContentLoaded&quot;, setBodyFontSize); &#125; &#125; setBodyFontSize(); // set 1rem = viewWidth / 10 function setRemUnit() &#123; var rem = docEl.clientWidth / 10; docEl.style.fontSize = rem + &quot;px&quot;; &#125; setRemUnit(); // reset rem unit on page resize window.addEventListener(&quot;resize&quot;, setRemUnit); window.addEventListener(&quot;pageshow&quot;, function (e) &#123; if (e.persisted) &#123; setRemUnit(); &#125; &#125;); // detect 0.5px supports if (dpr &gt;= 2) &#123; var fakeBody = document.createElement(&quot;body&quot;); var testElement = document.createElement(&quot;div&quot;); testElement.style.border = &quot;.5px solid transparent&quot;; fakeBody.appendChild(testElement); docEl.appendChild(fakeBody); if (testElement.offsetHeight === 1) &#123; docEl.classList.add(&quot;hairlines&quot;); &#125; docEl.removeChild(fakeBody); &#125;&#125;)(window, document); 15. 视口单位vw 和 vh 是 css 中的一个相对的长度单位，被称之为视口单位。 vw 就是 viewport width，表示它相对于视口的宽度进行计算。 vh 就是 viewport height，表示它相对于视口的高度进行计算。 1vw &#x3D; 1&#x2F;100 视口宽度，如果视口的宽度是 375px，那么 1vw &#x3D; 3.75px。 1vh &#x3D; 1&#x2F;100 视口高度，如果视口的高度是 667px，那么 1vh &#x3D; 6.76px。 123456.box &#123; /* 如果视口宽度是 375, 50 * 3.75 = 187.5 30 * 3.75 = 112.5 */ width: 50vw; height: 30vw; background: skyblue;&#125; 123456.box &#123; /* 如果视口高度是 667, 50 * 6.67 = 333.5 30 * 6.67 = 200.1 */ width: 50vh; height: 30vh; background: skyblue;&#125; 设计稿的宽度是 750px，设计稿中有一个盒子的宽高分别为 100px 和 50px，如何将它们转换为 vw 单位？ 我们可以将设计稿的宽度看成是某一个移动设备的视口宽度，那么在该视口宽度下 1vw &#x3D; 7.5px。 我们只需要使用 100px 除以 7.5px ，50px 除以 7.5px，就可以得到盒子的对应的宽高 vw 值。 123456.box &#123; /* 设计稿宽度 750, 100 / 7.5 = 13.333vw 50 / 7.5 = 6.666vw */ width: 13.333vw; height: 6.666vw; background: skyblue;&#125; 注意一般在使用视口单位布局时，一个盒子的宽高一般不会混用 vw 和 vh，一般会基于 vw。 通过配置 cssrem 插件启用对 vw 的支持，使插件辅助我们计算最终的 vw 值。 1234&#123; &quot;cssrem.vw&quot;: true, &quot;cssrem.vwHover&quot;: true&#125;","tags":["面试题"],"categories":["前端面试题"]},{"title":"HTML面试题","path":"/面试题/HTML面试题/","content":"HTML 高频面试题01. HTML 语义化① 什么是 HTML 语义化 HTML 是一门标记语言，在这门语言中每一个标记都被赋予了特殊的含义。 开发者在构建页面布局时应使用恰当语义的 HTML 标签进行内容的展示。 123456789101112131415161718192021222324252627282930&lt;!-- 用于定义标题 --&gt;&lt;h1&gt;&lt;/h1&gt;&lt;!-- 用于定义页面头部区域或 section 区域的页眉 --&gt;&lt;header&gt;&lt;/header&gt;&lt;!-- 用于定义网页导航链接区域 --&gt;&lt;nav&gt;&lt;/nav&gt;&lt;!-- 用于定义页面主体内容, 一个页面只能使用一次 --&gt;&lt;main&gt;&lt;/main&gt;&lt;!-- 用于定义一个页面中的一块自成一体的内容, 可以有自己的 header、footer、section 等 --&gt;&lt;article&gt;&lt;/article&gt;&lt;!-- 在 article 外, 主要用于定义页面侧边栏区域 --&gt;&lt;!-- 在 article 内, 主要用于定义主要内容的附属内容 --&gt;&lt;aside&gt;&lt;/aside&gt;&lt;!-- 表示有语义化的 div, 用于标记页面中的各个部分 --&gt;&lt;section&gt;&lt;/section&gt;&lt;!-- 用于定义页面底部区域 --&gt;&lt;footer&gt;&lt;/footer&gt;&lt;!-- 用于定义标题组 --&gt;&lt;hgroup&gt;&lt;/hgroup&gt;&lt;!-- 用于标记强调文本 --&gt;&lt;strong&gt;&lt;/strong&gt;&lt;!-- 用于标记一个段落 --&gt;&lt;p&gt;&lt;/p&gt;&lt;!-- 用于标记一个独立的流内容, 比如图像、图标、代码等等 --&gt;&lt;figure&gt; &lt;img src=&quot;/media/cc0-images/elephant-660-480.jpg&quot; alt=&quot;Elephant at sunset&quot; /&gt; &lt;figcaption&gt;An elephant at sunset&lt;/figcaption&gt;&lt;/figure&gt;&lt;!-- 用于标记时间 --&gt;&lt;time&gt;2011-01-28&lt;/time&gt; ② HTML 语义化有什么好处 (1) 语义化的 HTML 代码使开发者更容易理解，增加了程序的可阅读性便于团队开发和维护 (2) 使搜索引擎能够快速定位网页中的重要内容，爬虫是依赖于标签来确定上下文和各个关键字的权重 (3) 在没有 CSS 样式情况下也能够让页面呈现出清晰的结构 (一些标记自带样式) (4) 极大程度利用标签的特点优化用户体验，比如 img 标记的 alt 属性和 title 属性、比如 label 标记 02. 块级元素与行内元素① 在 HTML 语言中哪些标记属于块级元素、哪些标记属于行内元素、哪些标记属于行内块元素 display 属性值为 block 或 table 的元素属于块级元素。 1234567&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;/h1&gt;&lt;ul&gt;&lt;/ul&gt;&lt;ol&gt;&lt;/ol&gt;&lt;table&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt; display 属性值为 inline 的元素属于行内元素。 12345&lt;span&gt;&lt;/span&gt;&lt;a&gt;&lt;/a&gt;&lt;b&gt;&lt;/b&gt;&lt;strong&gt;&lt;/strong&gt;&lt;i&gt;&lt;/i&gt; display 属性值为 inline-block 的元素属于行内块元素 123&lt;img /&gt;&lt;input /&gt;&lt;button&gt;&lt;/button&gt; ② 块级元素有什么特点 (1) 块级元素独占一行 (2) 块级元素的宽度默认为 100% (3) 块级元素的高度、行高、外边距、内边距可控 (4) 可以包含行内元素可块级元素 ③ 行内元素有什么特点 (1) 行内元素可以与其他行内元素同在一行，在一行排不下的情况下才会换行显示 (2) 行内元素可设置水平方向上的内边距和外边距、垂直方向无效 (3) 行内元素不能设置宽度和高度，其宽度和高度由内容自动撑开 (4) 行内元素只能包含其他行内元素或文本 ④ 行内块元素有什么特点 (1) 和相邻的行内元素(行内块)在一行上但是中间会有空白的间隙 (2) 可设置宽度、但默认宽度为内容撑开的宽度 (3) 高度、内边距、外边距都可以设置 (4) 行内块元素不能转化为行内元素 ⑤ 通过哪些方式可以将行内元素转换为块级元素 1234567display: block;/* 为行内元素设置 float:left/right 后, 该元素的 display 属性会被设置 block, 且拥有浮动特性。 */float: left;float: right;/* 为行内元素设置决定定位或固定定位时, 会使得行内元素变为块级元素。 */position: absolute;position: fixed; 03. src 属性与 href 属性的区别src 属性和 href 属性都可以用来引入外部的资源。 src 全称 source，通过 src 属性指向的内容会嵌入到文档中标签所在位置比如 js 脚本、img 图片。 当浏览器解析到该元素时，会暂停其它资源下载直到将该资源加载、编译、执行完毕。 正因为该特性所以我们才建议将 js 脚本放置在页面底部加载，防止阻塞页面加载影响用户体验。 href 全称 hyper reference 表示超文本引用，用于建立标签与外部资源的关系。 当浏览器解析到该元素时，会和其他资源并行下载，并不会停止对文档的解析，通常用于超链接和样式表的加载。 由于并行加载特性所以我们才建议将样式表文件防止在页面顶部加载，防止出现页面裸奔现象。 123456&lt;link href=&quot;cssfile.css&quot; /&gt;&lt;a href=&quot;http://www.webpage.com&quot;&gt;&lt;/a&gt;&lt;script src=&quot;myscript.js&quot;&gt;&lt;/script&gt;&lt;img src=&quot;mypic.jpg&quot; /&gt;&lt;video src=&quot;&quot;&gt;&lt;/video&gt;&lt;audio src=&quot;&quot;&gt;&lt;/audio&gt; 04. 图像标记的 title 属性与 alt 属性alt 属性全称 alternate 表示备用，如果图像无法显示浏览器将渲染 alt 指定的内容。 title 属性表示图像的标题，当鼠标移动到图像上时显示 title 属性值中的内容。 1&lt;img src=&quot;&quot; title=&quot;鼠标移入图像时展示的内容&quot; alt=&quot;图像无法显示时展示的内容&quot; /&gt; 05. label 标签的作用label 标签的作用是为使用鼠标的用户改进了可用性，当用户点击 label 标签中的文本时浏览器就会自动将焦点转到和该标签相关联的表单控件上。 123456&lt;form&gt; &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; /&gt; &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot; /&gt;&lt;/form&gt; 06. GET 与 POST 的区别GET 和 POST，两者都是 HTTP 协议中发送请求的方法。 GET 一般用于从服务器端获取数据，POST 一般用于向服务器端传送数据。 GET 和 POST 本质上使用的都是 TCP 链接并无差别，但由于 HTTP 的规定和浏览器&#x2F;服务器的限制，导致他们在使用过程中会体现出一些区别。 ① GET 在浏览器回退时是无害的而 POST 会再次提交请求。 ② GET 产生的 URL 地址可以被存储为书签而 POST 不可以。 ③ GET 请求会被浏览器主动缓存而 POST 不会，除非手动设置。 ④ GET 请求只能进行 url 编码而 POST 支持多种编码方式。 ⑤ GET 请求参数会被完整保留在浏览器历史记录里而 POST 中的参数不会被保留。 ⑥ GET 请求在 URL 中传送的参数是有长度限制的而 POST 没有。 ⑦ GET 比 POST 更不安全，因为参数直接暴露在 URL 中，所以不能用来传递敏感信息。 ⑧ GET 参数通过 URL 传递，POST 放在请求体中。","tags":["面试题"],"categories":["前端面试题"]},{"title":"React路由[V6]","path":"/React/react路由v6/","content":"React 路由[V6]1.集成应用1234//创建应用create-react-app 项目名//安装路由库npm install react-router-dom@6.4.3 项目中应用 1234567891011121314// src/index.jsimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;// createBrowserRouter: 用于创建基于浏览器历史记录的路由系统// RouterProvider: 用于配置路由系统的组件import &#123; createBrowserRouter, RouterProvider &#125; from &quot;react-router-dom&quot;;// 创建路由系统const router = createBrowserRouter([ // 当用户在浏览器中访问 / 路径时,渲染对应组件 &#123; path: &quot;/&quot;, element: &lt;Home /&gt; &#125;,]);const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));// 使路由规则生效root.render(&lt;RouterProvider router=&#123;router&#125; /&gt;); 2.配置路由组件01.创建页面组件 123456789101112// src/pages/home/index.jsimport React from &quot;react&quot;;export default function HomePage() &#123; return &lt;div&gt;首页页面&lt;/div&gt;;&#125;// src/pages/news/index.jsimport React from &quot;react&quot;;export default function HomePage() &#123; return &lt;div&gt;新闻页面&lt;/div&gt;;&#125; 02.配置路由规则 123456789// src/index.jsimport HomePage from &quot;./pages/home&quot;;// 注意: 在 v6 版本中，请求路径 / 不再需要使用 exact 属性const router = createBrowserRouter([ // 当用户在浏览器中访问 / 路径时, 渲染 &lt;HomePage /&gt; 组件 &#123; path: &quot;/&quot;, element: &lt;HomePage /&gt; &#125;, // 当用户在浏览器中访问 /topic 路径时, 渲染 &lt;TopicPage /&gt; 组件 &#123; path: &quot;/topic&quot;, element: &lt;TopicPage /&gt; &#125;,]); 3.嵌套路由使一级路由和二级路由关联 12345678910111213const router = createBrowserRouter([ // 当用户在浏览器中访问 /news 路径时, 渲染 &lt;NewsPage /&gt; 组件 &#123; path: &quot;/news&quot;, element: &lt;NewsPage /&gt;, children: [ // 当用户在浏览器中访问 /news/company 路径时, 将 &lt;CompanyNewsPage /&gt; 组件渲染到 &lt;NewsPage /&gt; 组件中 &#123; path: &quot;company&quot;, element: &lt;CompanyNewsPage /&gt; &#125;, // 当用户在浏览器中访问 /news/industry 路径时, 将 &lt;IndustryNewsPage /&gt; 组件渲染到 &lt;NewsPage /&gt; 组件中 &#123; path: &quot;industry&quot;, element: &lt;IndustryNewsPage /&gt; &#125;, ], &#125;,]); 在一级路由页面添加占位符()给子级路由渲染位置 1234567// src/pages/news/index.jsimport &#123; Outlet &#125; from &quot;react-router-dom&quot;;export default function NewsPage() &#123; // 子路由页面组件将会被渲染到占位符组件所在的位置 return &lt;Outlet /&gt;;&#125; 4.导航链接使用 react 提供的 Link 组件实现路由跳转, 通过 NavLink 组件生成的链接在被激活时 React Router 会为其添加激活类名，默认激活类名为 active 1234567891011 &lt;div&gt; &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt; &lt;ink to=&quot;/topic&quot;&gt;专题&lt;/Link&gt; &lt;ink to=&quot;/news&quot;&gt;新闻&lt;/Link&gt; &lt;/div&gt;----------------------------&lt;div&gt; &lt;NavLink to=&quot;/&quot;&gt;首页&lt;/NavLink&gt; &lt;NavLink to=&quot;/topic&quot;&gt;专题&lt;/NavLink&gt; &lt;NavLink to=&quot;/news&quot;&gt;新闻&lt;/NavLink&gt; &lt;/div&gt; 5.路由路径传参01.路由规则定义可选参数 1&#123;path:&quot;url/:参数名&quot;,element:&lt;路由指向的组件/&gt;&#125; 02.页面组件中实现参数传递 (to&#x3D;”url&#x2F;参数”) 12345678910111213141516import &#123; Link &#125; from &quot;react-router-dom&quot;;export default function Page() &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&quot;/team/team-a&quot;&gt;Team A&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/team/team-b&quot;&gt;Team B&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; );&#125; 12//获取路由参数 -参数名为路由规则中的:参数名const &#123; 参数名 &#125; = useParams(); 6.路由查询参数在页面组件中进行页面跳转时实现路由传递参数 01.配置路由规则 1234567const router = createBrowserRouter([ &#123; path: &quot;/&quot;, element: &lt;Layout /&gt;, children: [&#123; path: &quot;login&quot;, element: &lt;LoginPage /&gt; &#125;], &#125;,]); 02.页面组件传参 （路径？路由参数） 1234567export default function HomePage() &#123; return ( &lt;p&gt; &lt;Link to=&quot;/login?returnUrl=testUrl&quot;&gt;登录&lt;/Link&gt; &lt;/p&gt; );&#125; 03.获取路由参数 1234// 获取路由查询参数操作对象const [searchParams] = useSearchParams();// 获取路由参数 returnUrl 的值const returnUrl = searchParams.get(&quot;returnUrl&quot;); 7.页面跳转回到顶部01.页面在进行跳转时滚动的位置不会回滚到顶部使用 react 提供的组件可以在跳转的页面实现页面回滚到顶部 12345import &#123; ScrollRestoration &#125; from &quot;react-router-dom&quot;;export default function Layout() &#123; return &lt;ScrollRestoration /&gt;;&#125; 02.阻止回滚到顶部通过 Link 组件的 preventScrollReset 选项阻止滚动恢复 123&lt;Link to=&quot;/topic&quot; preventScrollReset=&#123;true&#125;&gt; 专题&lt;/Link&gt; 8.路由组件懒加载01.通过 React 提供的 lazy 方法和 Suspense 组件实现路由组件懒加载lazy 方法用于懒加载组件、Suspense 组件用于渲染加载过程中的等待状态。 12345678910111213141516171819202122// 通过懒加载的方式导入组件const HomePage = lazy(() =&gt; import(&quot;./pages/home&quot;));//组件实现懒加载状态const router = createBrowserRouter([ &#123; path: &quot;/&quot;, element: &lt;Layout /&gt;, children: [ &#123; path: &quot;&quot;, element: ( &lt;Suspense fallback=&#123;&lt;Fallback /&gt;&#125;&gt; // &lt;Fallback /&gt; 为组件加载过程中的样式组件 &lt;HomePage /&gt; &lt;/Suspense&gt; ), &#125;, ], &#125;,]); 02.Suspense 组件复用实现懒加载状态 创建 loadable 方法复用 Suspense 组件 123456789export default function loadable(Component) &#123; return function (props) &#123; return ( &lt;Suspense fallback=&#123;&lt;Fallback /&gt;&#125;&gt; &lt;Component &#123;...props&#125; /&gt; &lt;/Suspense&gt; ); &#125;;&#125; 123456// src/index.js// 1. 多行选择: 按住鼠标滚动拖动// 2. 选择下一个单词: alt + shift + =&gt;// 3. 选择到行尾: ctrl + shift + =&gt;// 4. 选择下一个字符: shift + =&gt;const HomePage = loadable(lazy(() =&gt; import(&quot;./pages/home&quot;))); 9.404 页面配置创建自己定义的 404 组件页面 NotFoundPage，使用 errorElement 方法，当用户访问了一个不存在的路由路径时就会跳转该页面。 1234567const router = createBrowserRouter([ &#123; path: &quot;/&quot;, // 当用户访问了一个不存在的路由路径时, 渲染 PageNotFound 组件 errorElement: &lt;NotFoundPage /&gt;, &#125;,]);","tags":["React"],"categories":["React使用"]},{"title":"ReduxToolkit全局状态管理","path":"/React/ReduxToolkit全局状态管理/","content":"ReduxToolkitReduxToolkit 是官方推出的基于 Redux 进行高度封装的工具包，不需下载就可下载，在开发过程中可以用更少的代码完成工作。 使用12345# 新项目# Redux + Plain JS templatenpx create-react-app my-app --template redux# Redux + TypeScript templatenpx create-react-app my-app --template redux-typescript 12# 现有项目 (@reduxjs/toolkit 和 react-redux 都自带ts类型声明文件, 不需要单独下载)npm install @reduxjs/toolkit@1.9.5 react-redux@8.0.5 一、方法1.createActioncreateAction 用于创建 action creator 函数，接收 action 对象的 type 属性作为参数 1export const creator = createAction(&quot;type&quot;); 2.createReducercreateReducer 用于创建 reducer 函数，使 reducer 函数中的代码细化和拆分。 addCase 调度操作的 action.type 与提供字段完全匹配运行 reducer。 addMatcher 里提供的函数返回 true 时运行 reducer。 123456export const Reducer = createReducer(state, (builder) =&gt; &#123; builder .addCase(creator, () =&gt; (&#123;&#125;)) .addMatcher((action) =&gt; action.type === &quot;action.type&quot;), (state, action) =&gt; (&#123;&#125;);&#125;); 3.configureStoreconfigureStore 创建和配置 Redux 的 store 对象。 1234567export const store = configureStore(&#123; reducer: &#123; counterReducer, &#125;, //是否开启redux工具 devTools: process.env.NODE_ENV !== &quot;production&quot;,&#125;); 4.useSelectoruseSelector 用于在函数式组件中获取 store 对象中的状态的方法,接收函数为参数，参数函数的参数表示状态对象，参数函数返回要获取的具体状态。 1const useSelector((state)=&gt;state.counterReducer.count); 5.useDispatchuseDispatch 是用于在函数式组件中获取 dispatch 的方法 12const dispatch = useDispatch();dispatch(获取dispatch); 6.createAsyncThunkcreateAsyncThunk 用于创建执行异步操作的 action creator 函数。第一个参数是 action 对象的 type 属性，第二个参数是指向异步操作的函数。 1234567export const Creators = createAsyncThunk(&quot;type属性&quot;, async () =&gt; &#123; const res = await axios.get(&quot;http://123&quot;); return res;&#125;);//Creators.pending-&gt;加载//Creators.fulfilled-&gt;请求成功//Creators.rejected-&gt;请求失败 调用 1234567891011121314151617181920const initialState = &#123; status: &quot;idle&quot;, data: [], error: null &#125;;export const Reducer = createReducer(initialState, (builder) =&gt; &#123; builder .addCase(loadTodos.pending, () =&gt; (&#123; status: &quot;loading&quot;, data: [], error: null, &#125;)) .addCase(loadTodos.fulfilled, (state, action) =&gt; (&#123; status: &quot;success&quot;, data: action.payload, error: null, &#125;)) .addCase(loadTodos.rejected, (state, action) =&gt; (&#123; status: &quot;error&quot;, data: [], error: action.error, &#125;));&#125;); 7.createSlice 状态切片action creator 函数、reducer 函数全部都由状态切片生成，状态切片可以使在开发时更专注于状态的管理。 1234567891011121314151617181920212223242526272829import &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;;// createSlice 方法的返回值是一个对象// actions: 该对象中存储的是操作状态 action creator 函数, reducers 配置对象中的函数名称将会作为 action creator 函数的名称// reducer: 原本开发者自己定义的 reducer 函数const &#123; actions, reducer: counterReducer &#125; = createSlice(&#123; // 状态名称, 该名称将会被用于 action 对象的 type 属性值的第一部分 name: &quot;counter&quot;, // 初始状态 initialState: &#123; count: 0 &#125;, // 方法接收两个参数, state 对象和 action 对象 // 在方法中可以直接对状态对象进行操作, 不需要返回新的状态对象 // 调用 action creator 函数时传递的参数将会被放置在 action.payload 属性中 reducers: &#123; increment: (state) =&gt; &#123; state.count += 1; &#125;, decrement: (state) =&gt; &#123; state.count -= 1; &#125;, incrementByCount: (state, action) =&gt; &#123; state.count = state.count + action.payload; &#125;, &#125;,&#125;);// 导出 action creator 函数供组件使用export const &#123; increment, decrement, incrementByCount &#125; = actions;// 导出 counterReducer 函数export default counterReducer; 7.1createSlice_prepareprepare 方法允许开发者在 action 指令发出后 reducer 函数接收前先对 action 对象中的 payload 属性值进行处理。 123456789101112incrementByCount: &#123; prepare: (payload) =&gt; &#123; // prepare 方法接收 payload 作为参数 // 要求返回对象, 该对象会和 action 对象进行合并 return &#123; payload: payload + 10, &#125;; &#125;, reducer: (state, action) =&gt; &#123; state.count = state.count + action.payload; &#125;, &#125;, 8.configureStore_middleware 配置中间件middleware 选项的值是一个函数，该函数有一个参数，该参数习惯被命名为 getDefaultMiddeware，它就是用来获取内置中间件函数的。etDefaultMiddeware 方法的返回值是一个数组，数组中包含内置的中间件函数，开发者只需要在该数组中添加中间件函数即可。middleware 选项要求在该函数中返回最新的中间件函数数组。 12345678//npm i redux-logger@3.0.6import logger from &quot;redux-logger&quot;;export const store = configureStore(&#123; middleware: (getDefaultMiddleware) =&gt; &#123; return getDefaultMiddleware().concat(logger); &#125;,&#125;);","tags":["React"],"categories":["React使用"]},{"title":"React 函数组件","path":"/React/react函数组件/","content":"一、函数组件函数组件是一个返回视图(JSX)的函数。 1.创建函数组件123function App() &#123; return &lt;div&gt;APP&lt;/div&gt;;&#125; 2.函数组件使用方法01.useState 声明组件状态​ 在 React 函数组件中可以通过 useState 方法创建组件状态，可以被调用多次声明多个状态。 123456789101112131415161718//useState方法返回值是一个数组，第一个参数是状态变量，第二个参数是修改/更新状态的方法。function App() &#123; const [value, setValue] = useState(&quot;状态初始值&quot;); const [count, seCount] = useState(0); retutn( &lt;&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;p&gt;&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setValue(&quot;修改的值&quot;)&#125;&gt;更改状态&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setVlaue(count + 1)&#125;&gt;更改数值+1&lt;/button&gt; //更新状态方法可以接收函数作为参数，通过参数函数返回值指定新状态值 //prevState表示更新前状态 //参数函数返回值表示更新后状态 &lt;button onClick=&#123;() =&gt; setCount((prevState) =&gt; prevState - 1)&#125;&gt; 更新数值-1 &lt;/button&gt; &lt;/&gt; );&#125; ​ 当多次调用修改状态的方法时，当传递状态值，最后面的状态会覆盖前面状态；当传递函数，顺序执行，所有函数执行完毕才会更新。 123456789101112131415161718192021222324//传递状态值，最后结果为count+2&lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setCount(count + 1); setCount(count + 1); setCount(count + 2); &#125; &#125; &gt; &#123;count&#125; &lt;/button&gt;//传递函数方法，顺序执行+1+1+1+1返回最终相加结果&lt;button onClick=&#123;() =&gt; &#123; setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); setCount((prevState) =&gt; prevState + 1); &#125; &#125; &gt; &#123;count&#125; &lt;/button&gt; 02.useEffect 确保函数式组件正确执行副作用代码​ 在 React 中，副作用指与组件渲染无关的操作，如获取数据、修改全局变量、更新 DOM 等。这些操作可能会影响组件渲染结果，但不能被纯函数捕获，因此需 useEffect 进行特殊处理，确保代码在正确时机执行。 ​ useEffect 接收一个回调函数和一个依赖数组作为参数，回调函数的代码会在组件渲染完成后执行，依赖数组的变量会在其发生变化时触发回调函数重新执行。 1234const [参数变量, 修改方法代码] = useState(&quot;&quot;);useEffect(() =&gt; &#123; //回调函数代码&#125;, [&quot;参数变量&quot;]); 03.useRef 获取 DOM 对象​ 通过 useRef 方法可以在函数式组件中获取 DOM 对象 1234function App()&#123; const name = useRef(); return &lt;input ref=&#123;name&#125; onChange=&#123;()=&gt;consloe.lgo(name.current)&#125;/&gt;&#125; 04.forwardRef 获取子组件 DOM 对象​ 通过 useRef 和 forward 高阶函数配合使用可以实现父子组件之间传递 ref 对象。 12345678910//appfunction App() &#123; const appref = useRef(); return &lt;Message ref=&#123;appref&#125; /&gt;;&#125;//messagefunction Message(props, ref) &#123; return &lt;span ref=&#123;ref&#125;&gt;message&lt;/span&gt;;&#125;export default forwardRef(Message); 05.受控组件和非受控组件受控表单组件 ​ 表单状态由 React 组件状态控制 12345678910111213141516171819202122232425function App() &#123; const [formState, setFormState] = useState(&#123; username: &quot;&quot;, password: &quot;&quot; &#125;); const onChangeHandler = (event) =&gt; &#123; setFormState(&#123; ...formState, [event.target.name]: event.target.value, &#125;); &#125;; return ( &lt;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&#123;formState.username&#125; onChange=&#123;onChangeHandler&#125; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&#123;formState.password&#125; onChange=&#123;onChangeHandler&#125; /&gt; &lt;/&gt; );&#125; 非受控表单组件 ​ 通过 DOM 获取&#x2F;修改值，使用 useRef 实现非受控表单组件 12345678910111213function App() &#123; const usernameRef = useRef(); const onSubmijs = (event) =&gt; &#123; event.preventDefault(); console.log(usernameRef.current.value); &#125;; return ( &lt;form onSubmit=&#123;onSubmijs&#125;&gt; &lt;input type=&quot;text&quot; ref=&#123;usernameRef&#125; /&gt; &lt;button&gt;button&lt;/button&gt; &lt;/form&gt; );&#125; 06.父子组件通信 - Props1.父组件传递状态到子组件，子组件修改父组件传递的状态值。 1234567891011//父组件function App() &#123; const [msg, setMsg] = useState(&quot;hello&quot;); //传递给子组件 return &lt;Message msg=&#123;mgs&#125; setMsg=&#123;setMsg&#125;&gt;&lt;/Message&gt;;&#125;//子组件function Message(props) &#123; //接收父组件传递的数据 return &lt;button onClick=&#123;() =&gt; props.setMsg(&quot;你好&quot;)&#125;&gt;&#123;props.msg&#125;&lt;/button&gt;;&#125; 2.设置 Props 对象默认值方式 123456789101112131415161718192021222324252627function App(props) &#123; return ( &lt;div&gt; &lt;Message name=&#123;&quot;张三&quot;&#125; age=&#123;30&#125; /&gt; &lt;/div&gt; );&#125;function Message(&#123; name = &quot;李四&quot;, age = 20 &#125;) &#123; return ( &lt;div&gt; &#123;name&#125; &#123;age&#125; &lt;/div&gt; );&#125;export default App;-------------------------function App()&#123; return &lt;Message/&gt;;&#125;function Message(&#123;name,age&#125;)&#123; return &lt;div&gt;&#123;name&#125;&#123;age&#125;&lt;/div&gt;&#125;Message.defaultProps=&#123; name:&quot;张三&quot;, age:20&#125; 07.父子组件通信-useImperativeHandle​ useImperativeHandle 允许父组件直接调用子组件暴露的成员属性和方法。 12345678910111213141516//App.jsfunction App() &#123; const msgRef = useRef(); return ( &lt;&gt; &lt;Message ref=&#123;msgRef&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; console.log(msgRef.current.value); &#125;&#125; &gt; getMsg &lt;/button&gt; &lt;/&gt; );&#125; 12345678910111213//Messagefunction Message(props, ref) &#123; const [value, setValue] = useState(&quot;&quot;); //useImperativeHandle用于设置ref对象中current属性的值，(参数传递ref对象，传递函数(函数返回什么ref对象的current属性值就是什么，组件每次重新渲染时执行)，数组(传递依赖状态)) useImperativeHandle(ref, () =&gt; (&#123; vlaue &#125;), [value]); return ( &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;(event) =&gt; setValue(event.target.value)&#125; /&gt; );&#125; 08.跨级组件通讯-useContext在组件中创建导出的对象，另一个组件中通过 useContext 方法就那些获取。 12345//创建上下文对象export const PersonContext = createContext(&#123; name: &quot;张三&quot;, age: 20 &#125;);//获取上下文状态const person = useContext(PersonContext); 09.组件状态逻辑分离-useReduceruseReducer 是 React 提供的另一种在函数式组件中声明状态的方式。将组件状态逻辑和组件渲染逻辑进行分离，使代码更加清晰可维护。useReducer 是 useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。 1234567891011121314151617function App()&#123; const [state,dispatch] = useReducer(counterReducer,&#123;count:0&#125;); return &lt;button onClick=&#123;()=&gt;dispatch(&#123;type:&quot;counter/increent&quot;&#125;)&#125;&gt;&#123;state.count&#125;&lt;/button&gt;&#125;-----------------------// src/counterReducer.jsexport default function counterReducer(state, action) &#123; switch (action.type) &#123; case &quot;counter/increment&quot;: return &#123; ...state, count: state.count + 1, &#125;; default: return state; &#125;&#125; 10.保存组件值-useRefuseRef 可以获取 DOM 元素，保存普通值；使用 useRef 保存的普通值并不会随组件更新而销毁，修改通过 useRef 保存的值也不会触发组件更新。 例：组件初次渲染开启定时器，点击按钮进行清空。 1234567891011121314151617181920212223function App(props) &#123; // 根据useRef设置定时器; const [count, setCount] = useState(0); // 保存定时器id const intervalRef = useRef(); useEffect(() =&gt; &#123; //开启定时器 intervalRef.current = window.setInterval(() =&gt; &#123; setCount((prevState) =&gt; prevState + 1); &#125;, 1000); return () =&gt; clearInterval(intervalRef.current); &#125;, []); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; clearInterval(intervalRef.current)&#125;&gt; 清除定时器 &lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount((prevState) =&gt; prevState + 1)&#125;&gt; &#123;count&#125;数值加1 &lt;/button&gt; &lt;/div&gt; );&#125;","tags":["React"],"categories":["React使用"]},{"title":"React 基本使用","path":"/React/react基本使用/","content":"react 使用一、react 基础01.react 基本使用1.react 概念 react 概念 React 是一个开源的 JavaScript 库，用于构建 web 应用中的视图层，既是 web 应用的前端用户页面。（一个用于构建用户界面的 javascript 库，与 2012 年由 Facebook 创建，13 年 5 月开源维护） 2.创建 react 项目指令使用 123456#全局安装react脚手架npm install create-react-app@5.0.1 -g#创建项目 名称create-react-app react-basic#进入项目根目录启动项目npm start 目录结构分析 1234567891011121314151617181920# 项目结构分析├── README.md # 项目的说明书├── package.json # npm 包说明文件、记录项目信息├── package-lock.json # 跟踪被安装的每个软件包的确切版本├── public # 本地开发服务器提供的静态资源目录│ ├── favicon.ico # 网站图标、显示在浏览器的标签栏中│ ├── index.html # 项目的 HTML 模板│ ├── logo192.png # react logo 图片 (示例代码中用于设置 IOS 移动端网站图标)│ ├── logo512.png # react logo 图片│ ├── manifest.json # web 应用清单如名称, 作者, 图标和描述 (主要用于将 Web 应用程序安装到设备的主屏幕)│ └── robots.txt # 爬虫协议文件└── src # 项目源码目录 ├── App.css # 示例程序中的根组件样式文件 ├── App.js # 示例程序中的根组件文件 ├── App.test.js # 示例程序中的根组件测试文件 ├── index.css # 示例程序中的全局样式文件 ├── index.js # 项目的入口文件 ├── logo.svg # 示例程序中根组件中显示的网站图标文件 ├── reportWebVitals.js # 测试应用程序的性能 └── setupTests.js # 项目的测试文件 3.react 初使用123456789101112#创建h1元素#参数属性-》(标记名称，标记属性，子元素...);const title = React.createElement( &quot;h1&quot;, &#123;title:&quot;hello&quot;,id:1&#125;, &quot;hello react&quot;)document.createElement(&quot;h1&quot;);#获取public文件下的index.html中的div盒子idconst root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;))#使用render方法生成template模板root.render(title); 4.JSX 概述 jsx 概念 jsx 语法是 React 提供另一种创建用户界面的方式，看起来很像 HTML,但他绝不是 HTML,他是一只 JavaScript 语法扩展。facebook 处于性能考虑，解决必须通过 React.createElement 创建元素，创建出了 jsx，在应用构建的过程中 jsx 由 babel(js 编译器)转换成 React.createElement 方法调用 代码样式 1234567891011const list = ( &lt;div className=&quot;list&quot;&gt; &lt;h2&gt;Hello React&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;hello&lt;/li&gt; &lt;li&gt;react&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;);const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(list); 5.JSX 注意事项(1)JSX 格式美化 当 jsx 中存在多个标记使用小括号（）进行包裹，使代码格式美化排列，创建元素时，元素的最外层必须要有一个根标记 1234567const jsx = ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;); (2)避免出现无意义标记，可使用幽灵标记&lt;&gt;&lt;&#x2F;&gt;(完整语法&lt;React.Fragment&gt;&lt;&#x2F;React.Fragment&gt;) 123456const jsx = ( &lt;&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;/&gt;); (3)JSX 中使用单标签必须是闭合状态 12&lt;input type=&quot;text&quot;/&gt;&lt;img src=&quot;&quot; alt=&quot;&quot;/&gt; (4)在 JSX 中标记属性使用小驼峰命名法 （由多个单词组成，第一个单词首字符小写，其他单词首字符大写） 1&lt;input maxLength=&quot;100&quot; readOnly autoFocus /&gt; (5)在 JSX 中为元素添加属性时使用 className 代替 class、htmlFor 代替 for （jsx 本质上是 javaScript） 12&lt;input type=&quot;text&quot; className=&quot;todos&quot;/&gt;&lt;label htmlFor=&quot;demo&quot;/&gt; 6.JSX 嵌入表达式含义：将表达式产生的值渲染到用户界面中。 表达式就是一个能够产生结果的式子,jsx 里面只能放表达式，非表达式不能被嵌入 JSX 插入值（{}花括号）包裹插入属性值 123//插入文本内容const name = &quot;张三&quot;;const jsx = &lt;div&gt;&#123;name&#125;&lt;/div&gt;; 123//插入属性值const activeName = &quot;active&quot;;const jsx = &lt;input type=&quot;text&quot; className=&#123;activeName&#125; /&gt;; 1234//计算const x = 10;const y = 20;const jsx = &lt;p&gt;&#123;x * y&#125;&lt;/p&gt;; 12345//渲染函数返回值function getValue() &#123; return &quot;jsx&quot;;&#125;const jsx = &lt;p&gt;&#123;getValue()&#125;&lt;/p&gt;; 123//表达式const status = true;const jsx = status ? &lt;div&gt;true&lt;/div&gt; : &lt;div&gt;false&lt;/div&gt;; 12//插入对象 内容中不能直接插入对象const jsx = &lt;p style=&#123;&#123; width: 200 &#125;&#125;&gt;&#123;&#123; name: &quot;jsx&quot; &#125;&#125;&lt;/p&gt;; 1234//注释&#123; /**/&#125; 7.条件渲染（1）使用 if 分支语句进行条件渲染 123456789const Status = fasle;function getContent() &#123; if (Status) &#123; return &lt;span&gt;true&lt;/span&gt;; &#125; else &#123; return &lt;span&gt;fasle&lt;/span&gt;; &#125;&#125;const jsx = &lt;div&gt;&#123;getContent()&#125;&lt;/div&gt;; （2）使用三元运算符进行条件渲染 12const Status = false;const jsx = Status:&lt;span&gt;true&lt;/span&gt;:&lt;span&gt;false&lt;/span&gt; (3)使用逻辑运算符进行条件渲染 123逻辑运算符 &amp;&amp;,全为真时返回真，有一个为假返回假true&amp;&amp;truefalse&amp;&amp;true","tags":["React"],"categories":["React使用"]},{"title":"React性能优化","path":"/React/react性能优化/","content":"React 组件性能优化1. memoReact.memo 可以对组件输入数据进行浅层比较(简单数据类型比较值，引用数据类型比较内存的引用地址)，如果输入数据没有变化则阻止组件更新。 2. useMemoReact.useMemo 用于在函数式组件中缓存值，避免重复操作执行影响组件运行性能。 3. useCallbackReact.useCallback 用于在函数式组件中缓存方法，避免组件每次重新渲染时都返回一个新方法。 4. useDeferredValueReact.useDeferredValue 用于获取一个延时更新的值，让 React 在空闲时去更新值；在频繁更新视图的场景下可以避免出现视图卡顿现象。 5. useTransitionReact.useTransition 用于允许开发者点赞状态渲染的优先级；可以将资源密集型任务优先级降低，等待 React 空闲时执行，避免页面出现卡顿现象。","tags":["React"],"categories":["React使用"]},{"title":"React + TypeScript - 类组件","path":"/React/react-ts-类组件/","content":"React + TypeScript - 类组件1.应用创建使用官方提供脚手架，创建指令后添加–template typescript 即可 1npm create-react-app 文件名 --template typescript 创建应用后项目中包含 jsx 代码文件后缀为.tsx，不包含 jsx 代码的文件为.ts 2.Component 泛型类标注 Props 和 States 对象的类型 123456789101112131415161718192021222324interface Props &#123; name: string;&#125;interface States &#123; count: number;&#125;//使用泛型类export default class App extends React.Components&lt;Props, States&gt; &#123; constructor(props: Readonly&lt;Props&gt;) &#123; super(props); this.state = &#123; count: 0, &#125;; &#125; render() &#123; return ( &lt;&gt; &lt;div&gt;&#123;name&#125;&lt;/div&gt; &lt;/&gt; ); &#125;&#125;//index.tsx&lt;APP name=&#123;&quot;张三&quot;&#125; /&gt;; 3.标注 React 元素类型01.React 元素含义：通过 React.createElement 方法创建的元素、通过 JSX 语法创建的元素。（虚拟 DOM 对象） 12const title = React.createElement(&quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;);const title2 = &lt;h1 className=&quot;one&quot;&gt;Hello&lt;/h1&gt;; 02.标注 React 元素类型 使用 ReactElement 和 JSX.Element 都可以标注元素的类型 1234567891011import &#123; ReactElement &#125; from &quot;react&quot;;const title: ReactElement = React.createElement( &quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;);const titl2: JSXElement = React.createElement( &quot;h1&quot;, &#123; className: &quot;one&quot; &#125;, &quot;Hello&quot;); 4.ReactPortal(了解)ReactPortal 表示 ReactDOM.createPortal 方法的返回值类型 123render():ReactPortal&#123; return createPortal(&lt;div&gt;&lt;/div&gt;)&#125; 5.ReactNodeReactNode 表示可渲染的任意值，包括布尔值，数字，字符串，数组等，是 React 中最泛化的类型 123456789type ReactNode = | ReactElement | string | number | ReactFragment | ReactPortal | boolean | null | undefined; 6.ReactFragmentReactFragment 表示一组可以被遍历渲染的任意值，只用于标注组件 children 属性的类型。 123456789//type ReactFragment = Interble&lt;ReactNode&gt;interface Props &#123; children: ReactFragment;&#125;&lt;App&gt; &#123;/* 不能只有一个, 只能多个 */&#125; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt;&lt;/App&gt;; 7.CSSPropertiesCSSProperties 用于标注 styles 属性值的类型，对样式值对象的属性及属性值的类型进行约束。 1234interface Props &#123; style?: React.CSSProperties;&#125;&lt;div style=&#123;this.props.style&#125;&gt;&lt;/div&gt;; 8.标注事件对象的类型MouseEvent 用于标注鼠标事件对应的事件对象的类型。onClickHandler KeyboardEvent 用于标注键盘事件对应的事件对象的类型。onKeyUpHandler FormEvent 用于标注表单提交事件对应的事件对象的类型。onSubmitHandler UIEvent 通用的和用户界面相关的事件的事件对象类型，一般我们使用 UIEvent 标注滚动事件的事件对象类型、加载事件的事件对象类型等。onScrollHandler 123function on事件名(event:React.标注事件类型&lt;HTML事件Element&gt;)&#123;&#125;//等价写法const on事件名:React.标注事件类型Handler&lt;HTML事件Element&gt;=(event)=》&#123;&#125; 9.DefaultPropsdefaultProps 中添加属性之后，该属性变为可选，在调用当前组件时不传递该属性也可以通过 ts 的编译 123456789101112131415interface Props&#123; name:string; age:number;&#125;export default class App extends React.Component&lt;Props&gt;&#123; static defaultProps:Pick&lt;Props&gt; = &#123; name:&quot;默认&quot; &#125;; render() &#123; return &lt;div&gt;APP&lt;/div&gt;; &#125;&#125;//index.tsx&lt;App /&gt;&lt;App greetings=&#123;&quot;Hello world&quot;&#125; age=&#123;20&#125; /&gt;","tags":["React"],"categories":["React使用"]},{"path":"/about/index.html","content":"联系方式 手机：156****9428 Email：331****&#x33;&#50;&#48;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#109; QQ&#x2F;微信号：331***320&#x2F;A331****420 个人信息 国朋&#x2F;男&#x2F;2001 本科&#x2F;上海开发大学 工作年限：3 年 技术博客：http://mistbollon.github.io Github：http://github.com/mistbollon 期望职位：Web 前端程序员 期望薪资：税前月薪 15k~20k，特别喜欢的公司可例外 期望城市：北京 工作经历（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组） ABC 公司 （ 2012 年 9 月 ~ 2014 年 9 月 ）DEF 项目我在此项目负责了哪些工作，分别在哪些地方做得出色&#x2F;和别人不一样&#x2F;成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写 2~3 个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） 开源项目和作品开源项目 STU：项目的简要说明，Star 和 Fork 数多的可以注明 WXYZ：项目的简要说明，Star 和 Fork 数多的可以注明 技能清单 Web 开发：PHP&#x2F;Hack&#x2F;Node Web 框架：ThinkPHP&#x2F;Yaf&#x2F;Yii&#x2F;Lavaral&#x2F;LazyPHP 前端框架：Bootstrap&#x2F;AngularJS&#x2F;EmberJS&#x2F;HTML5&#x2F;Cocos2dJS&#x2F;ionic 前端工具：Bower&#x2F;Gulp&#x2F;SaSS&#x2F;LeSS&#x2F;PhoneGap 数据库相关：MySQL&#x2F;PgSQL&#x2F;PDO&#x2F;SQLite 版本管理、文档和自动化部署工具：Svn&#x2F;Git&#x2F;PHPDoc&#x2F;Phing&#x2F;Composer 单元测试：PHPUnit&#x2F;SimpleTest&#x2F;Qunit 云和开放平台：SAE&#x2F;BAE&#x2F;AWS&#x2F;微博开放平台&#x2F;微信应用开发 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"这是分页标题","path":"/wiki/conduit/07-综合案例-conduit.html","content":"综合案例 - conduit"},{"title":"项目配置","path":"/wiki/React/支持 TypeScript 的 React 应用.html","content":"React+ Type Script 应用1.应用创建12create-react-app 项目名称 --template typescriptnpm start 2.配置路径别名 (使用@可以找到要导入的部分)配置路径别名分为两部分，第一部分是使 Vs Code 识别路径别名(代码提示)，第二部分是使 web pack 识别路径别名(编译代码)。 ① 在应用的根目录下创建 tsconfig.paths.json 文件用于扩展 TS 配置选项，当前用于配置路径别名。 12345678910111213141516&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@shared/*&quot;: [&quot;./src/shared/*&quot;], &quot;@pages/*&quot;: [&quot;./src/pages/*&quot;], &quot;@router/*&quot;: [&quot;./src/router/*&quot;], &quot;@store/*&quot;: [&quot;./src/store/*&quot;], &quot;@slice/*&quot;: [&quot;./src/store/slice/*&quot;], &quot;@service/*&quot;: [&quot;./src/store/service/*&quot;], &quot;@middlewares/*&quot;:[&quot;./src/store/middlewares/*&quot;], &quot;@styles/*&quot;: [&quot;./src/assets/styles/*&quot;], &quot;@images/*&quot;: [&quot;./src/assets/images/*&quot;] &#125; &#125;&#125; ② 在 tsconfig.json 文件中添加以下配置使用扩展配置文件生效 123&#123; &quot;extends&quot;: &quot;./tsconfig.paths.json&quot;&#125; ③ 覆盖 CRA 默认配置使 webpack 能够支持解析路径别名 1npm install react-app-rewired@2.2.1 react-app-alias@2.2.2 --save-dev 1234567// config-overrides.jsconst &#123; aliasWebpack &#125; = require(&quot;react-app-alias&quot;);module.exports = function override(config) &#123; aliasWebpack(&#123; tsconfig: &quot;./tsconfig.json&quot; &#125;)(config); return config;&#125;; 123456// package.json&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;,&#125;, 3.配置应用环境变量文件根目录创建.env 文件配置项目 API 接口地址 12# .env.developmentREACT_APP_BASE_URL=开发环境接口地址 12# .env.productionREACT_APP_BASE_URL=生产环境接口地址 VS Code 中添加 12345// settings.json&quot;files.associations&quot;: &#123; &quot;*.env.development&quot;: &quot;env&quot;, &quot;*.env.production&quot;: &quot;env&quot;&#125; 4.配置全局状态管理库① 在应用中下载 redux toolkit 和 react-redux 1npm install @reduxjs/toolkit@1.9.1 react-redux@8.0.5 ② 创建全局的 API 状态切片 12345678910// src/store/service/index.tsimport &#123; createApi, fetchBaseQuery &#125; from &quot;@reduxjs/toolkit/query/react&quot;;const apiService = createApi(&#123; reducerPath: &quot;apiReducer&quot;, baseQuery: fetchBaseQuery(&#123; baseUrl: process.env.REACT_APP_BASE_URL &#125;), endpoints: () =&gt; (&#123;&#125;),&#125;);export default apiService; ③ 创建 store 对象并配置 API 状态切片 123456789101112131415161718192021// src/store/index.tsimport &#123; configureStore &#125; from &quot;@reduxjs/toolkit&quot;;import apiService from &quot;@service/index&quot;;import &#123; useDispatch, TypedUseSelectorHook, useSelector &#125; from &quot;react-redux&quot;;const store = configureStore(&#123; devTools: process.env.NODE_ENV !== &quot;production&quot;, reducer: &#123; [apiService.reducerPath]: apiService.reducer, &#125;, middleware: (getDefaultMiddleware) =&gt; getDefaultMiddleware().concat([apiService.middleware]),&#125;);export default store;export type AppDispatch = typeof store.dispatch;export const useTypedDispatch = () =&gt; useDispatch&lt;AppDispatch&gt;();export type AppState = ReturnType&lt;typeof store.getState&gt;;export const useTypedSelector: TypedUseSelectorHook&lt;AppState&gt; = useSelector; ④ 配置 Provider 组件 123456789// src/index.tsximport &#123; Provider &#125; from &quot;react-redux&quot;;import store from &quot;@store/index&quot;;root.render( &lt;Provider store=&#123;store&#125;&gt; &lt;div&gt;App works&lt;/div&gt; &lt;/Provider&gt;); 5.配置路由管理库① 下载 react-router-dom 路由库 12# 该库自带 TypeScript 类型声明文件 不需要单独下载npm install react-router-dom@6.6.1 ② 创建登录页面路由组件用于测试路由是否配置成功 1234// src/pages/home/index.tsxexport default function HomePage() &#123; return &lt;div&gt;HomePage&lt;/div&gt;;&#125; ③ 创建 AppRouter 组件用于配置应用路由规则 1234567891011121314// src/router/index.tsximport HomePage from &quot;@pages/home&quot;;import &#123; createBrowserRouter, RouterProvider &#125; from &quot;react-router-dom&quot;;export const router = createBrowserRouter([ &#123; path: &quot;/&quot;, element: &lt;HomePage /&gt;, &#125;,]);export default function AppRouter() &#123; return &lt;RouterProvider router=&#123;router&#125; /&gt;;&#125; ④ 在应用入口文件中调用 AppRouter 组件使路由系统生效 12345678// src/index.tsximport AppRouter from &quot;@router/index&quot;;root.render( &lt;Provider store=&#123;store&#125;&gt; &lt;AppRouter /&gt; &lt;/Provider&gt;); 6.配置 CSS 预处理器 LESS1npm i less@4.1.3 less-loader@11.1.0 123456789101112// config-overrides.jsfunction addLessLoader(config) &#123; config.module.rules[1].oneOf.splice(2, 0, &#123; test: /\\.less$/i, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;], &#125;);&#125;module.exports = function override(config) &#123; addLessLoader(config); return config;&#125;; 1234567891011121314151617// src/assets/styles/color.less// 主色@mainColor: #fc6627;// 文字颜色@textColor: #646566;// 文字辅助颜色@textHelperColor: #faab0c;// 边框色@borderColor: #ebedf0;// 成功色@successColor: #07c160;// 报错色@errorColor: #ee0a24;// 通知消息中的文本色@noticeTextColor: #ed6a0c;// 背景色@bgColor: #f8f8f8; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// src/assets/styles/base.less@import &quot;@styles/color.less&quot;;*,*::before,*::after &#123; box-sizing: border-box;&#125;* &#123; margin: 0;&#125;body &#123; -webkit-font-smoothing: antialiased; color: @textColor; font-size: 3.4667vw;&#125;img,picture,video,canvas,svg &#123; display: block; max-width: 100%;&#125;input,button,textarea,select &#123; font: inherit; outline: none; border: none; background: none; color: @textColor;&#125;p,h1,h2,h3,h4,h5,h6 &#123; overflow-wrap: break-word;&#125;ul &#123; padding: 0; list-style: none;&#125;a &#123; text-decoration: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125; 12// src/index.tsximport &quot;@styles/base.less&quot;; 7.解决移动端 1px 边框问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174// src/assets/styles/hairline.less@import &quot;./color&quot;;.scale-hairline-common(@color, @top, @right, @bottom, @left) &#123; content: &quot;&quot;; position: absolute; background-color: @color; display: block; z-index: 1; top: @top; right: @right; bottom: @bottom; left: @left;&#125;.hairline(@direction, @color: @borderColor) when (@direction = &quot;top&quot;) &#123; border-top: 1px solid @color; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; border-top: none; &amp;::before &#123; .scale-hairline-common(@color, 0, auto, auto, 0); width: 100%; height: 1px; transform-origin: 50% 50%; transform: scaleY(0.5); @media (min-resolution: 3dppx) &#123; transform: scaleY(0.33); &#125; &#125; &#125; &#125;&#125;.hairline(@direction, @color: @borderColor) when (@direction = &quot;right&quot;) &#123; border-right: 1px solid @color; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; border-right: none; &amp;::after &#123; .scale-hairline-common(@color, 0, 0, auto, auto); width: 1px; height: 100%; background: @color; transform-origin: 100% 50%; transform: scaleX(0.5); @media (min-resolution: 3dppx) &#123; transform: scaleX(0.33); &#125; &#125; &#125; &#125;&#125;.hairline(@direction, @color: @borderColor) when (@direction = &quot;bottom&quot;) &#123; border-bottom: 1px solid @color; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; border-bottom: none; &amp;::after &#123; .scale-hairline-common(@color, auto, auto, 0, 0); width: 100%; height: 1px; transform-origin: 50% 100%; transform: scaleY(0.5); @media (min-resolution: 3dppx) &#123; transform: scaleY(0.33); &#125; &#125; &#125; &#125;&#125;.hairline(@direction, @color: @borderColor) when (@direction = &quot;left&quot;) &#123; border-left: 1px solid @color; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; border-left: none; &amp;::before &#123; .scale-hairline-common(@color, 0, auto, auto, 0); width: 1px; height: 100%; transform-origin: 100% 50%; transform: scaleX(0.5); @media (min-resolution: 3dppx) &#123; transform: scaleX(0.33); &#125; &#125; &#125; &#125;&#125;.hairline(@direction, @color: @borderColor, @radius: 0) when (@direction = &quot;all&quot;) &#123; border: 1px solid @color; border-radius: @radius; html:not([data-scale]) &amp; &#123; @media (min-resolution: 2dppx) &#123; position: relative; border: none; &amp;::before &#123; content: &quot;&quot;; position: absolute; left: 0; top: 0; width: 200%; height: 200%; border: 1px solid @color; border-radius: @radius * 2; transform-origin: 0 0; transform: scale(0.5); box-sizing: border-box; pointer-events: none; // @media (min-resolution: 3dppx) &#123; // width: 300%; // height: 300%; // border-radius: @radius * 3; // transform: scale(0.33); // &#125; &#125; &#125; &#125;&#125;.hairline-remove(@position) when (@position = &quot;left&quot;) &#123; border-left: 0; &amp;:before &#123; display: none !important; &#125;&#125;.hairline-remove(@position) when (@position = &quot;right&quot;) &#123; border-right: 0; &amp;:after &#123; display: none !important; &#125;&#125;.hairline-remove(@position) when (@position = &quot;top&quot;) &#123; border-top: 0; &amp;:before &#123; display: none !important; &#125;&#125;.hairline-remove(@position) when (@position = &quot;bottom&quot;) &#123; border-bottom: 0; &amp;:after &#123; display: none !important; &#125;&#125;.hairline-remove(@position) when (@position = &quot;all&quot;) &#123; border: 0; &amp;:before &#123; display: none !important; &#125;&#125; 1234567891011// src/pages/home/index.tsximport styles from &quot;./styles.module.less&quot;;export default function HomePage() &#123; return ( &lt;&gt; &lt;div className=&#123;styles.one&#125;&gt;&lt;/div&gt; &lt;div className=&#123;styles.two&#125;&gt;&lt;/div&gt; &lt;/&gt; );&#125; 12345678910111213// src/pages/home/styles.module.less@import &quot;@styles/hairline.less&quot;;.one &#123; border-bottom: 1px solid red; margin: 10px 0;&#125;.two &#123; /* 注意: 设置1像素边框的元素必须是相对定位的 */ position: relative; .hairline(&quot;bottom&quot;, green);&#125; 1234567// src/@types/less.d.tsdeclare module &quot;*.module.less&quot; &#123; const classes: &#123; readonly [key: string]: string; &#125;; export default classes;&#125;"}]