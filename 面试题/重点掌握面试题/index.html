<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>重点掌握面试题 - GuoPeng Blog</title>

  
    <meta name="description" content="001：1、react 有哪些性能优化的点 11、https:&#x2F;&#x2F;github.com&#x2F;brickspert&#x2F;blog&#x2F;issues&#x2F;36  2、v8 垃圾回收机制 1https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6844904016325902344  3、CSS 样式隔离手段 1https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6844904034281734151#heading-9  4、行内">
<meta property="og:type" content="article">
<meta property="og:title" content="重点掌握面试题">
<meta property="og:url" content="http://example.com/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%87%8D%E7%82%B9%E6%8E%8C%E6%8F%A1%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="GuoPeng Blog">
<meta property="og:description" content="001：1、react 有哪些性能优化的点 11、https:&#x2F;&#x2F;github.com&#x2F;brickspert&#x2F;blog&#x2F;issues&#x2F;36  2、v8 垃圾回收机制 1https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6844904016325902344  3、CSS 样式隔离手段 1https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6844904034281734151#heading-9  4、行内">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-01T01:00:00.000Z">
<meta property="article:modified_time" content="2023-06-15T01:40:53.133Z">
<meta property="article:author" content="陈国朋">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="/images/favicon.ico">
  

  

  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/images/snow-leopard.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">GuoPeng</div><div class="sub normal cap">欢迎来到我的博客</div><div class="sub hover cap" style="opacity:0"> 淡泊明志</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">笔记</a><a class="nav-item" href="/wiki/">项目</a><a class="nav-item" href="/about/">关于</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>



<widget class="widget-wrapper recent"><div class="widget-header cap theme dis-select"><span class="name">最近更新</span></div><div class="widget-body related-posts fs14"><a class="item title" href="/Vue/Vue%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"><span class="title">Vue状态管理</span></a><a class="item title" href="/Vue/Vue%E6%8C%87%E4%BB%A4/"><span class="title">Vue指令v-指令名</span></a><a class="item title" href="/React/react%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6/"><span class="title">React 函数组件</span></a><a class="item title" href="/React/react%E8%B7%AF%E7%94%B1v6/"><span class="title">React路由[V6]</span></a><a class="item title" href="/%E9%9D%A2%E8%AF%95%E9%A2%98/React%E4%B8%93%E9%A2%98/"><span class="title">React专题</span></a></div></widget>





</div>


    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div id="post-meta">发布于&nbsp;<time datetime="2023-03-01T01:00:00.000Z">2023-03-01</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>重点掌握面试题</span></h1>
<p><strong>001：</strong><br>1、react 有哪些性能优化的点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="attr">https</span>:<span class="comment">//github.com/brickspert/blog/issues/36</span></span><br></pre></td></tr></table></figure>

<p>2、v8 垃圾回收机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://juejin.cn/post/6844904016325902344</span><br></pre></td></tr></table></figure>

<p>3、CSS 样式隔离手段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://juejin.cn/post/6844904034281734151#heading-9</span><br></pre></td></tr></table></figure>

<p>4、行内元素、块级元素有哪些，区别是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">什么叫行内元素？</span><br><span class="line"></span><br><span class="line">常见的span、a、lable、strong、b等html标签都是行内元素</span><br><span class="line"></span><br><span class="line">什么叫块级元素？</span><br><span class="line"></span><br><span class="line">常见的div、p、li、h1、h2、h3、h4等html标签都是块级元素</span><br><span class="line">行内元素属性:</span><br><span class="line">行内元素属性标签它和其它标签处在同一行内</span><br><span class="line">行内元素属性标签无法设置宽度，高度 距顶部距离 距底部距离</span><br><span class="line">行内元素属性标签的宽度是直接由内部的文字或者图片等内容撑开的</span><br><span class="line">行内元素属性标签内部不能嵌套行属性标签（a链接内不能嵌套其他链接）</span><br><span class="line">块级元素属性:</span><br><span class="line">每一个块级元素属性标签都是从新的一行开始，而且之后的元素也都会从新的一行开始（因为每一个块属性标签都会直接占据一整行的内容，导致下面的内容也只能从新的一行开始）</span><br><span class="line">块级元素属性标签都是可以设置宽度、高度，行高，距顶部距离，距底部距离</span><br><span class="line">块级元素属性标签的宽度假如不做设置，会直接默认为父元素宽度的<span class="number">100</span>%</span><br><span class="line">块级元素属性标签是可以直接嵌套的</span><br><span class="line">p标签中不能嵌套div标签</span><br></pre></td></tr></table></figure>

<p>5、聊下你知道的浏览器架构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">浏览器进程（Browser process）</span><br><span class="line">浏览器进程负责管理 Chrome 应用本身，包括地址栏、书签、前进和后退按钮。同时也负责可不见的功能，比如网络请求、文件按访问等，也负责其他进程的调度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">渲染进程（Renderer process）</span><br><span class="line">渲染进程负责站点的渲染，其中也包括 JavaScript 代码的运行，web worker 的管理等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">插件进程（Plugin process）</span><br><span class="line">插件进程负责为浏览器提供各种额外的插件功能，例如 flash。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GPU 进程（GPU process）</span><br><span class="line">GPU 进程负责提供成像的功能。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当然还有其他像扩展进程或工具进程等其他进程，可以在 Chrome 的 Task Manager 面板中查看，面板中列出了运行的进程和其占用的 CPU、内存情况。</span><br><span class="line">https://xie.infoq.cn/article/5d36d123bfd1c56688e125ad3</span><br></pre></td></tr></table></figure>

<p>6、是否有写过 webpack 插件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">看下webpack.config.js   如果没有运行 yarn eject 就会解包处理config文件夹，文件夹中包含。</span><br><span class="line">https://juejin.cn/post/6844903789804126222</span><br></pre></td></tr></table></figure>

<p>7、websocket 建立过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/LL845876425/article/details/106393358</span><br></pre></td></tr></table></figure>

<p>8、合并二维有序数组成一维有序数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce((m,n)=&gt;m.concat(n))</span><br><span class="line">arr.flat()</span><br><span class="line">[].concat.apply([],arr)</span><br></pre></td></tr></table></figure>

<p>9、实现防抖函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">E</span>:</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">func, wait</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(func, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">D</span>:</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">callback,delay</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> timer=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> that=<span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> args=<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(timer !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timer=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            callback.<span class="title function_">apply</span>(that,args)</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>10、Vue 首屏白屏或者加载慢如何解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://juejin.cn/post/6995455015972241444</span><br></pre></td></tr></table></figure>

<p>11、Vue 线上环境和开发环境如何切换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.env文件或者env,js文件，再通过process.env判断切换</span><br></pre></td></tr></table></figure>

<p>12、谈谈 axios 拦截器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求拦截器和响应拦截器;</span><br><span class="line">请求拦截器;</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(func);</span><br><span class="line">响应拦截器;</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(func);</span><br></pre></td></tr></table></figure>

<p>13、hash 和 history 路由的区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/Charissa2017/article/details/104779412</span><br></pre></td></tr></table></figure>

<p>14、call，apply 和 bind 的作用和区别？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">call和apply改变了函数的<span class="variable language_">this</span>上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数。</span><br><span class="line">他们俩之间的差别在于参数的区别，call和apply的第一个参数都是要改变上下文的对象，</span><br><span class="line">而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、判断变量类型：</span><br><span class="line"> &lt;script&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> str1 = <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;thomas&#x27;</span> &#125;;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">isArray</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn1</span>(arr1)); <span class="comment">// true // 判断类型的方式，这个最常用语判断array和object，null(因为typeof null等于object)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr1)); <span class="comment">// [object Array]</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(str1)); <span class="comment">// [object String]</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj1)); <span class="comment">// [object Object]</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>)); <span class="comment">// [object Null]</span></span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  <span class="number">2</span>、利用call和apply做继承</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">showName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name</span>)&#123;</span><br><span class="line">      <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Animal.call(this) 的意思就是使用this对象代替Animal对象，那么</span></span><br><span class="line">  <span class="comment">// Cat中不就有Animal的所有属性和方法了吗，Cat对象就能够直接调用Animal的方法以及属性了</span></span><br><span class="line">  <span class="keyword">var</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;TONY&quot;</span>);</span><br><span class="line">  cat.<span class="title function_">showName</span>();   <span class="comment">//TONY</span></span><br><span class="line"></span><br><span class="line">  参考给大家发的有道文档</span><br></pre></td></tr></table></figure>

<p>15、useMemo 的作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据缓存机制，避免在每次渲染时都进行高开销的计算。</span><br><span class="line">https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo</span><br></pre></td></tr></table></figure>

<p>16、react 中发送请求一般在哪个 hook 中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect</span><br></pre></td></tr></table></figure>

<p>17、如何更新组件的状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">render</span><br><span class="line">setState(class component)</span><br><span class="line">forceUpdate(class component)</span><br><span class="line">useState (function component)</span><br></pre></td></tr></table></figure>

<p>18、如何监听 react 状态更新</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">componentWillUpdate</span><br><span class="line">useEffect</span><br></pre></td></tr></table></figure>

<p>19、Vue 中的响应式原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue不支持IE8以下版本的浏览器，因为Vue是基于 Object.defineProperty 来实现数据响应的，而Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因；Vue通过Object.defineProperty的 getter/setter 对收集的依赖项进行监听,在属性被访问和修改时通知变化,进而更新视图数据；</span><br><span class="line">受现代JavaScript 的限制 (以及废弃 Object.observe)，Vue不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让Vue转换它，这样才能让它是响应的。</span><br><span class="line">shim:shim可以将新的API引入到旧的环境中，而且仅靠就环境中已有的手段实现。意思就是Object.defineProperty这个特性是无法使用低级浏览器中的方法来实现的，所以Vue不支持IE8以及更低版本的浏览器。</span><br><span class="line">第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</span><br><span class="line">第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲 染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者， 一旦数据有变动，收到通知，更新视图。</span><br><span class="line">第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:</span><br><span class="line">	1、在自身实例化时往属性订阅器(dep)里面添加自己</span><br><span class="line">	2、自身必须有一个 update()方法</span><br><span class="line">	3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。</span><br><span class="line">第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模 板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据 变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</span><br></pre></td></tr></table></figure>

<p>20、Vue-Router 有哪几种路由守卫?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">全局守卫</span><br><span class="line">router.beforeEach 全局前置守卫</span><br><span class="line">router.beforeResolve  全局解析守卫</span><br><span class="line">router.afterEach 全局后置钩子</span><br><span class="line">路由独享守卫</span><br><span class="line">beforeEnter</span><br><span class="line">路由组件内的守卫</span><br><span class="line">beforeRouteEnter</span><br><span class="line">beforeRouteUpdate</span><br><span class="line">beforeRouteLeave</span><br></pre></td></tr></table></figure>

<p>21、简述 Vuex 的数据传递流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、通过new Vuex.Store()创建一个仓库 state是公共的状态，state---&gt;components渲染页面</span><br><span class="line">2、在组件内部通过this.$store.state.属性 来调用公共状态中的state，进行页面的渲染。</span><br><span class="line">3、当组件需要修改数据的时候，必须遵循单向数据流。通过this.$store.dispatch来触发actions中的方法</span><br><span class="line">4、actions中的每个方法都会接受一个对象 这个对象里面有一个commit方法，用来触发mutations里面的方法</span><br><span class="line">5、mutations里面的方法用来修改state中的数据 mutations里面的方法都会接收到2个参数 一个是store中的state另外一个是需要传递到参数</span><br><span class="line">6、当mutations中的方法执行完毕后state会发生改变，因为vuex的数据是响应式的 所以组件的状态也会发生改变</span><br></pre></td></tr></table></figure>

<p>22、Vue 和 jQuery 两者之间的区别是什么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jquery直接操作dom</span><br><span class="line"></span><br><span class="line">Vue不直接操作dom，采用虚拟dom</span><br><span class="line"></span><br><span class="line">Vue通过数据驱动界面</span><br><span class="line"></span><br><span class="line">jquery通过选择器选取元素，进行取值赋值、事件绑定等操作</span><br><span class="line"></span><br><span class="line">Vue对项目的侵入较强。</span><br></pre></td></tr></table></figure>

<p>23、Object.defineProperty 和 Proxy 的区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）Proxy 的优势如下: Proxy 可以直接监听对象而非属性； Proxy 可以直接监听数组的变化；</span><br><span class="line">Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has等等是Object.defineProperty 不具备的；</span><br><span class="line">Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty 只能遍历对象属性直接修改；</span><br><span class="line">Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的 新标准的性能红利；</span><br><span class="line">2）Object.defineProperty 的优势如下: 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>24、Vue 怎么在组件中监听路由参数的变化？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一种 watch: &#123; &#x27;$route&#x27;(to, from) &#123; // 在此处监听 &#125;, &#125;,</span><br><span class="line">第二种beforeRouteUpdate (to, from, next) &#123; //这里监听 &#125;,</span><br></pre></td></tr></table></figure>

<p>25、watch、methods 和 computed 的区别?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1．computed：计算属性将被混入到Vue实例中。所有getter和setter的this上下文自动地绑定为Vue实例。</span><br><span class="line">2．methods： methods将被混入到Vue实例中。可以直接通过VM实例访问这些方法，或者在指令表达式中使用。方法中的this自动绑定为Vue实例。</span><br><span class="line">3．watch： 观察和响应 Vue 实例上的数据变动，一个对象，键是需要观察的表达式， 值是对应回调函数。值也可以是方法名，或者包含选项的对象，Vue 实例将会在 实例化时调用 $watch()，遍历 watch 对象的每一个属性。</span><br><span class="line">2）三者的加载顺序</span><br><span class="line">	1. computed 是在 HTML DOM 加载后马上执行的，如赋值；（属性将被混入 到 Vue 实例）</span><br><span class="line">	2. methods 则必须要有一定的触发条件才能执行，如点击事件</span><br><span class="line">	3. watch 呢？它用于观察 Vue 实例上的数据变动。</span><br><span class="line">3）默认加载的时候 先 computed 再 watch，不执行 methods；</span><br><span class="line">4）触发某一事件后 先 computed 再 methods 再到 watch computed 属性 vs method 方法 computed 计算属性是基于它们的依赖进行缓存的。</span><br><span class="line">5）总结计算属性computed只有在它的相关依赖发生改变时才会重新求值，当有一个性能开销比较大的的计算属性A，它需要遍历一个极大的数组和做大量的计算，然后我们可能有其他的计算属性依赖于A，这时候，我们就需要缓存，每次确实需要重新加载，不需要缓存时用 methods</span><br></pre></td></tr></table></figure>

<p>26、Vue 循环 key 的作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key 的作用主要是为了高效的更新虚拟 DOM。</span><br></pre></td></tr></table></figure>

<p>27、对比 Vue 和 React 的差异。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line">	数据驱动视图</span><br><span class="line">	组件化</span><br><span class="line">	都使用 Virtual DOM</span><br><span class="line">不同点：</span><br><span class="line">	核心思想不同：React：React推崇函数式编程（纯组件），数据不可变以及单向数据流,当然需要双向的地方也可以手动实现， 比如借助onChange和setState来实现。Vue：灵活易用的渐进式框架，进行数据拦截/代理，它对侦测数据的变化更敏感、更精确</span><br><span class="line">	组件写法不同：react：JSX + inline style vue：template</span><br><span class="line">	diff算法不同</span><br><span class="line">	响应式原理不同：</span><br><span class="line">Vue依赖收集，自动优化，数据可变。</span><br><span class="line">Vue递归监听data的所有属性,直接修改。</span><br><span class="line">当数据改变时，自动找到引用组件重新渲染。</span><br><span class="line"></span><br><span class="line">React基于状态机，手动优化，数据不可变，需要setState驱动新的state替换老的state。当数据改变时，以组件为根目录，默认全部重新渲染, 所以 React 中会需要 shouldComponentUpdate 这个生命周期函数方法来进行控制</span><br></pre></td></tr></table></figure>

<p>28、ES 中 JavaScript 的数据类型有哪些？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>，<span class="literal">null</span>，<span class="literal">undefined</span>,<span class="title class_">Number</span>,<span class="title class_">BigInt</span>,<span class="title class_">String</span>,<span class="title class_">Symbol</span>,<span class="title class_">Object</span></span><br></pre></td></tr></table></figure>

<p>29、在 JavaScript 中，可以通过哪些方式改变 this 指向。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">回答这个首先明确下<span class="variable language_">this</span>的指向问题：</span><br><span class="line">	一般来说，在<span class="variable language_">this</span>指向全局对象<span class="variable language_">window</span>（函数），对象里是指向调用对象，构造函数指向，指向实例，事件指向触发的dom对象，箭头函数没有自己的<span class="variable language_">this</span>，指向外层的代码的<span class="variable language_">this</span>，在严格模式下，<span class="variable language_">this</span>为<span class="literal">undefined</span>。</span><br><span class="line"></span><br><span class="line">  改变<span class="variable language_">this</span>指向可以使用call、apply、bind等方法，具体见题<span class="number">14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>30、http 常见的 header。</p>
<table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>指定客户端能够接收的内容类型</td>
<td>Accept: text&#x2F;plain, text&#x2F;html</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器可以接受的字符编码集。</td>
<td>Accept-Charset: iso-8859-5</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>指定浏览器可以支持的 web 服务器返回内容压缩编码类型。</td>
<td>Accept-Encoding: compress, gzip</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器可接受的语言</td>
<td>Accept-Language: en,zh</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>可以请求网页实体的一个或者多个子范围字段</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Authorization</td>
<td>HTTP 授权的授权证书</td>
<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>指定请求和响应遵循的缓存机制</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接。（HTTP 1.1 默认进行持久连接）</td>
<td>Connection: close</td>
</tr>
<tr>
<td>Cookie</td>
<td>HTTP 请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给 web 服务器。</td>
<td>Cookie: $Version&#x3D;1; Skin&#x3D;new;</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求的内容长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求的与实体对应的 MIME 信息</td>
<td>Content-Type: application&#x2F;x-www-form-urlencoded</td>
</tr>
<tr>
<td>Date</td>
<td>请求发送的日期和时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>Expect</td>
<td>请求的特定的服务器行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>From</td>
<td>发出请求的用户的 Email</td>
<td>From: <a href="mailto:&#117;&#115;&#x65;&#x72;&#x40;&#101;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;">&#117;&#115;&#x65;&#x72;&#x40;&#101;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>Host</td>
<td>指定请求的服务器的域名和端口号</td>
<td>Host: <a target="_blank" rel="noopener" href="http://www.zcmhi.com/">www.zcmhi.com</a></td>
</tr>
<tr>
<td>If-Match</td>
<td>只有请求内容与实体相匹配才有效</td>
<td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回 304 代码</td>
<td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>如果内容未改变返回 304 代码，参数为服务器先前发送的 Etag，与服务器回应的 Etag 比较判断是否改变</td>
<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为 Etag</td>
<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>只在实体在指定时间之后未被修改才请求成功</td>
<td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制信息通过代理和网关传送的时间</td>
<td>Max-Forwards: 10</td>
</tr>
<tr>
<td>Pragma</td>
<td>用来包含实现特定的指令</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>连接到代理的授权证书</td>
<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;</td>
</tr>
<tr>
<td>Range</td>
<td>只请求实体的一部分，指定范围</td>
<td>Range: bytes&#x3D;500-999</td>
</tr>
<tr>
<td>Referer</td>
<td>先前网页的地址，当前请求网页紧随其后,即来路</td>
<td>Referer: <a target="_blank" rel="noopener" href="http://www.zcmhi.com/archives/71.html">http://www.zcmhi.com/archives/71.html</a></td>
</tr>
<tr>
<td>TE</td>
<td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>
<td>TE: trailers,deflate;q&#x3D;0.5</td>
</tr>
<tr>
<td>Upgrade</td>
<td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>
<td>Upgrade: HTTP&#x2F;2.0, SHTTP&#x2F;1.3, IRC&#x2F;6.9, RTA&#x2F;x11</td>
</tr>
<tr>
<td>User-Agent</td>
<td>User-Agent 的内容包含发出请求的用户信息</td>
<td>User-Agent: Mozilla&#x2F;5.0 (Linux; X11)</td>
</tr>
<tr>
<td>Via</td>
<td>通知中间网关或代理服务器地址，通信协议</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache&#x2F;1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>关于消息实体的警告信息</td>
<td>Warn: 199 Miscellaneous warning</td>
</tr>
</tbody></table>
<p>31、http 中 cache-control 的含义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cache</span>-<span class="title class_">Control</span> 通用消息头字段，被用于在http请求和响应中，通过指定指令来实现缓存机制。</span><br><span class="line">详见：<span class="attr">https</span>:<span class="comment">//developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control</span></span><br></pre></td></tr></table></figure>

<p>32、JavaScript 的对象类型包含。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组，函数，正则，日期</span><br></pre></td></tr></table></figure>

<p>33、判断一个变量是值是数组还是对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="comment">// 1.基于instanceof</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="title class_">Array</span>;</span><br><span class="line"><span class="comment">// 2.基于constructor</span></span><br><span class="line">a.<span class="property">constructor</span> === <span class="title class_">Array</span>;</span><br><span class="line"><span class="comment">// 3.基于Object.prototype.isPrototypeOf</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(a);</span><br><span class="line"><span class="comment">// 4.基于getPrototypeOf</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(a) === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="comment">// 5.基于Object.prototype.toString</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(a) === <span class="string">&quot;[object Array]&quot;</span>;</span><br><span class="line"><span class="comment">//Array.isArray 的polyfill</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="property">isArray</span>) &#123;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="property">isArray</span> = <span class="keyword">function</span> (<span class="params">arg</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arg) === <span class="string">&quot;[object Array]&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>34、类数组对象 arguments。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">arguments</span> 是一个对应于传递给函数的参数的类数组对象。<span class="variable language_">arguments</span>对象是所有（非箭头）函数中都可用的局部变量。</span><br></pre></td></tr></table></figure>

<p>35、[“1”,”2”,”3”].map(parseInt)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parseInt(string, radix) -&gt; map(parseInt(value, index))</span></span><br><span class="line"><span class="comment">/*  first iteration (index is 0): */</span> <span class="built_in">parseInt</span>(<span class="string">&quot;1&quot;</span>, <span class="number">0</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">/* second iteration (index is 1): */</span> <span class="built_in">parseInt</span>(<span class="string">&quot;2&quot;</span>, <span class="number">1</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">/*  third iteration (index is 2): */</span> <span class="built_in">parseInt</span>(<span class="string">&quot;3&quot;</span>, <span class="number">2</span>); <span class="comment">// NaN</span></span><br><span class="line">如果radix未指定，且第一个参数为string，radix默认会<span class="number">10</span>。如果radix的小于<span class="number">2</span>或者大于<span class="number">36</span>，返回结果也是<span class="title class_">NaN</span>。</span><br><span class="line">参考：<span class="attr">https</span>:<span class="comment">//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map</span></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt</span></span><br></pre></td></tr></table></figure>

<p>36、JS 模块化规范有哪些？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commomJS,<span class="variable constant_">AMD</span>.<span class="property">CMD</span>,<span class="title class_">ES6</span>模块化，......</span><br></pre></td></tr></table></figure>

<p>37、Array.from 的用法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>() 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&#x27;foo&#x27;</span>));=&gt;[<span class="string">&quot;f&quot;</span>,<span class="string">&quot;o&quot;</span>,<span class="string">&quot;o&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>38、Vue 开发环境和线上环境如何切换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="property">env</span>;</span><br></pre></td></tr></table></figure>

<p>39、Object.defineProperty 和 Proxy 的区别</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考<span class="number">23</span>题;</span><br></pre></td></tr></table></figure>

<p>40、React 怎么在组件中监听路由参数的变化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在<span class="title function_">useEffect</span>()中可以通过history监听路由变化</span><br><span class="line"><span class="keyword">const</span> history = <span class="title function_">useHistory</span>()</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  history.<span class="title function_">listen</span>(<span class="function"><span class="params">historyLocation</span>=&gt;</span>....)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">component</span></span><br><span class="line">  props.<span class="property">history</span></span><br></pre></td></tr></table></figure>

<p>41、对比 Vue 和 React 的差异。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">27</span>题</span><br></pre></td></tr></table></figure>

<p>42、React 项目优化的方式有哪些。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">减少dom更新次数</span><br><span class="line">使用生产版本</span><br><span class="line">长列表优化</span><br><span class="line">webpack压缩（rollup）</span><br><span class="line">缓存</span><br><span class="line"></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//zh-hans.reactjs.org/docs/optimizing-performance.html</span></span><br></pre></td></tr></table></figure>

<p>43、Hash 和 history 路由模式的区别？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hash模式：监听浏览器地址hash值变化，执行相应的js切换网页；</span><br><span class="line">history模式：利用history <span class="variable constant_">API</span>实现url地址改变，网页内容改变；</span><br><span class="line"></span><br><span class="line">hash模式：使用<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。</span><br><span class="line"></span><br><span class="line">history模式：<span class="variable language_">window</span>.<span class="property">history</span> 属性指向 <span class="title class_">History</span> 对象，它表示当前窗口的浏览历史。当发生改变时，只会改变页面的路径，不会刷新页面。</span><br><span class="line">每当 history 对象出现变化时，就会触发 popstate 事件。</span><br><span class="line"></span><br><span class="line">hash 就是指 url 尾巴后的 # 号以及后面的字符，history没有底带#，外观上比hash 模好看些hash回车刷新会加载到地址栏对应的页面，history一般就是<span class="number">404</span>掉了hash 能兼容到<span class="title class_">IE8</span>， history 只能兼容到 <span class="title class_">IE10</span>；</span><br></pre></td></tr></table></figure>

<p>44、call，apply 和 bind 的作用和区别</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>题</span><br></pre></td></tr></table></figure>

<p>45、谈谈 axios 拦截器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求拦截器和响应拦截器;</span><br><span class="line">请求拦截器;</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(func);</span><br><span class="line">响应拦截器;</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(func);</span><br></pre></td></tr></table></figure>

<p>46、谈谈浏览器缓存，如何进行强制缓存？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中<span class="variable constant_">HTTP</span>头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中.缓存分为：</span><br><span class="line">强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程.</span><br><span class="line">协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">控制强制缓存的字段分别是<span class="title class_">Expires</span>和<span class="title class_">Cache</span>-<span class="title class_">Control</span>，其中<span class="title class_">Cache</span>-<span class="title class_">Control</span>优先级比<span class="title class_">Expires</span>高。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Expires</span>是<span class="variable constant_">HTTP</span>/<span class="number">1.0</span>控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于<span class="title class_">Expires</span>的值时，直接使用缓存结果。</span><br><span class="line">在<span class="variable constant_">HTTP</span>/<span class="number">1.1</span>中，<span class="title class_">Cache</span>-<span class="title class_">Control</span>是最重要的规则，主要用于控制网页缓存，主要取值为：</span><br><span class="line">            public：所有内容都将被缓存（客户端和代理服务器都可缓存）</span><br><span class="line">            private：所有内容只有客户端可以缓存，<span class="title class_">Cache</span>-<span class="title class_">Control</span>的默认取值</span><br><span class="line">            no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</span><br><span class="line">            no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</span><br><span class="line">            max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</span><br></pre></td></tr></table></figure>

<p>47、React 如何更改组件的状态，如何去监听组件状态？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>();</span><br></pre></td></tr></table></figure>

<p>48、实现一个算法，生成一个不会重复的 uuid。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Date</span>.<span class="title function_">now</span>().<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line"><span class="title function_">md5</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>());</span><br><span class="line">sha1;</span><br></pre></td></tr></table></figure>

<p>49、定义一个方法，实现数组的扁平化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">核心代码</span><br><span class="line"><span class="number">1</span>、arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)</span><br><span class="line"><span class="number">2</span>、<span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">res,next</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(next)? <span class="title function_">flatten</span>(next) : next);</span><br><span class="line">      &#125;,[]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">3</span>、arr.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>50、定义一个方法，实现数组的排序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">        <span class="keyword">var</span> middle = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        arr[j] = middle;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>51、实现浅拷贝的几种方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="title class_">Object</span>.<span class="title function_">assign</span>(target,source)</span><br><span class="line"><span class="number">2</span>、扩展运算符 <span class="keyword">let</span> cloneObj = &#123; ...obj &#125;</span><br><span class="line"><span class="number">3</span>、<span class="title function_">concat</span>()</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> copyArr = arr.<span class="title function_">concat</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copyArr)</span><br><span class="line"><span class="number">4</span>、<span class="title function_">slice</span>()</span><br></pre></td></tr></table></figure>

<p>52、手写一个浅拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">shallowClone</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (target === <span class="string">&quot;object&quot;</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">        cloneTarget[prop] = target[prop];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, &#123; <span class="attr">name</span>: <span class="string">&quot;apple&quot;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> newArr = <span class="title function_">shallowClone</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr);</span><br></pre></td></tr></table></figure>

<p>53、new 的执行过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;MAN&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">//MAN</span></span><br><span class="line">大致的执行步骤：</span><br><span class="line">创建一个新对象；</span><br><span class="line">将构造函数的作用域赋给新对象（<span class="variable language_">this</span> 指向新对象）；</span><br><span class="line">执行构造函数中的代码（为这个新对象添加属性）；</span><br><span class="line">返回新对象。</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 <span class="keyword">return</span> 语句指定的对象。</span><br></pre></td></tr></table></figure>

<p>54、new 的实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> type !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;type must be function&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="comment">//链接空对象到原型上</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(type.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">//绑定obj的this上下文</span></span><br><span class="line">  <span class="keyword">let</span> res = type.<span class="title function_">apply</span>(obj, args);</span><br><span class="line">  <span class="keyword">let</span> isObject = <span class="keyword">typeof</span> res === <span class="string">&quot;object&quot;</span> &amp;&amp; res !== <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> isFunction = <span class="keyword">typeof</span> res === <span class="string">&quot;function&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> isObject || isFunction ? res : obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">name, color</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  <span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj11 = <span class="title function_">_new</span>(<span class="title class_">Car</span>, <span class="string">&quot;MAN&quot;</span>, [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj11);</span><br></pre></td></tr></table></figure>

<p>55、什么是闭包？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">闭包其实就是一个可以访问其他函数内部变量的函数。即一个定义在函数内部的函数，或者直接说闭包是个内嵌函数也可以。</span><br><span class="line">因为通常情况下，函数内部变量是无法在外部访问的（即全局变量和局部变量的区别），因此使用闭包的作用，就具备实现了能在外部访问某个函数内部变量的功能，让这些内部变量的值始终可以保存在内存中。</span><br><span class="line"><span class="string">&#x27;闭包产生的本质就是：当前环境中存在指向父级作用域的引用。&#x27;</span></span><br></pre></td></tr></table></figure>

<p>56、闭包的表现形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 返回一个函数，上面讲原因的时候已经说过，这里就不赘述了。</span><br><span class="line"><span class="number">2.</span> 在定时器、事件监听、<span class="title class_">Ajax</span> 请求、<span class="title class_">Web</span> <span class="title class_">Workers</span> 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。</span><br><span class="line"><span class="number">3.</span> 作为函数参数传递的形式</span><br><span class="line"><span class="number">4.</span> <span class="variable constant_">IIFE</span>（立即执行函数），创建了闭包，保存了全局作用域（<span class="variable language_">window</span>）和当前函数的作用域</span><br></pre></td></tr></table></figure>

<p>57、循环引用问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上输出的结果是？</span><br><span class="line"></span><br><span class="line">上图的输出结果并不是想象中的  <span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>、<span class="number">4</span>、<span class="number">5</span>。而是<span class="number">6</span>，为什么呢？原因如下：</span><br><span class="line"><span class="number">1</span>、<span class="built_in">setTimeout</span> 为宏任务，由于 <span class="variable constant_">JS</span> 中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 <span class="built_in">setTimeout</span> 中的回调才依次执行。</span><br><span class="line"><span class="number">2</span>、因为 <span class="built_in">setTimeout</span> 函数也是一种闭包，往上找它的父级作用域链就是 <span class="variable language_">window</span>，变量 i 为 <span class="variable language_">window</span> 上的全局变量，开始执行 <span class="built_in">setTimeout</span> 之前变量 i 已经就是 <span class="number">6</span> 了，因此最后输出的连续就都是 <span class="number">6</span>。</span><br><span class="line"><span class="string">&#x27;解决办法：&#x27;</span></span><br><span class="line"><span class="number">1</span>、最简单的使用es6的<span class="keyword">let</span>。</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line"></span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>、利用<span class="variable constant_">IIFE</span> 立即执行函数。</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、利用定时器传入第三个参数。</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">  &#125;, <span class="number">0</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>58、JavaScript 中改变自身的数组方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop、push、reverse、shift、sort、splice、unshift，以及两个 <span class="title class_">ES6</span> 新增的方法 copyWithin 和 fill。</span><br></pre></td></tr></table></figure>

<p>59、JavaScript 中不改变自身的数组方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat、join、slice、toString、toLocaleString、indexOf、lastIndexOf以及 <span class="title class_">ES7</span> 新增的方法 includes。</span><br></pre></td></tr></table></figure>

<p>60、简述 promise，promise 有哪些状态？.then 返回的是什么？promise.race,promise.any,promise.all 分别代表什么意思？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、</span><br><span class="line"><span class="title class_">Promise</span> 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。</span><br><span class="line"><span class="number">2</span>、</span><br><span class="line">待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。</span><br><span class="line">已兑现（fulfilled）: 意味着操作成功完成。</span><br><span class="line">已拒绝（rejected）: 意味着操作失败。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、</span><br><span class="line">因为 <span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> 和  <span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> 方法返回的是 promise， 所以它们可以被链式调用。</span><br><span class="line"><span class="number">4</span>、</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>(iterable)</span><br><span class="line">当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>(iterable)</span><br><span class="line">接收一个<span class="title class_">Promise</span>对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(iterable)</span><br><span class="line">这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，</span><br></pre></td></tr></table></figure>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/%E9%9D%A2%E8%AF%95%E9%A2%98/React%E4%B8%93%E9%A2%98/">React专题</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%E5%9F%BA%E7%A1%80/">前端必问基础</a></div></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期</a><a href="/archives">归档</a><a href="/categories">分类</a><a href="/tags">标签</a></div><div class="sitemap-group"><span class="fs14">更多</span><a href="/">关于本站</a><a target="_blank" rel="noopener" href="https://github.com/mistbollon">GitHub</a></div><div class="sitemap-group"><span class="fs14">项目</span><a target="_blank" rel="noopener" href="https://github.com/mistbollon?tab=repositories">开源库</a></div></div><div class="text"><p>本站由 <a href="/">@GuoPeng</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
<!-- hexo injector body_end start -->
  <style>
    .highlight {
      position: relative;
    }
    .highlight .code .copy-btn{
      position: absolute;
      top: 0;
      right: 0;
      padding: 4px 0.5rem;
      opacity: 0.25;
      font-weight: 700;
      color: var(--theme);
      cursor: pointer;
      transination: opacity 0.3s;
    }
    .highlight .code .copy-btn:hover{
      color: var(--text-code);
      opacity: 0.75;
    }
    .highlight .code .copy-btn.success {
      color: var(--swiper-theme-color);
      opacity: 0.75;

    }
    
  </style>
  <script>
    const codeElementArr = document.querySelectorAll('.code')
    codeElementArr.forEach(code => {
      const codeBeforeWidth = window.getComputedStyle(code, '::before').width.split('px')[0]
      const codeBeforePadding = window.getComputedStyle(code, '::before').padding.split(' ').pop().split('px')[0]
  
      // copy btn 
      const codeCopyBtn = document.createElement('div')
      codeCopyBtn.classList.add('copy-btn')
      codeCopyBtn.style.right = Number(codeBeforeWidth) + Number(codeBeforePadding) * 2 + 'px'
      codeCopyBtn.innerText = 'copy'
      code.appendChild(codeCopyBtn)
  
      codeCopyBtn.addEventListener('click', async () => {
        const currentCodeElement = code.children[0]?.innerText
        await copyCode(currentCodeElement)


        codeCopyBtn.innerText = 'copied'
        codeCopyBtn.classList.add('success')

        setTimeout(() => {
          codeCopyBtn.innerText = 'copy'
          codeCopyBtn.classList.remove('success')
        },1000)
      })
    })
    
    async function copyCode(currentCode) {
      console.log(currentCode)
      console.log('copy')
      if (navigator.clipboard) {
        try {
          await navigator.clipboard.writeText(currentCode)
        } catch (error) {
          // 未获得用户许可
          console.error(error)
        }
      } else {
        console.error('当前浏览器不支持此api')
      }
    }
  </script>
  <!-- hexo injector body_end end --></body>
</html>
